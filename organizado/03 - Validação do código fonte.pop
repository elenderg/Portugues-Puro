 Rotina para que se compile um endereço da pasta (análise dos arquivos fornecidos): \#003
  Se existir algum problema de compilação, retorne.
  Escreva "Analisando código fonte dos arquivos..." junto com o texto CRLF para StdOut.
  Comece o temporizador de análise/verificação.
  Examine os arquivos fontes.
  Suspenda o temporizador de análise/verificação.

Rotina para que se examine uns arquivos fontes:
  \Itere.
  Se existir algum problema de compilação, retorne.
    Obtenha um arquivo fonte desde os arquivos fontes.
    Se o arquivo fonte for inexistente, retorne.
    Examine o arquivo fonte.
  Reitere.

\Um arquivo fonte é uma lista com um endereço completo e um trecho.

Rotina para que se examine um arquivo fonte:
  Se o arquivo fonte for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Lance um percorredor sobre o trecho deste arquivo fonte. \ STRING INICIAL
  Mova o percorredor (usando diretrizes de compilação).
  Itere.
    Se existir algum problema de compilação, retorne.
    Se o segmento inicial deste percorredor estiver em branco, retorne.
    Se o segmento inicial deste percorredor for o início de algum tipo,
      Examine um tipo usando o percorredor;
      Reitere.
    Se o segmento inicial deste percorredor for o início de alguma variável global,
      Examine uma variável global usando o percorredor;
      Reitere.
    Se o segmento inicial deste percorredor for o início de alguma rotina,
      Examine uma rotina usando o percorredor;
      Reitere.
    [Se o segmento inicial deste percorredor for outra coisa]
    Apresente uma mensagem de erro contendo 
      "Código de Erro #004. O compilador não reconhece a sintaxe '" 
      junto com o segmento inicial deste percorredor seguido de "'." 
      junto com o texto CRLF e o percorredor.
  Reitere.

Rotina para que se mova um percorredor (usando diretrizes de compilação): \ talvez aqui conserte o comando "subtraia"
  [Itere.]
    Se o sinalizador de erros deste compilador estiver ativo,
       Limpe o segmento inicial deste percorredor;
       Retorne.
    Mova o percorredor retornando uma string de erro (englobando tudo).
    Se a string de erro não estiver em branco,
       Apresente uma mensagem de erro contendo a string de erro e o caractere inicial deste segmento inicial deste percorredor; \#191
       Retorne.
    \Se o segmento inicial deste percorredor for "del", recue o percorredor; Retorne.
    Se o segmento inicial deste percorredor estiver em branco, retorne.
    Se o conteúdo deste caractere inicial deste segmento inicial deste percorredor for irrelevante, 
      Reitere.
    Se o conteúdo deste caractere inicial deste segmento inicial deste percorredor for a barra invertida, 
      Reitere.
    Se o conteúdo deste caractere inicial deste segmento inicial deste percorredor for o colchete esquerdo, 
      Reitere.
  \Reitere.

Rotina para que se mova um percorredor retornando uma string de erro (englobando tudo):
  Limpe a string de erro.
  Mova o percorredor (englobando tudo).
  Se o segmento inicial deste percorredor estiver em branco, retorne.
  Se o conteúdo deste caractere inicial deste segmento inicial deste percorredor for o colchete esquerdo,
    Mova o percorredor retornando a string de erro (validação de comentários de bloco);
    Retorne.
  Se o conteúdo deste caractere inicial deste segmento inicial deste percorredor for as aspas duplas,
    Mova o percorredor retornando a string de erro (validação de strings literais);
    Retorne.
  Se o conteúdo deste caractere inicial deste segmento inicial deste percorredor for o parênteses esquerdo,
    Mova o percorredor retornando a string de erro (diretrizes de validação de qualificadores);
    Retorne.

Rotina para que se mova um percorredor retornando uma string de erro (validação de comentários de bloco):
  Se a quantidade de caracteres deste segmento inicial deste percorredor for menor do que 2,
    Atribua "Código de Erro #005. Observações devem terminar com um colchete direito ']'." para a string de erro;
    Retorne.
  Se o conteúdo deste caractere final deste segmento inicial deste percorredor não for o colchete direito,
    Atribua "Código de Erro #006. Observações precisam iniciar com um colchete esquerdo '['." para a string de erro;
    Retorne.

Rotina para que se mova um percorredor retornando uma string de erro (validação de strings literais):
  Se a quantidade de caracteres deste segmento inicial deste percorredor for menor do que 2,
    Atribua "Código de Erro #007. Strings literais precisam terminar com aspas duplas: ""." para a string de erro;
    Retorne.
  Se o conteúdo deste caractere final deste segmento inicial deste percorredor não for as aspas duplas,
    Atribua "Código de Erro #008. Strings literais devem começar com aspas duplas: ""." para a string de erro;
    Retorne.

Rotina para que se mova um percorredor retornando uma string de erro (diretrizes de validação de qualificadores):
  Se a quantidade de caracteres deste segmento inicial deste percorredor for menor do que 2,
    Atribua "Código de Erro #009. Qualificadores devem terminar com um parêntese direito ')'." para a string de erro;
    Retorne.
  Se o conteúdo deste caractere final deste segmento inicial deste percorredor não for o parênteses direito,
    Atribua "Código de Erro #010. Qualificadores precisam iniciar com um parêntese direito '('." para a string de erro;
    Retorne.

Rotina para que se apresente uma mensagem de erro contendo uma string e um endereço de byte:
  Se existir algum problema de compilação,
    Retorne.
  Ative o sinalizador de erros deste compilador.
  Atribua a string à mensagem de erro deste compilador.
  Encontre o endereço do arquivo atual deste compilador e o número da linha de erro deste compilador usando o endereço de byte .
  Se o endereço do arquivo atual deste compilador estiver em branco,
    Retorne.
  Extraia um nome do arquivo desde o endereço do arquivo atual deste compilador.
  Anteponha "ALERTA: Não foi possível compilar o arquivo '" junto com o nome do arquivo seguido de "'. " junto com o texto CRLF para a mensagem de erro deste compilador.

Rotina para que se encontre um endereço completo e um número da linha usando um endereço de byte:
  Limpe o endereço completo.
  Atribua 0 ao número da linha.
  Encontre um arquivo fonte usando o endereço de byte .
  Se o arquivo fonte for inexistente, retorne.
  Atribua o endereço completo deste arquivo fonte ao endereço completo.
  Encontre o número da linha usando o arquivo fonte e o endereço de byte.

Rotina para que se encontre um número da linha usando um arquivo fonte e um endereço de byte :
  Se o endereço de byte for inexistente,
    Atribua 0 ao número da linha;
    Retorne.
  Lance um subtexto sobre o trecho deste arquivo fonte.
  Atribua 1 ao número da linha.
  Itere.
    Se o subtexto estiver em branco, retorne.
    Se o caractere inicial deste subtexto for o endereço de byte , retorne.
    Se o conteúdo deste caractere inicial deste subtexto for o retorno de carro, 
      Adicione 1 para o número da linha.
  Adicione 1 para o caractere inicial deste subtexto.
  Reitere.

Rotina para que se encontre um arquivo fonte usando um endereço de byte :
  Se o endereço de byte for inexistente,
    Esvazie o arquivo fonte;
    Retorne.
  Itere.
    Obtenha o arquivo fonte desde os arquivos fontes.
    Se o arquivo fonte for inexistente,
      Retorne.
    Se o endereço de byte for menor do que o caractere inicial deste trecho deste arquivo fonte,
      Reitere.
    Se o endereço de byte for maior do que o caractere final deste trecho deste arquivo fonte,
      Reitere.

Função para que se determine se uma string é o início de algum tipo:
  Se a string for algum artigo indefinido, diga sim.
  Diga não.

\Função para que se determine se uma string é algum artigo indefinido:
  \Se a string for algum artigo indefinido português, diga sim.
  \Se a string for algum pronome demonstrativo abrangente, diga sim. \Duplicado
  \Diga não.

Função para que se determine se uma string é algum artigo indefinido;
Função para que se determine se uma string é algum artigo indefinido português: 
  \PAL
  Se a string for "um", diga sim.
  Se a string for "uma", diga sim.
  Se a string for "uns", diga sim.
  Se a string for "umas", diga sim.
  \Se a string for "outro", diga sim.
  \Se a string for "outra", diga sim.
  \Se a string for "algum", diga sim.
  \Se a string for "alguma", diga sim.
  \Se a string for "alguns", diga sim.
  \Se a string for "algumas", diga sim.
  Se a string for algum pronome demonstrativo abrangente, diga sim. \ para funcionamento dos possessivos - local correto
  Diga não.

Função para que se determine se uma string é algum pronome demonstrativo abrangente:
  Se a string for "esse", diga sim.
  Se a string for "essa", diga sim.
  Se a string for "aquele", diga sim.
  Se a string for "aquela", diga sim.
  Se a string for "esses", diga sim.
  Se a string for "essas", diga sim.
  Se a string for "aqueles", diga sim.
  Se a string for "aquelas", diga sim.
  Se a string for "certo", diga sim.
  Se a string for "certa", diga sim.
  Se a string for "certos", diga sim.
  Se a string for "certas", diga sim.
  Se a string for "determinado", diga sim.
  Se a string for "determinada", diga sim.
  Se a string for "determinados", diga sim.
  Se a string for "determinadas", diga sim.
  Diga não.

\ --------------------------------------------------------------------- VALIDAÇÃO DA SINTAXE DOS TIPOS ----------------------------------------------------------------

Rotina para que se examine um tipo usando um percorredor:
  Se existir algum problema de compilação, retorne.
  Se o segmento inicial deste percorredor for algum artigo indefinido, 
    Ative um sinalizador denominado artigo indefinido.
  Adicione o tipo para os tipos usando o caractere inicial deste segmento inicial deste percorredor.
  Mova o percorredor (usando diretrizes de compilação).
  Examine o nome deste tipo usando o percorredor.
  Atribua o nome deste tipo ao nome plural deste tipo.
  Atribua 0 para uma contagem.
  Se o artigo indefinido estiver ativo,
    Pluralize o nome plural deste tipo;
    Adicione 1 à contagem.
  Se a contagem for igual ou maior do que 2,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #011. não foi possível detectar o idioma desta variável" junto com o texto CRLF e o endereço local deste tipo;
    Retorne.
  Se o segmento inicial deste percorredor for algum operador de atribuição de estruturas compostas,
    Examine o tipo usando o percorredor (cláusula 'tem');
    Retorne.
  Se o segmento inicial deste percorredor não for algum operador de atribuição simples,
    Apresente a mensagem de erro contendo 
      "Código de Erro #012. O compilador esperava encontrar um operador de atribuição ('é' ou 'são'), porém encontrou o seguinte termo: '" 
       junto com o segmento inicial deste percorredor seguido de "'." junto com o texto CRLF e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for algum valor numérico literal,
    Examine o tipo usando o percorredor (unidade de medida);
    Retorne.
  Se o segmento inicial deste percorredor não for algum artigo indefinido,
    Apresente a mensagem de erro contendo 
      "Código de Erro #013. Esperado 'um/uma'. Encontrado '" 
      junto com o segmento inicial deste percorredor seguido de "'." junto com o texto CRLF e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine o nome do tipo primitivo deste tipo usando o percorredor.
  Examine algum dado complementar para o tipo usando o percorredor.
  Se o segmento inicial deste percorredor não for o ponto final,
    Apresente a mensagem de erro contendo 
      "Código de Erro #014. Insira um '.' após a declaração do tipo."
      junto com o segmento inicial deste percorredor seguido de "." junto com o texto CRLF e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Catalogue o tipo.

Rotina para que se adicione um tipo para uns tipos usando um endereço local:
  Crie o tipo.
  Acrescente o tipo para o tipos.
  Atribua o endereço local ao endereço local deste tipo.

Rotina para que se examine um nome usando um percorredor:
  Limpe o nome.
  Se existir algum problema de compilação, retorne.
  Se o percorredor estiver sobre algum indicador de início de variável,
    Expanda o nome com o segmento inicial deste percorredor;
    Mova o percorredor (usando diretrizes de compilação).
  Itere.
    Se existir algum problema de compilação, retorne.
    Se o percorredor estiver sobre algum indicador de fim de variável, pare.
    Expanda o nome com o segmento inicial deste percorredor.
    Mova o percorredor (usando diretrizes de compilação).
  Reitere.
  Se o nome estiver em branco,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #015. A variável '" junto com o segmento inicial deste percorredor 
      seguido de "' não foi definida ainda." junto com o texto CRLF e o percorredor;
    Retorne.

Função para que se determine se um percorredor está sobre algum indicador de início de variável:
  \ compare com indicador de fim de variável
  Se o segmento inicial deste percorredor for algum sinal de pontuação, diga não.
  Se o segmento inicial deste percorredor for algum símbolo, diga não.
  Se o segmento inicial deste percorredor for algum artigo, diga não.
  Se o segmento inicial deste percorredor for alguma conjunção, diga sim.
  Se o segmento inicial deste percorredor for algum possessivo inglês, diga não.
  Se o segmento inicial deste percorredor for algum verbo, diga sim.
  Se o segmento inicial deste percorredor for algum operador aritmético, diga sim.
  Se o percorredor estiver sobre alguma preposição, diga sim.
  Se o segmento inicial deste percorredor for algum qualificador, diga não.
  Se o segmento inicial deste percorredor for algum valor literal, diga não.
  Se o segmento inicial deste percorredor for uma palavra-chave de designação, diga sim.
  Se o segmento inicial deste percorredor for "então", diga sim.
  Se o segmento inicial deste percorredor for algum operador de atribuição composto, diga sim.
  Se o segmento inicial deste percorredor estiver em branco, diga não.
  Diga sim.

Função para que se determine se uma string é algum sinal de pontuação:
  Se a quantidade de caracteres desta string não for 1, diga não.
  Se o conteúdo deste caractere inicial desta string for algum sinal de pontuação, diga sim.
  Diga não.

Função para que se determine se um byte é algum sinal de pontuação:
  Se o byte for o ponto final, diga sim.
  Se o byte for o vírgula, diga sim.
  Se o byte for o ponto&vírgula, diga sim.
  Se o byte for o sinal de dois pontos, diga sim.
  Se o byte for o ponto de exclamação, diga sim.
  Se o byte for o ponto de interrogação, diga sim.
  Diga não.

Função para que se determine se uma string é algum símbolo:
  Se a quantidade de caracteres desta string não for 1, diga não.
  Se o conteúdo deste caractere inicial desta string for algum símbolo, diga sim.
  Diga não.

Função para que se determine se um byte é algum símbolo: 
  \ esta rotina deveria estar na biblioteca padrão
  Se o byte for o acento circunflexo, diga sim.
  Se o byte for o barra vertical, diga sim.
  Se o byte for o asterisco, diga sim.
  Se o byte for o sinal de adição, diga sim.
  Se o byte for o hífen, diga sim.
  Se o byte for o barra inclinada, diga sim.
  Se o byte for o símbolo menor do que, diga sim.
  Se o byte for o símbolo maior do que, diga sim.
  Se o byte for a chave esquerda, diga sim.
  Se o byte for a chave direita, diga sim.
  Se o byte for o sinal de igualdade, diga sim.
  \ Codepage Extended ANSI - Windows-1252 
  Se o byte for 128, diga sim. 
  Se o byte for 130, diga sim.
  Se o byte estiver entre 132 e 137, diga sim.
  Se o byte for 139, diga sim.
  Se o byte estiver entre 145 e 153, diga sim.
  Se o byte for 155, diga sim.
  Se o byte estiver entre 161 e 180, diga sim.
  Se o byte estiver entre 183 e 191, diga sim.
  Se o byte for 215, diga sim.
  Se o byte for 247, diga sim.
  Diga não.

Função para que se determine se uma string é algum artigo:
  Se a string for algum artigo indefinido, diga sim.
  Se a string for algum artigo definido, diga sim.
  Diga não.

Função para que se determine se uma string é algum artigo definido:
  Se a string for "o", diga sim.
  Se a string for "a", diga sim.
  Se a string for "os", diga sim.
  Se a string for "as", diga sim.
  Se a string for algum pronome demonstrativo adjacente, diga sim.
  Diga não.

Função para que se determine se uma string é algum pronome demonstrativo adjacente:
  Se a string for "este", diga sim.
  Se a string for "esta", diga sim.
  Se a string for "estes", diga sim.
  Se a string for "estas", diga sim.
  Diga não.

Função para que se determine se uma string é alguma conjunção:
  \# verificar o uso dos termos: "ambos", "mas" e "nenhum"
  Se a string for "e", diga sim.
  Se a string for "ou", diga sim.
  Se a string for "nem", diga sim.
  \INGLÊS - REMOVER
  Se a string for "neither", diga sim.
  Se a string for "nor", diga sim.
  Diga não.

Função para que se determine se uma string é algum possessivo inglês:
  Se a string for "'s", diga sim.
  Se a string for "'", diga sim.
  Diga não.

Função para que se determine se uma string é algum verbo:
  Se a string for "cabe", diga sim.
  Se a string for "couber", diga sim.
  Se a string for "começa", diga sim.  
  Se a string for "começar", diga sim.  
  Se a string for "conter", diga sim.
  Se a string for "contiver", diga sim.
  Se a string for "contém", diga sim.  
  Se a string for "deve", diga sim.
  Se a string for "devem", diga sim.
  Se a string for "deveria", diga sim.
  Se a string for "deveriam", diga sim.
  Se a string for "estamos", diga sim.
  Se a string for "estar", diga sim.
  Se a string for "estará", diga sim.
  Se a string for "estarão", diga sim.
  Se a string for "estava", diga sim.
  Se a string for "estavam", diga sim.
  Se a string for "estiver", diga sim.
  Se a string for "estiverem", diga sim.
  Se a string for "está", diga sim.
  Se a string for "estão", diga sim.
  Se a string for "excede", diga sim.
  Se a string for "excedem", diga sim.
  Se a string for "existe", diga sim.
  Se a string for "existem", diga sim.
  Se a string for "existir", diga sim.
  Se a string for "finaliza", diga sim.
  Se a string for "finalizar", diga sim.
  Se a string for "é", diga sim.  
  Se a string for "foi", diga sim.
  Se a string for "for", diga sim.
  Se a string for "foram", diga sim.
  Se a string for "forem", diga sim.
  Se a string for "há", diga sim.
  Se a string for "houver", diga sim.  
  Se a string for "inicia", diga sim.
  Se a string for "iniciar", diga sim.
  Se a string for "necessita", diga sim.
  Se a string for "necessitar", diga sim.
  Se a string for "parece", diga sim.
  Se a string for "pode", diga sim.
  Se a string for "podem", diga sim.
  Se a string for "podemos", diga sim.
  Se a string for "poderia", diga sim.
  Se a string for "poderia", diga sim.
  Se a string for "possuem", diga sim.
  Se a string for "possui", diga sim.
  Se a string for "possuir", diga sim.
  Se a string for "puder", diga sim.
  Se a string for "puderem", diga sim.
  Se a string for "requer", diga sim.
  \Se a string for "seja", diga sim.
  Se a string for "ser", diga sim.
  Se a string for "será", diga sim.
  Se a string for "serão", diga sim.
  Se a string for "supera", diga sim.
  Se a string for "superam", diga sim.
  Se a string for "superar", diga sim.
  Se a string for "são", diga sim.
  Se a string for "tem", diga sim.
  Se a string for "ter", diga sim.
  Se a string for "termina", diga sim.
  Se a string for "terminar", diga sim.
  Se a string for "tiver", diga sim.
  Se a string for "têm", diga sim.
  Diga não.

Função para que se determine se uma string é algum operador aritmético:
  Se a string for "mais", diga sim.
  Se a string for "menos", diga sim.
  Se a string for "vezes", diga sim.
  Se a string for "dividido", diga sim.
  \Se a string for "depois", diga sim.
  Se a string for "seguido", diga sim.
  Se a string for "juntamente", diga sim.
  Se a string for "junto", diga sim.
  Se a string for "acompanhado", diga sim.
  Diga não.

Função para que se determine se um percorredor está sobre alguma preposição:
  Atribua o segmento inicial deste percorredor para um subtexto.
  Se o percorredor estiver sobre algum preposição conectiva, diga sim. \ "a" no sentido de "para"
  Se o subtexto for "a_partir_de", diga sim.
  Se o subtexto for "abaixo", diga sim.
  \Se o subtexto for "baixo", diga sim.
  Se o subtexto for "acima", diga sim.
  \Se o subtexto for "cima", diga sim.
  Se o subtexto for "ante", diga sim.
  Se o subtexto for "perante", diga sim.
  Se o subtexto for "antes", diga sim.
  Se o subtexto for "debaixo", diga sim.
  Se o subtexto for "sob", diga sim.
  Se o subtexto for "acerca", diga sim.
  Se o subtexto for "cerca", diga sim.
  Se o subtexto for "cuja", diga sim.
  Se o subtexto for "cujo", diga sim.
  Se o subtexto for "cujas", diga sim.
  Se o subtexto for "cujos", diga sim.
  \Se o subtexto for "próximo", diga sim.
  Se o subtexto for "perto", diga sim.
  Se o subtexto for "com", diga sim.
  \Se o subtexto for "contendo", diga sim.
  Se o subtexto for "tal", diga sim.
  Se o subtexto for "como", diga sim.
  Se o subtexto for "contra", diga sim.
  Se o subtexto for "dada", diga sim.
  Se o subtexto for "dado", diga sim.
  Se o subtexto for "dando", diga sim.
  Se o subtexto for "gerando", diga sim.
  Se o subtexto for "resultando", diga sim.
  Se o subtexto for "retornando", diga sim.
  Se o subtexto for "desde", diga sim.
  Se o subtexto for "depois", diga sim.
  Se o subtexto for "após", diga sim.
  Se o subtexto for "durante", diga sim.
  Se o subtexto for "em", diga sim.
  Se o subtexto for "entre", diga sim.
  Se o subtexto for "dentre", diga sim.
  Se o subtexto for "até", diga sim.
  \Se o subtexto for "que", diga sim.
  \Se o subtexto for "esquerda", diga sim.
  Se o subtexto for "mediante", diga sim.
  Se o subtexto for "para", diga sim.
  Se o subtexto for "via", diga sim.
  Se o subtexto for "segundo", diga sim.
  Se o subtexto for "acordo", diga sim.
  Se o subtexto for "sem", diga sim.
  Se o subtexto for "então", diga sim.
  Se o subtexto for "sobre", diga sim.
  Se o subtexto for "usando", diga sim.
  Se o subtexto for "versus", diga sim.
  Se o subtexto for "enquanto", diga sim.
  Se o subtexto for "aproximadamente", diga sim.
  Se o subtexto for "através", diga sim.
  Se o subtexto for "algum", diga sim.
  Se o subtexto for "sob", diga sim.
  Se o subtexto for "debaixo", diga sim.
  Se o subtexto for "entre", diga sim.
  \Se o subtexto for "baixo", diga sim. -> erro
  Se o subtexto for "por", diga sim.
  Se o subtexto for "usando", diga sim.
  Se o subtexto for "referente", diga sim.
  Se o subtexto for "pertencente", diga sim.
  Se o subtexto for "pertinente", diga sim.
  Se o subtexto for "relativo", diga sim.
  Se o subtexto for "relativa", diga sim.
  Se o subtexto for "concernente", diga sim.
  Se o subtexto for "atinente", diga sim.
  Se o subtexto for "pertinente", diga sim.
  Se o subtexto for "retornando", diga sim.
  Se o subtexto for "começando", diga sim.
  Se o subtexto for "começando", diga sim.
  Se o subtexto for "iniciando", diga sim.
  Se o subtexto for "usando", diga sim.
  Se o subtexto for "via", diga sim.
  Se o subtexto for "com", diga sim.
  Se o subtexto for "aproada", diga sim.
  Se o subtexto for "aproado", diga sim.
  Se o subtexto for "aproando", diga sim.
  Se o subtexto for "orientada", diga sim.
  Se o subtexto for "orientado", diga sim.
  Se o subtexto for "orientando", diga sim.
  Se o subtexto for "orientando-se", diga sim.
  Se o subtexto for "voltada", diga sim.
  Se o subtexto for "voltado", diga sim.
  Se o subtexto for "virada", diga sim.
  Se o subtexto for "virado", diga sim.
  Se o subtexto for "virando", diga sim.
  Se o subtexto for "virando-se", diga sim.
  Se o subtexto for "tão", diga sim.
  Se o subtexto for "tanto", diga sim.
  Se o subtexto for "quanto", diga sim.
  Se o subtexto for "quão", diga sim.
  Se o subtexto for "qual", diga sim.
  Se o subtexto for "after", diga sim.
  Se o subtexto for "regressivamente", diga sim.
  Se o subtexto for "dentro de", diga sim.
  Se o subtexto for "dentro", diga sim.
  Se o subtexto for "parecida", diga sim.
  Se o subtexto for "parecido", diga sim.
  Se o subtexto for "semelhante", diga sim.
  Se o subtexto for "similar", diga sim.
  Se o subtexto for "em comprimento", diga sim.
  Se o subtexto for "d'", diga sim.
  Se o subtexto for "d'", diga sim.
  Se o subtexto for "só", diga sim.
  Se o subtexto for "somente", diga sim.
  Se o subtexto for "unicamente", diga sim.
  Se o subtexto for "exclusivamente", diga sim.
  Se o subtexto for "apenas", diga sim.
  Se o subtexto for "fora", diga sim.
  Se o subtexto for "menores", diga sim.
  Se o subtexto for "alta", diga sim.
  Se o subtexto for "alto", diga sim.
  Se o subtexto for "comprido", diga sim.
  Se o subtexto for "comprida", diga sim.
  Se o subtexto for "largo", diga sim.
  Se o subtexto for "larga", diga sim.
  Diga não.

Função para que se determine se uma string é algum qualificador:
  Se a string estiver em branco, diga não.
  Se o conteúdo deste caractere inicial desta string for o parênteses esquerdo, diga sim.
  Diga não.

Função para que se determine se uma string é algum valor literal:
  Se a string for algum ponteiro literal, diga sim.
  Se a string for algum valor numérico literal, diga sim.
  Se a string for algum string literal, diga sim.
  \Se a string for algum sinalizador literal, diga sim. ***
  Se a string for algum valor hexadecimal literal, diga sim.
  Diga não.

Função para que se determine se uma string é algum ponteiro literal:
  Se a string for "nulo", diga sim.
  Se a string for "nula", diga sim.
  Se a string for "nulos", diga sim.
  Se a string for "nulas", diga sim.
  Se a string for "inexistente", diga sim.
  Se a string for "inexistentes", diga sim.
  Se a string for "zerado", diga sim.
  \CAL
  Se a string for "nil", diga sim.
  Diga não.

Função para que se determine se uma string é algum valor numérico literal:
  Se a string estiver em branco, diga não.
  Se o conteúdo deste caractere inicial desta string não for algum indicador numérico, diga não.
  Se a string é algum número inteiro, diga sim.
  Se a string é algum fração literal, diga sim.
  Se a string é algum numeral misto literal, diga sim.
  Diga não.

Função para que se determine se uma string é alguma string literal;
Função para que se determine se uma string é algum string literal:
  Se a string estiver em branco, diga não.
  Se o conteúdo deste caractere inicial desta string for as aspas duplas, diga sim.
  Diga não.

Função para que se determine se uma string é algum valor hexadecimal literal:
  Se a string estiver em branco, diga não.
  Se o conteúdo deste caractere inicial desta string for o cifrão, diga sim.
  Diga não.

Função para que se determine se uma string é uma palavra-chave de designação:
  Se a string for "chamado", diga sim.
  Se a string for "chamados", diga sim.
  Se a string for "chamada", diga sim.
  Se a string for "chamadas", diga sim.
  Se a string for "denominado", diga sim.
  Se a string for "denominados", diga sim.
  Se a string for "denominada", diga sim.
  Se a string for "denominadas", diga sim.
  Diga não.

Função para que se determine se uma string é algum operador de atribuição composto:
  Se a string for "igual", diga sim.
  Diga não.

Rotina para que se expanda uma string com uma segunda string:
  Se a segunda string estiver em branco, retorne.
  Se a string não estiver em branco, 
    Acrescente o caractere de espaço para a string.
  Acrescente a segunda string para a string.

Função para que se determine se um percorredor está sobre algum indicador de fim de variável:
  \ compare com indicador de início de variável
  Se o segmento inicial deste percorredor for algum sinal de pontuação, diga sim.
  Se o segmento inicial deste percorredor for algum símbolo, diga sim.
  Se o segmento inicial deste percorredor for algum artigo, diga sim.
  Se o segmento inicial deste percorredor for alguma conjunção, diga sim.
  Se o segmento inicial deste percorredor for algum possessivo inglês, diga sim.
  Se o percorredor estiver sobre algum possessivo reverso, diga sim. \ 
  Se o segmento inicial deste percorredor for algum verbo, diga sim.
  Se o segmento inicial deste percorredor for algum operador aritmético, diga sim.
  Se o percorredor estiver sobre alguma preposição, diga sim.
  Se o segmento inicial deste percorredor for algum qualificador, diga sim.
  Se o segmento inicial deste percorredor for algum valor literal, diga sim.
  Se o segmento inicial deste percorredor for uma palavra-chave de designação, diga sim.
  Se o segmento inicial deste percorredor for "então", diga sim.
  Se o segmento inicial deste percorredor for algum operador de atribuição composto, diga sim.
  Se o segmento inicial deste percorredor estiver em branco, diga sim.
  Se o segmento inicial deste percorredor for algum advérbio de negação, diga sim.
  Diga não.

Função para que se determine se um percorredor está sobre algum possessivo reverso:
  Preserve o percorredor.
  Se o segmento inicial deste percorredor não for "de", diga não.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for algum pronome demonstrativo, diga sim.
  Diga não.

Função para que se determine se uma string é algum advérbio de negação:
  Se a string for "não", diga sim.
  Diga não.

Rotina para que se pluralize uma string:
  Lance um percorredor sobre a string.
  Atribua "" para uma string denominada string pluralizada.
  Itere.
    Mova o percorredor (palavras plurais). \ Aqui posso mudar a formação dos plurais.
    Se o segmento inicial deste percorredor estiver em branco, pare. \ Se atingirmos o final da string.
    Se a string pluralizada não estiver em branco, 
      Acrescente " " para a string pluralizada.
    Acrescente o segmento inicial deste percorredor para a string pluralizada.
    Se o segmento inicial deste percorredor for "de",
      Ative um sinalizador;
      Reitere. \ PLURAL
    Se o sinalizador não estiver ativo, 
      Aplique o plural adequado para a string pluralizada.
  Reitere.
  Atribua a string pluralizada à string.

Rotina para que se mova um percorredor (palavras plurais): \ talvez aqui conserte o comando "subtraia"
  [Itere.]
    Se o sinalizador de erros deste compilador estiver ativo,
       Limpe o segmento inicial deste percorredor;
       Retorne.
    Mova o percorredor retornando uma string de erro (plurais).
    \Se a string de erro estiver definida e contiver conteúdo, 
    Se a string de erro não estiver em branco,
       Apresente uma mensagem de erro contendo a string de erro e o caractere inicial deste segmento inicial deste percorredor; \#191
       Retorne.
    \Se o segmento inicial deste percorredor for "del", recue o percorredor; Retorne. 
    Se o segmento inicial deste percorredor estiver em branco, 
      Retorne.
    Se o conteúdo deste caractere inicial deste segmento inicial deste percorredor for irrelevante, 
      Reitere.
    Se o conteúdo deste caractere inicial deste segmento inicial deste percorredor for a barra invertida, 
      Reitere.
    Se o conteúdo deste caractere inicial deste segmento inicial deste percorredor for o colchete esquerdo, 
      Reitere.
  \Reitere.

Rotina para que se mova um percorredor retornando uma string de erro (plurais):
  Limpe a string de erro.
  Mova o percorredor (englobando tudo).
  Se o segmento inicial deste percorredor estiver em branco, retorne.
  Se o conteúdo deste caractere inicial deste segmento inicial deste percorredor for o colchete esquerdo,
    Mova o percorredor retornando a string de erro (validação de comentários de bloco);
    Retorne.
  Se o conteúdo deste caractere inicial deste segmento inicial deste percorredor for as aspas duplas,
    Mova o percorredor retornando a string de erro (validação de strings literais);
    Retorne.
  Se o conteúdo deste caractere inicial deste segmento inicial deste percorredor for o parênteses esquerdo,
    Mova o percorredor retornando a string de erro (diretrizes de validação de qualificadores);
    Retorne.

Rotina para que se aplique o plural adequado para uma string:
  \# https://www.normaculta.com.br/singular-e-plural/
  \# palavras que são exceções às regras
  Se a string for "caráter",
    Atribua "carateres" à string;
    Retorne.
  Se a string for "júnior",
    Atribua "juniores" à string;
    Retorne.
  Se a string for "sênior",
    Atribua "seniores" à string;
    Retorne.
  \# advérbios principais
  Se a string for "muito", retorne.
  Se a string for "pouco", retorne.
  Se a string for "mais", retorne.
  Se a string for "menos", retorne.
  Se a string for "bastante", retorne.
  Se a string for "quase", retorne.
  Se a string for "demais", retorne.
  Se a string for "bem", retorne.
  Se a string for "deveras", retorne.
  Se a string for "mal", retorne.
  Se a string for "melhor", retorne.
  Se a string for "pior", retorne.
  \# palavras terminadas com "ão"
  Se a string termina com "ão",
    Pluralize a string (terminada com "ão");
    Retorne.
  \# palavras terminadas com "d"
  Se a string termina com "d",
    Pluralize a string (terminada com outras letras);
    Retorne.
  \# palavras terminadas com "l"
  Se a string termina com "l",
    Pluralize a string (terminada com "l");
    Retorne.
  \# palavra terminadas com "m"
  Se a string termina com "m",
    Remova o último caractere desde a string;
    Acrescente "ns" para a string;
    Retorne.
  \# palavra terminadas com "n" (essa regra é preferível porque mantém o acento da palavra, se houver)
  Se a string termina com "n",
    Acrescente "es" para a string;
    Retorne.
  \# palavras terminadas com "r"
  Se a string termina com "r",
    Pluralize a string (terminada com "r");
    Retorne.
  \# palavras terminadas com "s"
  Se a string termina com "s",
    Pluralize a string (terminada com "s");
    Retorne.
  \# palavras terminadas com "t"
  Se a string termina com "t",
    Pluralize a string (terminada com outras letras);
    Retorne.
  \# palavra terminadas com "x"
  Se a string termina com "x",
    Pluralize a string (terminada com "x");
    Retorne.
  \# palavras terminadas com "z"
  Se a string termina com "z",
    Pluralize a string (terminada com "z");
    Retorne.
  Se a string termina com "#",
    Acrescente "s" para a string;
    Retorne.
  Se a string não termina com alguma vogal ou com alguma consoante,
    Acrescente "s" para a string;
    Retorne.
  \# regra padrão
  [Caso contrário,]
  Acrescente "s" para a string. \ Só acrescenta o "s" caso nenhuma das condições acima tenha siddo correspondida.
  \Volte.

Rotina para que se pluralize uma string (terminada com "ão"):
  \A formação do plural dos substantivos terminados -ão pode ser feita de três formas distintas: -ões, -ãos, -ães.
  \Alguns substantivos terminados em -ão admitem duas (ou até três) formas no plural:
  \refrão - refrãos ou refrães;
  \corrimão - corrimões ou corrimãos;
  \guardião - guardiões ou guardiães;
  \vilão - vilões, vilãos ou vilães.
    \TODOS os substantivos paroxítonos terminados em -ão formam o plural com -ãos.
  \ALGUNS substantivos oxítonos também têm o seu plural formado segundo essa regra:
  \órfão - órfãos;
  \sótão - sótãos;
  \órgão - órgãos;
  \cidadão - cidadãos;
  \irmão - irmãos;
  \cristão - cristãos.
  Se a string for "cidadão",
    Acrescente "s" para a string;
    Retorne.
  Se a string for "irmão",
    Acrescente "s" para a string;
    Retorne.
  Se a string for "cristão",
    Acrescente "s" para a string;
    Retorne.
  Se a string for "refrão",
    Acrescente "s" para a string;
    Retorne.
  Se a string for "mão",
    Acrescente "s" para a string;
    Retorne.
  Se a string for "são",
    Acrescente "s" para a string;
    Retorne.
  \-ão no singular para -ães no plural:
  \Alguns substantivos terminados em -ão formam o plural com -ães.
  Se a string for "pão",
    Remova o último caractere desde a string;
    Acrescente "es" para a string;
    Retorne.
  Se a string for "capitão",
    Remova o último caractere desde a string;
    Acrescente "es" para a string;
    Retorne.
  Se a string for "alemão",
    Remova o último caractere desde a string;
    Acrescente "es" para a string;
    Retorne.
  Se a string for "charlatão",
    Remova o último caractere desde a string;
    Acrescente "es" para a string;
    Retorne.
  Lance um subtexto sobre a string.
  Subtraia 2 desde o caractere final deste subtexto.   \ remova o "ão". Acho que não precisa
  \caso encontre acentos em sílabas prévias, faça o seguinte
  Se o subtexto possui alguma vogal acentuada,
    Acrescente "s" para a string;
    Retorne. \-> exemplo: órgão
  \# regra padrão
  \A maioria dos substantivos terminados em -ão forma o plural com -ões:
  \opinião - opiniões;
  \coração - corações;
  \eleição - eleições.
  Remova os dois últimos caracteres desde a string. 
  Acrescente "ões" para a string.\ Retorne.

Função para que se determine se uma string possui alguma vogal acentuada:
  Preserve a string.
  Itere.
    Se a string estiver em branco, diga não.
    Se o conteúdo deste caractere final desta string for alguma vogal acentuada, diga sim.
    Subtraia 1 desde o caractere final desta string.
  Reitere.

Rotina para que se pluralize uma string (terminada com outras letras):
  Acrescente "s" para a string. \ Retorne.

Rotina para que se pluralize uma string (terminada com "l"):
  \# palavras terminadas com "al"
  Se a string termina com "al",
    Pluralize a string (terminada com "al");
    Retorne. \ MAL -> MALES
  \# palavras terminadas com "el"
  Se a string termina com "el",
    Pluralize a string (terminada com "el");
    Retorne. \PASTEL - PASTÉIS
  \# palavras terminadas com "il"
  Se a string termina com "il",
    Pluralize a string (terminada com "il");
    Retorne. \-> FUZIL -> FUZIS
  \# palavras terminadas com "ol"
  Se a string termina com "ol",
    Pluralize a string (terminada com "ol");
    Retorne. \- LENÇOL -> LENÇÓIS
  \# palavras terminadas com "ul"
  Se a string termina com "ul",
    Pluralize a string (terminada com "ul");
    Retorne. \ AZUL -> AZUIS \ Cônsul - cônsules
  [Caso a string seja uma sigla, tipo URL]
  Acrescente "s" para a string. \ Retorne.

Rotina para que se pluralize uma string (terminada com "al"):
  Se a string for "mal",
    Atribua "males" para a string;
    Retorne.
  Remova o último caractere desde a string. \remova a letra L
  Acrescente "is" para a string. \ Retorne.

Rotina para que se pluralize uma string (terminada com "el"):
  \Se a string for "pixel", atribua "pixels" para a string; Retorne.
  \# acentos em sílabas prévias
  Lance um subtexto sobre a string.
  Subtraia 2 desde o caractere final deste subtexto. \ remova o el
  Se o subtexto possui alguma vogal acentuada,
    Remova o último caractere desde a string;
    Acrescente "is" para a string;
    Retorne.
  Remova os dois últimos caracteres desde a string.
  Acrescente "éis" para a string. \ Retorne.

Rotina para que se pluralize uma string (terminada com "il"):
  \Se a string for "canil", atribua "canis" para a string; Retorne.
  \Se a string for "covil", atribua "covis" para a string; Retorne.
  \Se a string for "funil", atribua "funis" para a string; Retorne.
  \Se a string for "barril", atribua "barris" para a string; Retorne.
  \Se a string for "fuzil", atribua "fuzis" para a string; Retorne.
  \Se a string for "redil", atribua "redis" para a string; Retorne.
  \# acentos em sílabas prévias
  Lance um subtexto sobre a string.
  Subtraia 2 desde o caractere final deste subtexto.
  Se o subtexto possui alguma vogal acentuada,
    Remova os dois últimos caracteres desde a string;
    Acrescente "eis" para a string;
    Retorne.
  Remova o último caractere desde a string. \ remova a letra L
  Acrescente "s" para a string. \ Retorne.

Rotina para que se pluralize uma string (terminada com "ol"):
  \# acentos em sílabas prévias
  Lance um subtexto sobre a string.
  Subtraia 2 desde o caractere final deste subtexto.
  Se o subtexto possui alguma vogal acentuada,
    Remova o último caractere desde a string;
    Acrescente "is" para a string;
    Retorne.
  Remova os dois últimos caracteres desde a string.
  Acrescente "óis" para a string. \ Retorne.

Rotina para que se pluralize uma string (terminada com "ul"):
  Se a string for "cônsul",
    Atribua "cônsules" à string;
    Retorne.
  Remova o último caractere desde a string. \ remova o L
  Acrescente "is" para a string. \ Retorne.

Rotina para que se pluralize uma string (terminada com "r"):
  \# acentos em sílabas prévias
  Lance um subtexto sobre a string.
  Subtraia 2 desde o caractere final deste subtexto.
  Se o subtexto possui alguma vogal acentuada,
    Acrescente "es" para a string;
    Retorne.
  \# hiatos
  Se a string termina com "air",
    Remova os dois últimos caracteres desde a string;
    Acrescente "íres" para a string;
    Retorne.
  Se a string termina com "aur",
    Remova os dois últimos caracteres desde a string;
    Acrescente "úres" para a string;
    Retorne.
  \# regra padrão
  Acrescente "es" para a string. \ Retorne.

Rotina para que se pluralize uma string (terminada com "s"):
\Quando os substantivos terminados em -s são paroxítonos, a formação do plural fica invariável:.
  \# proparoxítonas/paroxítonas terminadas com "as", "es", "os"
  Se a string termina com "as",
    Acrescente "es" para a string;
    Retorne. \atlas
  Se a string termina com "es",
      Acrescente "es" para a string;
    Retorne. \atlas
  Se a string termina com "os",
      Acrescente "es" para a string;
    Retorne. \atlas
  \# hiatos acentuados
  Se a string termina com "aís",
    Acrescente "es" para a string;
    Retorne.
  Se a string termina com "aús",
    Acrescente "es" para a string;
    Retorne.
  \# oxítonas terminadas com "ás", "âs", "és", "ês", "ís", "ós", "ôs", "ús"
  Se a string termina com "ás",
    Remova os dois últimos caracteres desde a string;
    Acrescente "ases" para a string;
    Retorne.
  Se a string termina com "âs",
    Remova os dois últimos caracteres desde a string;
    Acrescente "ases" para a string;
    Retorne.
  Se a string termina com "és",
    Remova os dois últimos caracteres desde a string;
    Acrescente "eses" para a string;
    Retorne.
  Se a string termina com "ês",
    Remova os dois últimos caracteres desde a string;
    Acrescente "eses" para a string;
    Retorne.
  Se a string termina com "ís",
    Remova os dois últimos caracteres desde a string;
    Acrescente "ises" para a string;
    Retorne.
  Se a string termina com "ós",
    Remova os dois últimos caracteres desde a string;
    Acrescente "oses" para a string;
    Retorne.
  Se a string termina com "ôs",
    Remova os dois últimos caracteres desde a string;
    Acrescente "oses" para a string;
    Retorne.
  Se a string termina com "ús",
    Remova os dois últimos caracteres desde a string;
    Acrescente "uses" para a string;
    Retorne.
  \# palavras terminadas com "is", "us"
  Se a string termina com "is",
    Pluralize a string (terminada com "is" ou com "us");
    Retorne.
  Se a string termina com "us",
    Pluralize a string (terminada com "is" ou com "us");
    Retorne. \ônibus / vírus
  \Se a string termina com "ts", exit.
  \# regra padrão
  Acrescente "es" para a string. \ Retorne.

Rotina para que se pluralize uma string (terminada com "is" ou com "us"):
  \# acentos em sílabas prévias
  Lance um subtexto sobre a string.
  Subtraia 2 desde o caractere final deste subtexto.
  Se o subtexto possui alguma vogal acentuada, retorne.
  \# hiatos
  Se a string termina com "ais",
    Remova os dois últimos caracteres desde a string;
    Acrescente "íses" para a string;
    Retorne. \cais não varia....
  Se a string termina com "aus",
    Remova os dois últimos caracteres desde a string;
    Acrescente "úses" para a string;
    Retorne.
  \# regra padrão
  Acrescente "es" para a string. \ Retorne.

Rotina para que se pluralize uma string  (terminada com "x"):
  \Se a string for "px",
    \acrescente "pxs" para a string;
    \Retorne.
  Se a string for "fax",
    Acrescente "es" para a string;
    Retorne.
  Acrescente "s" para a string. \ tratamento de exceções
   \ Retorne.

Rotina para que se pluralize uma string (terminada com "z"):
  \# hiatos acentuados
  Se a string termina com "aíz",
    Acrescente "es" para a string;
    Retorne.
  Se a string termina com "aúz",
    Acrescente "es" para a string;
    Retorne.
  \# palavras terminas em "áz", "âz", "éz", "êz", "íz", "óz", "ôz", "úz"
  Se a string termina com "áz",
    Remova os dois últimos caracteres desde a string;
    Acrescente "azes" para a string;
    Retorne.
  Se a string termina com "âz",
    Remova os dois últimos caracteres desde a string;
    Acrescente "azes" para a string;
    Retorne.
  Se a string termina com "éz",
    Remova os dois últimos caracteres desde a string;
    Acrescente "ezes" para a string;
    Retorne.
  Se a string termina com "êz",
    Remova os dois últimos caracteres desde a string;
    Acrescente "ezes" para a string;
    Retorne.
  Se a string termina com "íz",
    Remova os dois últimos caracteres desde a string;
    Acrescente "izes" para a string;
    Retorne.
  Se a string termina com "óz",
    Remova os dois últimos caracteres desde a string;
    Acrescente "ozes" para a string;
    Retorne.
  Se a string termina com "ôz",
    Remova os dois últimos caracteres desde a string;
    Acrescente "ozes" para a string;
    Retorne.
  Se a string termina com "úz",
    Remova os dois últimos caracteres desde a string;
    Acrescente "uzes" para a string;
    Retorne.
  \# acentos em sílabas prévias
  Lance um subtexto sobre a string.
  Subtraia 2 desde o caractere final deste subtexto.
  Se o subtexto possui alguma vogal acentuada,
    Acrescente "es" para a string;
    Retorne.
  \# hiatos
  Se a string termina com "aiz",
    Remova os dois últimos caracteres desde a string;
    Acrescente "ízes" para a string;
    Retorne.
  Se a string termina com "auz",
    Remova os dois últimos caracteres desde a string;
    Acrescente "úzes" para a string;
    Retorne.
  \# regra padrão
  Acrescente "es" para a string. \ Retorne.

Função para que se determine se uma string termina com alguma vogal ou com alguma consoante:
  Se a string terminar com algum vogal, diga sim.
  Se a string terminar com alguma consoante, diga sim.
  Diga não.

Função para que se determine se uma string termina com algum vogal:
  Se a string estiver em branco, diga não.
  Se o conteúdo deste caractere final desta string não for algum vogal, diga não.
  Diga sim.

Função para que se determine se uma string termina com alguma consoante:
  Se a string estiver em branco, diga não.
  Se o conteúdo deste caractere final desta string não for alguma consoante, diga não.
  Diga sim.

Rotina para que se apresente uma mensagem de erro contendo uma string e um percorredor:
  Se o segmento inicial deste percorredor não estiver em branco,
    Apresente a mensagem de erro contendo a string e o caractere inicial deste segmento inicial deste percorredor;
    Retorne.
  Apresente a mensagem de erro contendo a string e o caractere final deste segmento final deste percorredor.

Função para que se determine se uma string é algum operador de atribuição de estruturas compostas:
  Se a string for "tem", diga sim.
  Se a string for "têm", diga sim.
  Se a string for "contém", diga sim.
  Se a string for "contêm", diga sim.
  \Se a string for "possui", diga sim.
  Diga não.

Rotina para que se examine um tipo usando um percorredor (cláusula 'tem'):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Atribua "estrutura" ao nome do tipo primitivo deste tipo.
  Examine os campos deste tipo usando o percorredor.
  Se o segmento inicial deste percorredor não for o ponto final,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #016. Esperado '.' no final da estrutura. Encontrado '" 
      junto com o segmento inicial deste percorredor seguido de "'." junto com o texto CRLF e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Catalogue o tipo.

Rotina para que se examine uns campos usando um percorredor:
  \Itere.
  Se existir algum problema de compilação, retorne.
    Adicione um campo para o campos usando "campo" e o caractere inicial deste segmento inicial deste percorredor.
    \ Um campo é uma variável.
    Examine o campo usando o percorredor.
    Se o segmento inicial deste percorredor não for alguma pausa, retorne.
    Examine algumas pausas usando o percorredor.
  Reitere.

Rotina para que se adicione uma variável para umas variáveis usando uma categoria e um endereço local:
  Crie a variável usando a categoria.
  Acrescente a variável para as variáveis.
  Atribua o endereço local ao endereço local desta variável.

Rotina para que se crie uma variável usando um categoria:
  Aloque memória para a variável.
  Atribua a categoria à categoria desta variável.
  Atribua 1 à contagem desta variável.

Rotina para que se examine um campo usando um percorredor:
  Se existir algum problema de compilação, retorne.
  Examine o campo usando o percorredor (tipo geral).
  Itere.
    Se existir algum problema de compilação, retorne.
    Se o segmento inicial deste percorredor for uma palavra-chave de designação,
      Examine o campo usando o percorredor (cláusula designadora);
      Reitere.
    Se o segmento inicial deste percorredor for "sob",
      Examine o campo usando o percorredor (cláusula de redefinição);
      Reitere.
    Se o segmento inicial deste percorredor for "em",
      Examine o campo usando o percorredor (cláusula de redefinição);
      Reitere.
    Se o segmento inicial deste percorredor for "sobre",
      Examine o campo usando o percorredor (cláusula de redefinição);
      Reitere.
    Se o segmento inicial deste percorredor for uma palavra-chave de referenciamento,
      Examine o campo usando o percorredor (cláusula de referência);
      Reitere.
  \Pare.

Rotina para que se examine um campo usando um percorredor (tipo geral):
  Se existir algum problema de compilação, retorne.
  Se o segmento inicial deste percorredor for algum valor numérico literal,
    Examine o campo usando o percorredor (tipo: array de bytes);
    Retorne.
  Examine o campo usando o percorredor (tipo normal).

Rotina para que se examine um campo usando um percorredor (tipo: array de bytes):
  Se existir algum problema de compilação, retorne.
  Converta o segmento inicial deste percorredor para uma proporção.
  Reduza a proporção.
  Se o denominador desta proporção não for 1,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #017. Erro de sintaxe. Bytes contíguos devem ser declarados apenas com números inteiros." junto com o texto CRLF e o percorredor;
    Retorne.
  Atribua o numerador desta proporção à contagem deste campo.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for "byte" ou "bytes",
    Apresente a mensagem de erro contendo 
      "Código de Erro #018. Erro de sintaxe. Esperado encotrar o identificador 'bytes' após a declaração de número. Identificador encontrado: '" 
      junto com o segmento inicial deste percorredor seguido de "'." junto com o texto CRLF e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Atribua "byte" ao nome do tipo deste campo.

Rotina para que se examine um campo usando um percorredor (tipo normal):
  Se existir algum problema de compilação, retorne.
  Se o segmento inicial deste percorredor não for algum artigo indefinido,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #019. Erro de sintaxe. Esperado encontrar um artigo indefinido. Identificador encontrado: '" 
      junto com o segmento inicial deste percorredor seguido de "'." junto com o texto CRLF e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Expanda o nome deste campo com o nome.

Rotina para que se examine um campo usando um percorredor (cláusula designadora):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o nome do tipo deste campo estiver em branco, 
    Atribua o nome deste campo ao nome do tipo deste campo. \ O nome do tipo "array de bytes" já foi preenchido
  Examine o nome deste campo usando o percorredor.

Rotina para que se examine um campo usando um percorredor (cláusula de redefinição):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum artigo definido,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #020. Sintaxe incorreta. Esperado 'o/a'. Encontrado: '" 
      junto com o segmento inicial deste percorredor seguido de "'." junto com o texto CRLF e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine o novo nome deste campo usando o percorredor.

Função para que se determine se uma string é uma palavra-chave de referenciamento:
  Se a string for "(referência)", diga sim.
  Diga não.

Rotina para que se examine um campo usando um percorredor (cláusula de referência):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Ative o sinalizador de referência deste campo.

Função para que se determine se uma string é alguma pausa:
  Se a string for "e", diga sim.
  Se a string for "ou", diga sim.
  \default
  Se a string for ",", diga sim.
  Se a string for ";", diga sim.
  Diga não.

Rotina para que se examine algumas pausas usando um percorredor:
  \Itere.
    Se existir algum problema de compilação, retorne.
    Se o segmento inicial deste percorredor não for alguma pausa, retorne.
    Mova o percorredor (usando diretrizes de compilação).
  Reitere.

Rotina para que se catalogue um tipo:
  Se o tipo for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Catalogue o tipo usando o nome deste tipo.

Rotina para que se catalogue um tipo usando um nome:
  Se o tipo for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Encontre um tipo denominado tipo procurado usando o nome e o catálogo de tipos.
  Se o tipo procurado for inexistente,
    Catalogue o tipo usando o nome e o catálogo de tipos;
    Retorne.
  [Se o tipo procurado estiver presente no catálogo de tipos, então:]
  Atribua o endereço local deste tipo para um endereço local.
  Se o endereço local for inexistente, 
    Atribua o endereço local deste tipo procurado ao endereço local. \ aponta para um erro do tipo no código-fonte, não para um tipo gerado
  Se o endereço local não for inexistente,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #021. O identificador '" junto com o nome seguido de 
      "' corresponde a um tipo já declarado anteriormente." junto com o texto CRLF e o endereço local.

Função para que se determine se uma string é algum operador de atribuição simples:
  Se a string for "é", diga sim.
  Se a string for "está", diga sim.
  Se a string for "são", diga sim.
  Se a string for "estão", diga sim.
  Se a string for "estamos", diga sim.
  Se a string for "for", diga sim.
  Se a string for "forem", diga sim.
  Se a string for "estiverem", diga sim.
  Se a string for "estarem", diga sim.
  Se a string for "possui", diga sim.
  \Se a string for "tem", diga sim. \records
  Diga não.

Rotina para que se examine um tipo usando um percorredor (unidade de medida):
  Se existir algum problema de compilação, retorne.
  Converta o segmento inicial deste percorredor para a razão de escala deste tipo.
  Se a razão de escala deste tipo for 0,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #022. Impossível utilizar 0 como razão de escala em tipos escalares." 
      junto com o texto CRLF e o endereço local deste tipo;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine o nome do tipo primitivo deste tipo usando o percorredor.
  Se o segmento inicial deste percorredor não for o ponto final,
    Apresente a mensagem de erro contendo 
      "Código de Erro #023. Esperado encontrar um '.' após a declaração de unidade de medida. Encontrado. '" 
      junto com o segmento inicial deste percorredor seguido de "'." junto com o texto CRLF e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Catalogue o tipo.

\Rotina para que se examine algum dado complementar de um tipo usando um percorredor:
Rotina para que se examine algum dado complementar para um tipo usando um percorredor:
  Se existir algum problema de compilação, retorne.
  \Se o segmento inicial deste percorredor for "to",
    \Examine algum dado complementar para o tipo usando o percorredor (ponteiros);
    \Retorne.
  Se o segmento inicial deste percorredor for "para",
    Examine algum dado complementar para o tipo usando o percorredor (ponteiros);
    Retorne.
  Se o segmento inicial deste percorredor for alguma palavra-chave de complementação,
    Examine algum dado complementar para o tipo usando o percorredor (estrutura);
    Retorne.

Rotina para que se examine algum dado complementar para um tipo usando um percorredor (ponteiros):
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum artigo indefinido,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #024. Esperava encontrar 'Aponte para UM/UMA'. Encontrado: '" 
      junto com o segmento inicial deste percorredor seguido de "'." junto com o texto CRLF e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine o nome do conteúdo deste tipo usando o percorredor.

Função para que se determine se uma string é alguma palavra-chave de complementação:
  Se a string for "com", diga sim.
  Se a string for "contendo", diga sim.
  Diga não.

Rotina para que se examine algum dado complementar para um tipo usando um percorredor (estrutura):
  Mova o percorredor (usando diretrizes de compilação).
  Examine o campos deste tipo usando o percorredor.

\ ---------------------------------------------- VALIDAÇÃO DA SINTAXE DE VARIÁVEIS GLOBAIS ---------------------------------------------------------------

\ CONFERIR ARQUIVO "ETAPA INICIAL"

Função para que se determine se uma string é o início de alguma variável global:
  Se a string for algum artigo definido, diga sim.
  Diga não.

Rotina para que se examine uma variável global usando um percorredor:
  Se existir algum problema de compilação, retorne.
  Adicione a variável global para as variáveis globais usando "variável global" [categoria] e o caractere inicial deste segmento inicial deste percorredor. [endereço local]
  Mova o percorredor (usando diretrizes de compilação).
  Examine o nome desta variável global usando o percorredor.
  Se o segmento inicial deste percorredor for algum operador de atribuição de estruturas compostas,
    Examine a variável global usando o percorredor (cláusula 'tem');
    Retorne.
  Se o segmento inicial deste percorredor não for algum operador de atribuição simples,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #025. Erro de sintaxe. Esperado: 'é/está'. Encontrado: '" 
      junto com o segmento inicial deste percorredor seguido de "'." junto com o texto CRLF e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum artigo indefinido,
    Examine a variável global usando o percorredor (literal termo);
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine o nome do tipo desta variável global usando o percorredor.
  Se o segmento inicial deste percorredor for o início de algum dado complementar,
    Examine a variável global usando o percorredor (dados complementares);
    Retorne.
  Se o segmento inicial deste percorredor for algum operador de atribuição composto,
    Examine a variável global usando o percorredor (análise de valor);
    Retorne.
  Se o segmento inicial deste percorredor não for o ponto final,
    Apresente a mensagem de erro contendo 
      "Código de Erro #026. Erro de sintaxe. Declaração de variáveis globais devem terminar com um '.'" junto com o texto CRLF e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Catalogue a variável global.

Rotina para que se examine uma variável global usando um percorredor (cláusula 'tem'):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  [embutido/incorporado/vinculado]
  Atribua "~inline "  junto com o nome desta variável global seguido de " tipo" para um nome.
  \Atribua "TIPO "  junto com o nome desta variável global seguido de " ~inline" para um nome.
  Atribua o nome seguido de "s" para um nome plural. \ 
  Adicione um tipo para os tipos usando o nome e o nome plural e "estrutura" e o endereço local desta variável global. \ ESTRUTURA
  Catalogue o tipo.
  Atribua o nome deste tipo ao nome do tipo desta variável global.
  Examine os campos deste tipo usando o percorredor.
  Se o segmento inicial deste percorredor não for o ponto final,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #027. Esperado '.' no final de declarações de variáveis globais. Encontrado: '" 
      junto com o segmento inicial deste percorredor seguido de "'." junto com o texto CRLF e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Catalogue a variável global.

Rotina para que se catalogue uma variável global:
  Se existir algum problema de compilação, retorne.
  Se a variável global for inexistente, retorne.
  Se o nome desta variável global estiver no catálogo de variáveis globais,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #028. O identificador '" junto com o nome desta variável global 
      seguido de "' corresponde a uma variável global já declarada anteriormente." 
      junto com o texto CRLF e o endereço local desta variável global;
    Retorne.
  Catalogue a variável global usando o nome desta variável global e o catálogo de variáveis globais.

Rotina para que se examine uma variável global usando um percorredor (literal termo):
  Se existir algum problema de compilação, retorne.
  Examine o corpo de variável global desta variável global usando o percorredor.
  Se o segmento inicial deste percorredor não for o ponto final,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #029. Erro de sintaxe. Necessário inserir '.' ao inicializar variáveis globais." 
      junto com o texto CRLF e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Catalogue a variável global.

Rotina para que se examine um corpo de variável global usando um percorredor:
  Se existir algum problema de compilação, retorne.
  Se o segmento inicial deste percorredor estiver em branco, retorne.
  Atribua o caractere inicial deste segmento inicial deste percorredor ao caractere inicial deste corpo de variável global.
  Atribua -1 ao caractere final deste corpo de variável global.
  Itere.
    Se existir algum problema de compilação, retorne.
    Se o segmento inicial deste percorredor estiver em branco, retorne.
    Se o segmento inicial deste percorredor for o sinal de dois pontos, retorne.
    Se o segmento inicial deste percorredor for o ponto final, retorne.
    Atribua o caractere final deste segmento inicial deste percorredor ao caractere final deste corpo de variável global.
    Mova o percorredor (usando diretrizes de compilação).
  Reitere.

Função para que se determine se uma string é o início de algum dado complementar:
  \PAL
  Se a string for "com", diga sim.
  Se a string for "contendo", diga sim.
  Diga não.

Rotina para que se examine uma variável global usando um percorredor (dados complementares):
  Se existir algum problema de compilação, retorne.
  Atribua "~inline " junto com o nome desta variável global seguido de " tipo" para um nome.
  Atribua o nome seguido de "s" para um nome plural. \ 
  Adicione um tipo para os tipos usando o nome e o nome plural e o nome do tipo desta variável global e o endereço local desta variável global.
  Catalogue o tipo.
  Atribua o nome deste tipo ao nome do tipo desta variável global.
  Examine algum dado complementar para o tipo usando o percorredor.
  Se o segmento inicial deste percorredor não for o ponto final,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #030. Erro de sintaxe. Esperado '.' após informações complementares." junto com o texto CRLF e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Catalogue a variável global.

Rotina para que se examine uma variável global usando um percorredor (análise de valor):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum termo de equivalência,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #031. Esperava encontrar 'igual a'. Encontrado: '" 
      junto com o segmento inicial deste percorredor seguido de "'." junto com o texto CRLF e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine o corpo de variável global desta variável global usando o percorredor.
  Se o segmento inicial deste percorredor não for o ponto final,
    Apresente a mensagem de erro contendo 
      "Código de Erro #032. Erro de sintaxe. Esperado '.' ao final de uma declaração variável variável global" junto com o texto CRLF e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Catalogue a variável global.

Função para que se determine se uma string é algum termo de equivalência: \ igual a 
  Se a string for "a", diga sim. 
  \Se a string for "que", diga sim.
  Diga não.

Rotina para que se duplique uma variável global retornando uma segunda variável global:
  Se a variável global for inexistente, retorne.
  Se a segunda variável global for inexistente, 
    Aloque memória para a segunda variável global.
  Atribua a categoria desta variável global para a categoria desta segunda variável global.
  Atribua o nome desta variável global para o nome desta segunda variável global.
  Atribua o nome do tipo desta variável global para o nome do tipo desta segunda variável global.
  Atribua o corpo de variável global desta variável global para o corpo de variável global desta segunda variável global.

\ -------------------------------------------------------------------- VALIDAÇÃO DA SINTAXE DOS CABEÇALHOS DE ROTINAS -----------------------------------------------------

Função para que se determine se uma string é o início de alguma rotina:
  Se a string for "Para", diga sim.
  Se a string for "Procedimento", diga sim.
  Se a string for "Rotina", diga sim.
  Se a string for "Função", diga sim.
  \ Se a string for "Passos", diga sim.
  \ Se a string for "Etapas", diga sim.
  \ Se a string for "Instruções", diga sim.
  \ Se a string for "Diretrizes", diga sim.
  \ Se a string for "Método", diga sim.
  \ Se a string for "Roteiro", diga sim.
  \ Se a string for "Descrição", diga sim.
  \ Se a string for "Processo", diga sim.
  \ Se a string for "Ações", diga sim.
  \ Se a string for "Caminho", diga sim.
  \ Se a string for "Guia", diga sim.
  \ Se a string for "Modelo", diga sim.
  \ Se a string for "Estratégia", diga sim.
  \ Se a string for "Manual", diga sim.
  Diga não.

Rotina para que se examine uma rotina usando um percorredor:
  \ Define o cabeçalho de rotina.
  Se existir algum problema de compilação, retorne.
  Adicione a rotina para as rotinas usando o caractere inicial deste segmento inicial deste percorredor.
  Se o segmento inicial deste percorredor for açúcar sintático, 
    Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for "para",
    Apresente uma mensagem de erro contendo 
      "Código de Erro #033. Erro. Esperado 'para'. Encontrado '" 
      junto com o segmento inicial deste percorredor 
      seguido de "'." junto com o texto CRLF e o percorredor;
    Retorne.
  \Se o segmento inicial deste percorredor for "para",
    Mova o percorredor (usando diretrizes de compilação). \ Obtém a próxima palavra
  Se o segmento inicial deste percorredor for "que", 
    Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for "se", 
    Mova o percorredor (usando diretrizes de compilação).
  Examine a cabeçalho de rotina desta rotina usando o percorredor.
  Se o segmento inicial deste percorredor for o ponto&vírgula,
    Examine a rotina usando o percorredor (sobrecarga de métodos);
    Retorne. \ *** usado para nomes alternativos de rotinas
  Se o segmento inicial deste percorredor não for o sinal de dois pontos,
    Apresente a mensagem de erro contendo 
      "Código de Erro #034. Erro de sintaxe no cabeçalho de rotina. ':' ausente ou mal posicionado" 
      e o endereço local desta rotina;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine as instruções desta rotina usando o percorredor.

Rotina para que se adicione uma rotina para umas rotinas usando um endereço local:
  Crie a rotina.
  Acrescente a rotina para as rotinas.
  Atribua o endereço local ao endereço local desta rotina.

Rotina para que se crie uma rotina:
  Aloque memória para a rotina.

Função para que se determine se uma string é açúcar sintático:
  \PAL
  \Se a string for "Passos", diga sim.
  \Se a string for "Etapas", diga sim.
  Se a string for "Procedimento", diga sim.
  Se a string for "Rotina", diga sim.
  Se a string for "Função", diga sim.
  Diga não.

Rotina para que se examine uma cabeçalho de rotina usando um percorredor:
  Se existir algum problema de compilação, retorne.
  Se o segmento inicial deste percorredor estiver em branco, retorne.
  Atribua o caractere inicial deste segmento inicial deste percorredor ao caractere inicial deste cabeçalho de rotina.
  Atribua -1 ao caractere final deste cabeçalho de rotina.
  Itere.
    Se existir algum problema de compilação, retorne.
    Se o segmento inicial deste percorredor estiver em branco, retorne.
    Se o segmento inicial deste percorredor for o ponto&vírgula, retorne.
    Se o segmento inicial deste percorredor for o sinal de dois pontos, retorne.
    Se o segmento inicial deste percorredor for o ponto final, retorne.
    Atribua o caractere final deste segmento inicial deste percorredor ao caractere final deste cabeçalho de rotina.
    Mova o percorredor (usando diretrizes de compilação).
  Reitere.

Rotina para que se examine uma rotina usando um percorredor (sobrecarga de métodos):
  \ *** para cabeçalhos alternativos de rotinas
  Preserve o percorredor.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for o início de alguma rotina,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #035. Erro de sintaxe. Verifique se existe um 'para' após o ';'." e o percorredor original;
    Retorne.
  Atribua o caractere inicial deste segmento inicial deste percorredor original ao caractere inicial destas instruções desta rotina.
  Atribua o caractere final deste segmento inicial deste percorredor original ao caractere final destas instruções desta rotina.
  Mova o percorredor original (usando diretrizes de compilação).

Rotina para que se examine uma instruções usando um percorredor:
  Se existir algum problema de compilação, retorne.
  Se o segmento inicial deste percorredor estiver em branco, retorne.
  Se o segmento inicial deste percorredor for o enunciado de alguma rotina ou variável, retorne.
  Atribua o caractere inicial deste segmento inicial deste percorredor ao caractere inicial destas instruções.
  Itere.
    Se existir algum problema de compilação, retorne.
    Se o segmento inicial deste percorredor estiver em branco, retorne.
    Atribua o caractere final deste segmento inicial deste percorredor ao caractere final destas instruções.
    Se o segmento inicial deste percorredor for o sinal de dois pontos,
      Apresente uma mensagem de erro contendo 
        "Código de Erro #036. Mova o ':' para o final do cabeçalho desta rotina." junto com o texto CRLF e o percorredor;
      Retorne.
    Se o segmento inicial deste percorredor não for o ponto final,
      Mova o percorredor (usando diretrizes de compilação);
      Reitere.
    Mova o percorredor (usando diretrizes de compilação).
    Se o segmento inicial deste percorredor for o enunciado de alguma rotina ou variável, retorne.
  Reitere.

Função para que se determine se uma string é o enunciado de alguma rotina ou variável:
  Se a string for açúcar sintático, diga sim.
  Se a string for algum artigo indefinido, diga sim.
  Se a string for algum artigo definido, diga sim.
  Diga não.

\-------------------------------------------------------------------------------------ROTINAS EXTRAS--------------------------------------------------------------

Função para que se determine se uma string termina com alguma consoante e uma segunda string:
  Lance um subtexto sobre a string.
  Subtraia a quantidade de caracteres desta segunda string desde o caractere final deste subtexto.
  Se o subtexto estiver em branco, diga não.
  Se o conteúdo deste caractere final deste subtexto não for alguma consoante, diga não.
  Se a string não terminar com a segunda string, diga não.
  Diga sim.

Função para que se determine se uma string termina com algum vogal e uma segunda string:
  Lance um subtexto sobre a string.
  Subtraia a quantidade de caracteres desta segunda string desde o caractere final deste subtexto.
  Se o subtexto estiver em branco, diga não.
  Se o conteúdo deste caractere final deste subtexto não for algum vogal, diga não.
  Se a string não terminar com a segunda string, diga não.
  Diga sim.