 \ Este arquivo contém o código fonte do compilador da linguagem de programação "Português Puro"
 
Rotina para que se execute o programa:
  Inicialize os componentes.
  \Inicialize o compilador.
  Compile o diretório do projeto.
  Finalize o compilador.
  Escreva na próxima linha em StdOut.
  Escreva "Operação finalizada." junto com o texto CRLF para StdOut.
  \Execute os eventos. \
  Feche o programa.

Rotina para que se compile o diretório do projeto:
  Atribua 1252 a um número denominado codepage.
  Processe "kernel32.dll" "SetConsoleOutputCP" com o codepage retornando um número denominado status de erro.
  Se o status de erro for 0 [NULL], 
    Escreva "Erro ao definir o CodePage do Console para STDOUT." junto com o texto CRLF para STDOUT;
    Escreva "Se você estiver utilizando o console do NppExec, ignore a mensagem acima." junto com o texto CRLF para STDOUT.
  Obtenha uma string denominada diretório do projeto desde os argumentos da linha de comando.
  Se o diretório do projeto estiver em branco, 
    Escreva "|-----------------------------------------------------------------------------------------------------------------------|" junto com o texto CRLF para StdOut;
    Escreva "| Aviso. Para utilizar este compilador, você deve invocá-lo através da linha de comando.                 |" junto com o texto CRLF para StdOut;
    Escreva "| Para fazer isso, abra compilador no Prompt de Comando (cmd.exe) usando a sintaxe abaixo:      |" junto com o texto CRLF para StdOut;
    Escreva "|                                                                                                                                                                       |" junto com o texto CRLF para StdOut;
    Escreva "|       C:\endereço_do_compilador.exe\  C:\pasta_do_projeto_atual\                                                 |" junto com o texto CRLF para StdOut;
    Escreva "|                                                                                                                                                                       |" junto com o texto CRLF para StdOut;
    Escreva "|-----------------------------------------------------------------------------------------------------------------------|" junto com o texto CRLF para StdOut;
  Retorne.
  Se o conteúdo deste caractere final deste diretório do projeto não for a barra invertida, 
    Acrescente a barra invertida para o diretório do projeto
  Se o diretório do projeto não estiver no sistema de arquivos, 
    Escreva "Erro. O diretório '" junto com o diretório do projeto seguido de "' não foi encontrado." junto com o texto CRLF para StdOut;
    Retorne.
  Escreva "Compilando o diretório '" junto com o diretório do projeto seguido de "' ..." junto com o texto CRLF para StdOut. \ Etapa #0
  Escreva o texto CRLF para StdOut.
  Compile o diretório do projeto.
  Se existir algum problema de compilação, 
    Exiba o erro de compilação; 
    Retorne.
  Escreva "Tempo de compilação: " junto com a string deste temporizador deste compilador seguido de " ms" junto com o texto CRLF para StdOut.

Rotina para que se obtenha uma string desde os argumentos da linha de comando:
  Processe "kernel32.dll" "GetCommandLineA" 
    Retornando um endereço do caractere.
  Converta o endereço do caractere para uma string denominada argumentos.
  Lance um subtexto sobre os argumentos.
  Itere.
    Se o subtexto estiver em branco, 
      Limpe a string; 
      Retorne. 
    Se o conteúdo deste caractere inicial deste subtexto não for o caractere de espaço, 
      Adicione 1 para o caractere inicial deste subtexto; 
      Reitere.
    Atribua o subtexto para a string.
    Elimine os resíduos na string.
  \Reitere.

Rotina para que se compile um endereço da pasta:
  Compile o endereço da pasta (inicialização). \ Etapa #001
  Compile o endereço da pasta (arquivos de código fonte). \ Etapa #002
  Compile o endereço da pasta (análise dos arquivos fornecidos). \ Etapa #003
  Compile o endereço da pasta (identificação dos tipos das variáveis). \ Etapa #004
  Compile o endereço da pasta (identificação de variáveis globais). \ Etapa #005
  Compile o endereço da pasta (cabeçalhos de rotinas). \ Etapa #006
  Compile o endereço da pasta (cálculo de tamanhos e deslocamentos). \ Etapa #007
  Compile o endereço da pasta (adição de rotinas de memória incorporadas). \ Etapa #008
  Compile o endereço da pasta (catalogue as rotinas por utilização). \ Etapa #009
  Compile o endereço da pasta (conteúdo das rotinas). \ Etapa #010
  Compile o endereço da pasta (adição e compilação da rotina de inicialização). \ Etapa #011
  Compile o endereço da pasta (deslocamento de parâmetros e variáveis). \ Etapa #012
  Compile o endereço da pasta (endereço). \ Etapa #013
  Compile o endereço da pasta (transmutação). \ Etapa #014
  Compile o endereço da pasta (vinculação). \ Etapa #015
  Compile o endereço da pasta (etapa final). \ Etapa #016
  Compile o endereço da pasta (interrupção). \ Etapa #017


Rotina para que se compile um endereço da pasta (inicialização): \#001
  Escreva "Inicializando os componentes..." junto com o texto CRLF para StdOut.
  Finalize o compilador.
  Comece o temporizador deste compilador.
  Inicialize o compilador usando o endereço da pasta.
  Adicione os tipos primitivos.

Rotina para que se finalize o compilador:
  Destrua o catálogo de rotinas úteis.
  Destrua o catálogo geral de rotinas.
  Destrua o catálogo de variáveis hexadecimais.
  Destrua o catálogo de variáveis globais.
  Destrua o catálogo de tipos.
  \Destrua o catálogo de apelidos.
  Destrua as DLLs.
  Destrua as rotinas.
  Destrua os valores literais.
  Destrua as variáveis globais.
  Destrua as variáveis globais predefinidas.
  Destrua os tipos.
  Destrua os arquivos fontes.

Rotina para que se inicialize o compilador usando um endereço da pasta:
  Atribua o endereço da pasta ao endereço da pasta deste compilador.
  Atribua 0 à contagem de nomes deste compilador.
  Desative o sinalizador de erros deste compilador.
  Limpe a mensagem de erro deste compilador.
  Limpe o endereço do arquivo atual deste compilador.
  Atribua 0 ao número da linha de erro deste compilador.
  Esvazie a rotina utilizada atualmente.
  Crie o catálogo de tipos com 13001 [recipientes]. \ era 4027
  Crie o catálogo de variáveis globais com 13001 [recipientes]. \ era 4027
  Crie o catálogo de variáveis hexadecimais com 13001 [recipientes]. \ era 4027
  Crie o catálogo geral de rotinas com 13001 [recipientes]. \ era 7919
  Crie o catálogo de rotinas úteis com 13001 [recipientes]. \ era 4027

Rotina para que se adicione os tipos primitivos:
  Adicione um tipo primitivo usando "byte" e "bytes" e 1.
  Adicione um outro tipo primitivo usando "estrutura" e "estruturas" e 0.

Rotina para que se adicione um tipo primitivo usando um nome e um nome plural e uma quantidade de caracteres:
  Adicione o tipo primitivo para os tipos usando o nome e o nome plural e o nome. [do tipo primitivo]
  Atribua a quantidade de caracteres à quantidade de caracteres deste tipo primitivo.
  Atribua o tipo primitivo ao tipo base deste tipo primitivo.
  Catalogue o tipo primitivo.

Rotina para que se adicione um tipo para uns tipos usando um nome e um nome plural e um nome do tipo primitivo:
  Adicione o tipo para os tipos usando o nome e o nome plural e o nome do tipo primitivo e nil.

Rotina para que se adicione um tipo para uns tipos usando um nome e um nome plural e um nome do tipo primitivo e um endereço local:
  Crie o tipo.
  Acrescente o tipo para os tipos. \ Um tipo é uma lista duplamente encadeada
  Atribua o endereço local ao endereço local deste tipo.
  Atribua o nome ao nome deste tipo.
  Atribua o nome plural ao nome plural deste tipo.
  Atribua o nome do tipo primitivo ao nome do tipo primitivo deste tipo.

Rotina para que se crie um tipo:
  Aloque memória para o tipo.
  Atribua 0/1 à razão de escala deste tipo.
  Atribua -1 à quantidade de caracteres deste tipo.

Rotina para que se catalogue um tipo:
  Se o tipo for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Catalogue o tipo usando o nome deste tipo.

Função para que se determine se há algum problema de compilação;
Função para que se determine se existe algum problema de compilação:
  Se o sinalizador de erros deste compilador estiver ativado, diga sim.

Rotina para que se catalogue um tipo usando um nome:
  Se o tipo for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Encontre um existing tipo usando o nome e o catálogo de tipos.
  Se o existing tipo for inexistente,
    Catalogue o tipo usando o nome e o catálogo de tipos;
    Retorne.
  [Se o existing tipo já existir, então:]
  Atribua o endereço local deste tipo para um endereço local.
  Se o endereço local for inexistente, 
    Atribua o endereço local deste existing tipo ao endereço local. \ Aponta o erro para o tipo encontrado no código fonte, ao invés de um tipo gerado
  Se o endereço local não for inexistente,
    Apresente uma mensagem de erro contendo "Erro #001. Tipo: " junto com o nome seguido de "' duplicado." e o endereço local.

Rotina para que se apresente uma mensagem de erro contendo uma string e um endereço de byte:
  Se existir algum problema de compilação,
    Retorne.
  Ative o sinalizador de erros deste compilador.
  Atribua a string à mensagem de erro deste compilador.
  Encontre o endereço do arquivo atual deste compilador e o número da linha de erro deste compilador usando o endereço de byte .
  Se o endereço do arquivo atual deste compilador estiver em branco,
    Retorne.
  Extraia um nome do arquivo desde o endereço do arquivo atual deste compilador.
  Anteponha "Erro no arquivo '" junto com o nome do arquivo seguido de "'. " para a mensagem de erro deste compilador.

Rotina para que se encontre um endereço completo e um número da linha usando um endereço de byte:
  Limpe o endereço completo.
  Atribua 0 ao número da linha.
  Encontre um arquivo fonte usando o endereço de byte .
  Se o arquivo fonte for inexistente, retorne.
  Atribua o endereço completo deste arquivo fonte ao endereço completo.
  Encontre o número da linha usando o arquivo fonte e o endereço de byte .

Rotina para que se encontre um arquivo fonte usando um endereço de byte :
  Se o endereço de byte for inexistente,
    Esvazie o arquivo fonte;
    Retorne.
  Itere.
    Obtenha o arquivo fonte desde os arquivos fontes.
    Se o arquivo fonte for inexistente,
      Retorne.
    Se o endereço de byte for menor do que o caractere inicial deste trecho deste arquivo fonte,
      Reitere.
    Se o endereço de byte for maior do que o caractere final deste trecho deste arquivo fonte,
      Reitere.

Rotina para que se encontre um número da linha usando um arquivo fonte e um endereço de byte :
  Se o endereço de byte for inexistente,
    Atribua 0 ao número da linha;
    Retorne.
  Lance um subtexto sobre o trecho deste arquivo fonte.
  Atribua 1 ao número da linha.
  Itere.
    Se o subtexto estiver em branco, retorne.
    Se o caractere inicial deste subtexto for o endereço de byte , retorne.
    Se o conteúdo deste caractere inicial deste subtexto for o retorno de carro, 
      Adicione 1 para o número da linha.
    Adicione 1 para o caractere inicial deste subtexto.
  Reitere.

Rotina para que se compile um endereço da pasta (arquivos de código fonte): \#002
  Se existir algum problema de compilação, retorne.
  Escreva "Carregando arquivos..." junto com o texto CRLF para StdOut.
  Comece o temporizador de operacionalização.
  Carregue os arquivos fontes.
  Suspenda o temporizador de operacionalização.

Rotina para que se carregue uns arquivos fontes:
  Atribua ".pop" a uma extensão denominada extensão do arquivo.
  Anexe o caractere NULL após a  extensão do arquivo.
  Itere.
    Se existir algum problema de compilação, retorne.
    Obtenha um item desde o endereço da pasta deste compilador.
    Se o item não for encontrado, pare. \ Se não houver mais itens a analisar, pare.
    Se a categoria deste item não for "arquivo", reitere.
    Se a extensão deste  item não for a extensão do arquivo, reitere.
    \Se o item parece ser encadernável, reitere.
    Adicione um arquivo fonte para os arquivos fontes usando o endereço completo deste item.
    Carregue o arquivo fonte.
  Reitere.

Rotina para que se adicione um arquivo fonte para uns arquivos fontes usando um endereço completo:
  Crie o arquivo fonte.
  Acrescente o arquivo fonte para os arquivos fontes.
  Atribua o endereço completo ao endereço completo deste arquivo fonte.

Rotina para que se crie um arquivo fonte:
  Aloque memória para o arquivo fonte.

Rotina para que se carregue um arquivo fonte:
  Se o arquivo fonte for inexistente, retorne.
  \Carregue o endereço completo deste arquivo fonte para o trecho deste arquivo fonte.
  Carregue o endereço completo deste arquivo fonte para uma string. \ necessário para expandir contrações.
  Se o erro do fluxo de entrada/saída não estiver em branco,
    Apresente uma mensagem de erro contendo "Erro #002. Não foi possível carregar o arquivo: " 
      junto com o endereço completo deste arquivo fonte seguido de ".";
    Retorne.
  Parse a string para o trecho deste arquivo fonte (para expandir contrações).

Rotina para que se parse uma string para uma segunda string (para expandir contrações):
  Limpe a segunda string.
  Limpe uma terceira string.
  Lance o percorredor de contrações sobre a string.
  Itere.
    Se o segmento final deste percorredor de contrações estiver em branco, retorne.
    Posicione o segmento inicial deste percorredor de contrações sobre o segmento final deste percorredor de contrações.
    Mova o percorredor de contrações (englobando tudo).
    Se o conteúdo deste caractere inicial deste segmento inicial deste percorredor de contrações não for um byte ignorável,
      Acrescente o segmento inicial deste percorredor de contrações para a segunda string;
      Reitere.
    Acrescente o segmento inicial deste percorredor de contrações para a segunda string usando a terceira string (para expandir contrações).
    Atribua o segmento inicial deste percorredor de contrações à terceira string.
  Reitere.

Rotina para que se mova um percorredor (englobando tudo):
  Posicione o segmento inicial deste percorredor sobre o segmento final deste percorredor.
  Se o segmento final deste percorredor estiver em branco, retorne.
  \Se o conteúdo deste caractere inicial deste segmento final deste percorredor for "a",
  \ Avance o percorredor.
  \ Se o conteúdo deste caractere inicial deste segmento final deste percorredor for algum artigo indefinido,
  \ Recue o percorredor; atribua "para" para o percorredor.  
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for irrelevante,
    Mova o percorredor (ignorando os caracteres irrelevantes);
    Retorne.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for a barra invertida,
    Mova o percorredor (ignorando os comentários);
    Retorne.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for o colchete esquerdo,
    Mova o percorredor (ignorando as observações);
    Retorne.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for as aspas duplas,
    Mova o percorredor (conteúdo de texto);
    Retorne.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for o parênteses esquerdo,
    Mova o percorredor (qualificadores);
    Retorne.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for algum sinal de pontuação,
    Mova o percorredor (sinais de pontuação);
    Retorne.
  Se o percorredor estiver sobre algum possessivo inglês,
    Mova o percorredor (possessivo inglês);
    Retorne.
  Mova o percorredor (símbolos conectivos).

Rotina para que se mova um percorredor (ignorando os caracteres irrelevantes):
  [Itere.]
    Avance o percorredor.
    Se o segmento final deste percorredor estiver em branco, retorne.
    Se o conteúdo deste caractere inicial deste segmento final deste percorredor for irrelevante, reitere.

Rotina para que se mova um percorredor (ignorando os comentários):
  [Itere.]
    Avance o percorredor.
    Se o segmento final deste percorredor estiver em branco, retorne.
    Se o conteúdo deste caractere inicial deste segmento final deste percorredor não for o retorno de carro, reitere.

Rotina para que se mova um percorredor (ignorando as observações):
  [Itere.]
    Se o segmento final deste percorredor estiver em branco, retorne.
    Se o conteúdo deste caractere inicial deste segmento final deste percorredor for o retorno de carro, pare.
    Se o conteúdo deste caractere inicial deste segmento final deste percorredor for o colchete esquerdo, 
      Adicione 1 para uma contagem.
    Se o conteúdo deste caractere inicial deste segmento final deste percorredor for o colchete direito, 
      Subtraia 1 desde a contagem.
    Avance o percorredor.
    Se a contagem for 0, pare.
  Reitere.

Rotina para que se mova um percorredor (conteúdo de texto):
  [Itere.]
    Avance o percorredor.
    Se o segmento final deste percorredor estiver em branco, retorne.
    Se o conteúdo deste caractere inicial deste segmento final deste percorredor for o retorno de carro, retorne.
    Se o percorredor estiver sobre algum nested double-quote,
      Avance o percorredor;
      Reitere.
    Se o conteúdo deste caractere inicial deste segmento final deste percorredor for as aspas duplas,
      Avance o percorredor;
      Retorne.
  Reitere.

Função para que se determine se um percorredor está sobre algum nested double-quote:
  Se o segmento final deste percorredor começa com """""", diga sim.
  Diga não.

Rotina para que se mova um percorredor (qualificadores):
  [Itere.]
    Se o segmento final deste percorredor estiver em branco, retorne.
    Se o conteúdo deste caractere inicial deste segmento final deste percorredor for o retorno de carro, pare.
    Se o conteúdo deste caractere inicial deste segmento final deste percorredor for o parênteses esquerdo, 
      Adicione 1 para uma contagem.
    Se o conteúdo deste caractere inicial deste segmento final deste percorredor for o parênteses direito, 
      Subtraia 1 desde a contagem.
    Avance o percorredor.
    Se a contagem for 0, pare.
  Reitere.

Função para que se determine se um byte é algum sinal de pontuação:
  Se o byte for o ponto final, diga sim.
  Se o byte for o vírgula, diga sim.
  Se o byte for o ponto&vírgula, diga sim.
  Se o byte for o sinal de dois pontos, diga sim.
  Se o byte for o ponto de exclamação, diga sim.
  Se o byte for o ponto de interrogação, diga sim.
  Diga não.

Rotina para que se mova um percorredor (sinais de pontuação):
  Avance o percorredor.

Função para que se determine se um percorredor está sobre algum possessivo inglês:
  Se o segmento final deste percorredor estiver em branco, diga não.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor não for o single-quote byte, diga não. \ apóstrofo
  Se o percorredor estiver sobre algum possessivo inglês (tipo 1 - 's), diga sim.
  Se o percorredor estiver sobre algum possessivo inglês (tipo 2 - s'), diga sim.
  Diga não.

Função para que se determine se um percorredor está sobre algum possessivo inglês (tipo 1 - 's):
  Se o segmento final deste percorredor não começa com "'s", diga não.
  Preserve o percorredor.
  Adicione 2 para o caractere inicial deste segmento final deste percorredor.
  Se o segmento final deste percorredor estiver em branco, diga sim.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor não for um byte ignorável, diga sim.
  Diga não.

Função para que se determine se um percorredor está sobre algum possessivo inglês (tipo 2 - s'):
  Preserve o percorredor.
  Se o caractere inicial deste segmento final deste percorredor for o caractere inicial desta cópia da string original deste percorredor, diga não.
  Subtraia 1 desde o caractere inicial deste segmento final deste percorredor.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor não for o s minúsculo ou o S maiúsculo, diga não.
  Adicione 2 para o caractere inicial deste segmento final deste percorredor.
  Se o segmento final deste percorredor estiver em branco, diga sim.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor não for um byte ignorável, diga sim.
  Diga não.

Rotina para que se mova um percorredor (possessivo inglês):
  Avance o percorredor.
  Se o segmento final deste percorredor estiver em branco, retorne.
  Se o segmento final deste percorredor começa com "s", 
    Avance o percorredor.

Rotina para que se mova um percorredor (símbolos conectivos):
  [Itere.]
    Avance o percorredor.
    Se o segmento final deste percorredor estiver em branco, retorne.
    Se o percorredor estiver sobre algum possessivo inglês, retorne.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for um byte ignorável, reitere.

Rotina para que se acrescente uma string para uma segunda string usando uma terceira string (para expandir contrações):
  \contrações
  Se a string for "ao",
    Acrescente "a o" para a segunda string;
    Retorne.
  Se a string for "à",
    Acrescente "a a" para a segunda string;
    Retorne.
  Se a string for "aos",
    Acrescente "a os" para a segunda string;
    Retorne.
  Se a string for "às",
    Acrescente "a as" para a segunda string;
    Retorne.
  Se a string for "d'o",
    Acrescente "d' o" para a segunda string;
    Retorne.
  Se a string for "d'os",
    Acrescente "d' os" para a segunda string;
    Retorne.
  Se a string for "d'a",
    Acrescente "d' a" para a segunda string;
    Retorne.
  Se a string for "d'as",
    Acrescente "d' as" para a segunda string;
    Retorne.
  Se a string for "d'um",
    Acrescente "d' um" para a segunda string;
    Retorne.
  Se a string for "d'uns",
    Acrescente "d' uns" para a segunda string;
    Retorne.
  Se a string for "d'uma",
    Acrescente "d' uma" para a segunda string;
    Retorne.
  Se a string for "d'umas",
    Acrescente "d' umas" para a segunda string;
    Retorne.
  \Se a string estiver precisando ser decomposta, acrescente "de o" para a segunda string; Retorne.
  \Se a string for "dos", determine se a string precisa ser decomposta.
  \Se a string precisa ser decomposta, acrescente "de os" para a segunda string; exit
  \Se a string for "da", determine se a string precisa ser decomposta.
  \Se a string precisa ser decomposta, acrescente "de a" para a segunda string; exit
  \Se a string for "das", determine se a string precisa ser decomposta.
  \Se a string precisa ser decomposta, acrescente "de as" para a segunda string; exit
  \Se a string for "do", acrescente "de o" para a segunda string; Retorne.
  \Se a string for "da", acrescente "de a" para a segunda string; Retorne.
  \Se a string for "dos", acrescente "de os" para a segunda string; Retorne.
  \Se a string for "das", acrescente "de as" para a segunda string; Retorne.
  Se a string for "dum",
    Acrescente "de esse" para a segunda string;
    Retorne.
  Se a string for "duma",
    Acrescente "de essa" para a segunda string;
    Retorne.
  Se a string for "dumas",
    Acrescente "de esses" para a segunda string;
    Retorne.
  Se a string for "duns",
    Acrescente "de esses" para a segunda string;
    Retorne.
  Se a string for "daqui",
    Acrescente "de aqui" para a segunda string;
    Retorne.
  Se a string for "dali",
    Acrescente "de ali" para a segunda string;
    Retorne.
  Se a string for "dele",
    Acrescente "de ele" para a segunda string;
    Retorne.
  Se a string for "dela",
    Acrescente "de ela" para a segunda string;
    Retorne.
  Se a string for "desse",
    Acrescente "de esse" para a segunda string;
    Retorne.
  Se a string for "dessa",
    Acrescente "de essa" para a segunda string;
    Retorne.
  Se a string for "desses",
    Acrescente "de esses" para a segunda string;
    Retorne.
  Se a string for "dessas",
    Acrescente "de essas" para a segunda string;
    Retorne.
  Se a string for "deste",
    Acrescente "de este" para a segunda string;
    Retorne.
  Se a string for "desta",
    Acrescente "de esta" para a segunda string;
    Retorne.
  Se a string for "destes",
    Acrescente "de estes" para a segunda string;
    Retorne.
  Se a string for "destas",
    Acrescente "de estas" para a segunda string;
    Retorne.
  Se a string for "disso",
    Acrescente "de isso" para a segunda string;
    Retorne.
  Se a string for "disto",
    Acrescente "de isto" para a segunda string;
    Retorne.
  Se a string for "nesse",
    Acrescente "em esse" para a segunda string;
    Retorne.
  Se a string for "nesses",
    Acrescente "em esses" para a segunda string;
    Retorne.
  Se a string for "neste",
    Acrescente "em este" para a segunda string;
    Retorne.
  Se a string for "nestes",
    Acrescente "em estes" para a segunda string;
    Retorne.
  Se a string for "nisso",
    Acrescente "em isso" para a segunda string;
    Retorne.
  Se a string for "nisto",
    Acrescente "em isto" para a segunda string;
    Retorne.
  Se a string for "nessa",
    Acrescente "em essa" para a segunda string;
    Retorne.
  Se a string for "nessas",
    Acrescente "em essas" para a segunda string;
    Retorne.
  Se a string for "nesta",
    Acrescente "em esta" para a segunda string;
    Retorne.
  Se a string for "nestas",
    Acrescente "em estas" para a segunda string;
    Retorne.
  \Se a string for "donde", acrescente "de onde" para a segunda string; Retorne.
  \Se a string for "dentre", acrescente "de entre" para a segunda string; Retorne.
  \Se a string for "dantes", acrescente "de antes" para a segunda string; Retorne.
  Se a string for "dalguém",
    Acrescente "de alguém" para a segunda string;
    Retorne.
  Se a string for "dalgum",
    Acrescente "de um" para a segunda string;
    Retorne.
  Se a string for "dalguma",
    Acrescente "de uma" para a segunda string;
    Retorne.
  Se a string for "dalguns",
    Acrescente "de uns" para a segunda string;
    Retorne.
  Se a string for "dalgumas",
    Acrescente "de umas" para a segunda string;
    Retorne.
  Se a string for "nalgum",
    Acrescente "em um" para a segunda string;
    Retorne.
  Se a string for "nalguma",
    Acrescente "em uma" para a segunda string;
    Retorne.
  Se a string for "nalguns",
    Acrescente "em uns" para a segunda string;
    Retorne.
  Se a string for "nalgumas",
    Acrescente "em umas" para a segunda string;
    Retorne.
  Se a string for "doutro",
    Acrescente "de outro" para a segunda string;
    Retorne.
  Se a string for "doutra",
    Acrescente "de outra" para a segunda string;
    Retorne.
  Se a string for "doutros",
    Acrescente "de outros" para a segunda string;
    Retorne.
  Se a string for "doutras",
    Acrescente "de outras" para a segunda string;
    Retorne.
  Se a string for "noutro",
    Acrescente "em outro" para a segunda string;
    Retorne.
  Se a string for "noutra",
    Acrescente "em outra" para a segunda string;
    Retorne.
  Se a string for "noutros",
    Acrescente "em outros" para a segunda string;
    Retorne.
  Se a string for "noutras",
    Acrescente "em outras" para a segunda string;
    Retorne.
   \Se a string deveria ser expandida usando a terceira string (análise de termos compostos), atribua "desde" para a string; atribua "" para a segunda string; Retorne.
  Se a string for "na",
    Acrescente "em a" para a segunda string;
    Retorne.
  Se a string for "no",
    Acrescente "em o" para a segunda string;
    Retorne.
  Se a string for "nos",
    Acrescente "em os" para a segunda string;
    Retorne.
  Se a string for "nas",
    Acrescente "em as" para a segunda string;
    Retorne.
  \Se a string for "noutro", acrescente "em outro" para a segunda string; Retorne.
  \Se a string for "noutra", acrescente "em outra" para a segunda string; Retorne.
  \Se a string for "noutros", acrescente "em outros" para a segunda string; Retorne.
  \Se a string for "noutras", acrescente "em outras" para a segunda string; Retorne.
  Se a string for "num",
    Acrescente "em um" para a segunda string;
    Retorne.
  Se a string for "numa",
    Acrescente "em uma" para a segunda string;
    Retorne.
  Se a string for "nuns",
    Acrescente "em uns" para a segunda string;
    Retorne.
  Se a string for "numas",
    Acrescente "em umas" para a segunda string;
    Retorne.
  Se a string for "pelo",
    Acrescente "por o" para a segunda string;
    Retorne.
  Se a string for "pela",
    Acrescente "por a" para a segunda string;
    Retorne.
  Se a string for "pelos",
    Acrescente "por os" para a segunda string;
    Retorne.
  Se a string for "pelas",
    Acrescente "por as" para a segunda string;
    Retorne.
  Acrescente a string para a segunda string.

Rotina para que se compile um endereço da pasta (análise dos arquivos fornecidos): \#003
  Se existir algum problema de compilação, retorne.
  Escreva "Analisando o código fonte dos arquivos da pasta atual..." junto com o texto CRLF para StdOut.
  Comece o temporizador de análise/verificação.
  Examine os arquivos fontes.
  Suspenda o temporizador de análise/verificação.

Rotina para que se examine uns arquivos fontes:
  [Itere.] \ LOOP PRINCIPAL QUE FAZ O PARSING DOS ARQUIVOS
    Se existir algum problema de compilação, retorne.
    Obtenha um arquivo fonte desde os arquivos fontes.
    Se o arquivo fonte for inexistente, retorne.
    Examine o arquivo fonte.
  Reitere.

Rotina para que se examine um arquivo fonte:
  Se o arquivo fonte for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Lance um percorredor sobre o trecho deste arquivo fonte.
  Mova o percorredor (usando diretrizes de compilação).
  Itere. \ LOOP PRINCIPAL QUE EFETUA A ANÁLISE DO CONTEÚDO DOS ARQUIVOS
    Se existir algum problema de compilação, retorne.
    Se o segmento inicial deste percorredor estiver em branco, retorne.
    Se o segmento inicial deste percorredor for o início de algum tipo, \ ou seja, um artigo indefinido
      Examine um tipo usando o percorredor;
      Reitere.
    Se o segmento inicial deste percorredor for o início de alguma variável global, \ ou seja, um artigo definido
      Examine uma variável global usando o percorredor;
      Reitere.
    Se o segmento inicial deste percorredor for o início de alguma rotina, \ "Rotina" / "Função" / "Para"
      Examine uma rotina usando o percorredor;
      Reitere.
    Apresente uma mensagem de erro contendo "Erro #003. A expressão '" 
    junto com o segmento inicial deste percorredor seguido de "' não pode ser identificada corretamente. Verifique a sintaxe." e o percorredor.
  Reitere.

Rotina para que se mova um percorredor (usando diretrizes de compilação): \ talvez aqui conserte o comando "subtraia"
  [Itere.]
    Se o sinalizador de erros deste compilador estiver ativo,
       Limpe o segmento inicial deste percorredor;
       Retorne.
    Mova o percorredor retornando uma string de erro (englobando tudo).
    Se a string de erro não estiver em branco,
       Apresente uma mensagem de erro contendo a string de erro e o caractere inicial deste segmento inicial deste percorredor; \ Erro #004. 
       Retorne.
    \Se o segmento inicial deste percorredor for "del", recue o percorredor; Retorne. 
    Se o segmento inicial deste percorredor estiver em branco, retorne.
    Se o conteúdo deste caractere inicial deste segmento inicial deste percorredor for irrelevante, 
      Reitere.
    Se o conteúdo deste caractere inicial deste segmento inicial deste percorredor for a barra invertida, 
      Reitere.
    Se o conteúdo deste caractere inicial deste segmento inicial deste percorredor for o colchete esquerdo, 
      Reitere.

Rotina para que se mova um percorredor retornando uma string de erro (englobando tudo):
  Limpe a string de erro.
  Mova o percorredor (englobando tudo).
  Se o segmento inicial deste percorredor estiver em branco, retorne.
  Se o conteúdo deste caractere inicial deste segmento inicial deste percorredor for o colchete esquerdo,
    Mova o percorredor retornando a string de erro (diretrizes de validação de observações);
    Retorne.
  Se o conteúdo deste caractere inicial deste segmento inicial deste percorredor for as aspas duplas,
    Mova o percorredor retornando a string de erro (diretrizes de validação de conteúdos de texto);
    Retorne.
  Se o conteúdo deste caractere inicial deste segmento inicial deste percorredor for o parênteses esquerdo,
    Mova o percorredor retornando a string de erro (diretrizes de validação de qualificadores);
    Retorne.

Rotina para que se mova um percorredor retornando uma string de erro (diretrizes de validação de observações):
  Se a quantidade de caracteres deste segmento inicial deste percorredor for menor do que 2,
    Atribua "Erro #005. Observações devem terminar com um colchete ']'." para a string de erro;
    Retorne.
  Se o conteúdo deste caractere final deste segmento inicial deste percorredor não for o colchete direito,
    Atribua "Erro #006. Observações precisam terminar com um colchete ']'." para a string de erro;
    Retorne.

Rotina para que se mova um percorredor retornando uma string de erro (diretrizes de validação de conteúdos de texto):
  Se a quantidade de caracteres deste segmento inicial deste percorredor for menor do que 2,
    Atribua "Erro #007. Strings devem terminar com aspas duplas." para a string de erro;
    Retorne.
  Se o conteúdo deste caractere final deste segmento inicial deste percorredor não for as aspas duplas,
    Atribua "Erro #008. Strings precisam terminar com aspas duplas." para a string de erro;
    Retorne.

Rotina para que se mova um percorredor retornando uma string de erro (diretrizes de validação de qualificadores):
  Se a quantidade de caracteres deste segmento inicial deste percorredor for menor do que 2,
    Atribua "Erro #009. Qualificadores devem terminar com parêntese ')'." para a string de erro;
    Retorne.
  Se o conteúdo deste caractere final deste segmento inicial deste percorredor não for o parênteses direito,
    Atribua "Erro #010. Qualificadores precisam terminar com um parêntese ')'." para a string de erro;
    Retorne.

Função para que se determine se uma string é o início de algum tipo:
  Se a string for algum artigo indefinido, diga sim.
  Diga não.

Função para que se determine se uma string é algum artigo indefinido:
  Se a string for algum artigo indefinido português, diga sim.
  Se a string for algum pronome demonstrativo abrangente, diga sim.
  Diga não.

Função para que se determine se uma string é algum artigo indefinido português: 
  \PAL
  Se a string for "um", diga sim.
  Se a string for "uma", diga sim.
  Se a string for "uns", diga sim.
  Se a string for "umas", diga sim.
  \Se a string for "outro", diga sim.
  \Se a string for "outra", diga sim.
  \Se a string for "algum", diga sim.
  \Se a string for "alguma", diga sim.
  \Se a string for "alguns", diga sim.
  \Se a string for "algumas", diga sim.
  Se a string for algum pronome demonstrativo abrangente, diga sim. \ para funcionamento dos possessivos - local correto
  Diga não.

Função para que se determine se uma string é algum pronome demonstrativo abrangente:
  Se a string for "esse", diga sim.
  Se a string for "essa", diga sim.
  Se a string for "aquele", diga sim.
  Se a string for "aquela", diga sim.
  Se a string for "esses", diga sim.
  Se a string for "essas", diga sim.
  Se a string for "aqueles", diga sim.
  Se a string for "aquelas", diga sim.
  Se a string for "certo", diga sim.
  Se a string for "certa", diga sim.
  Se a string for "certos", diga sim.
  Se a string for "certas", diga sim.
  Se a string for "determinado", diga sim.
  Se a string for "determinada", diga sim.
  Se a string for "determinados", diga sim.
  Se a string for "determinadas", diga sim.
  Diga não.

Rotina para que se examine um tipo usando um percorredor:
  Se existir algum problema de compilação, retorne.
  \Se o segmento inicial deste percorredor for algum artigo indefinido português, 
    \Ative um sinalizador denominado sinalizador de artigo indefinido.
  Adicione o tipo para os tipos usando o caractere inicial deste segmento inicial deste percorredor.
  Mova o percorredor (usando diretrizes de compilação).
  Examine o nome deste tipo usando o percorredor.
  Atribua o nome deste tipo ao nome plural deste tipo.
  Atribua 0 para uma contagem.
  \Se o sinalizador de artigo indefinido estiver ativo,
    Pluralize o nome plural deste tipo (strings em português).\;
    \Adicione 1 à contagem.
  \Se a contagem for igual ou maior do que 2,
    \Apresente uma mensagem de erro contendo "Erro #010. não foi possível detectar o idioma desta variável" e o endereço local deste tipo;
    \Retorne.
  Se o segmento inicial deste percorredor for algum operador de atribuição de estruturas compostas,
    Examine o tipo usando o percorredor (cláusula 'tem');
    Retorne.
  Se o segmento inicial deste percorredor não for algum operador de atribuição simples,
    Apresente a mensagem de erro contendo "Erro #011. Esperado 'é/está'. Encontrado '" 
    junto com o segmento inicial deste percorredor seguido de "'." e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for algum valor numérico literal,
    Examine o tipo usando o percorredor (unidade de medida);
    Retorne.
  Se o segmento inicial deste percorredor não for algum artigo indefinido,
    Apresente a mensagem de erro contendo "Erro #012. O compilador esperava encontrar um artigo indefinido. Termo encontrado: '" 
    junto com o segmento inicial deste percorredor seguido de "'." e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine o nome do tipo primitivo deste tipo usando o percorredor.
  Examine algum dado complementar para o tipo usando o percorredor.
  Se o segmento inicial deste percorredor não for o ponto final,
    Apresente a mensagem de erro contendo "Erro #013. O compilador esperava encontrar '.' após a declaração do tipo."
    junto com o segmento inicial deste percorredor seguido de "." e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Catalogue o tipo.

Rotina para que se adicione um tipo para uns tipos usando um endereço local:
  Crie o tipo.
  Acrescente o tipo para os tipos.
  Atribua o endereço local ao endereço local deste tipo.

Rotina para que se examine um nome usando um percorredor:
  Limpe o nome.
  Se existir algum problema de compilação, retorne.
  Se o percorredor estiver sobre algum indicador de início de variável,
    Expanda o nome com o segmento inicial deste percorredor;
    Mova o percorredor (usando diretrizes de compilação).
  Itere.
    Se existir algum problema de compilação, retorne.
    Se o percorredor estiver sobre algum indicador de fim de variável, pare.
    Expanda o nome com o segmento inicial deste percorredor.
    Mova o percorredor (usando diretrizes de compilação).
  Reitere.
  Se o nome estiver em branco,
    Apresente uma mensagem de erro contendo "Erro #014. A variável '" 
    junto com o segmento inicial deste percorredor seguido de "' não foi definida ainda." e o percorredor;
    Retorne.

Função para que se determine se um percorredor está sobre algum indicador de início de variável:
  \ compare com indicador de fim de variável
  Se o segmento inicial deste percorredor for algum sinal de pontuação, diga não.
  Se o segmento inicial deste percorredor for algum símbolo, diga não.
  Se o segmento inicial deste percorredor for algum artigo, diga não.
  Se o segmento inicial deste percorredor for alguma conjunção, diga sim.
  Se o segmento inicial deste percorredor for algum possessivo inglês, diga não.
  Se o segmento inicial deste percorredor for algum verbo, diga sim.
  Se o segmento inicial deste percorredor for algum operador aritmético, diga sim.
  Se o percorredor estiver sobre alguma preposição, diga sim.
  Se o segmento inicial deste percorredor for algum qualificador, diga não.
  Se o segmento inicial deste percorredor for algum valor literal, diga não.
  Se o segmento inicial deste percorredor for uma palavra-chave de designação, diga sim.
  Se o segmento inicial deste percorredor for "então", diga sim.
  Se o segmento inicial deste percorredor for algum operador de atribuição composto, diga sim.
  Se o segmento inicial deste percorredor estiver em branco, diga não.
  Diga sim.

Função para que se determine se uma string é algum símbolo:
  Se a quantidade de caracteres desta string não for 1, diga não.
  Se o conteúdo deste caractere inicial desta string for algum símbolo, diga sim.
  Diga não.

Função para que se determine se um byte é algum símbolo: \ deveria estar no cérebro
  Se o byte for o acento circumflexo, diga sim.
  Se o byte for o barra vertical, diga sim.
  Se o byte for o asterisco, diga sim.
  Se o byte for o sinal de adição, diga sim.
  Se o byte for o hífem, diga sim.
  Se o byte for o barra inclinada, diga sim.
  Se o byte for o símbolo menor do que, diga sim.
  Se o byte for o símbolo maior do que, diga sim.
  Se o byte for a chave esquerda, diga sim.
  Se o byte for a chave direita, diga sim.
  Se o byte for o sinal de igualdade, diga sim.
  Se o byte for 128, diga sim.
  Se o byte for 130, diga sim.
  Se o byte estiver entre 132 e 137, diga sim.
  Se o byte for 139, diga sim.
  Se o byte estiver entre 145 e 153, diga sim.
  Se o byte for 155, diga sim.
  Se o byte estiver entre 161 e 180, diga sim.
  Se o byte estiver entre 183 e 191, diga sim.
  Se o byte for 215, diga sim.
  Se o byte for 247, diga sim.
  Diga não.

Função para que se determine se uma string é algum artigo:
  Se a string for algum artigo indefinido, diga sim.
  Se a string for algum artigo definido, diga sim.
  Diga não.

Função para que se determine se uma string é algum artigo definido:
  Se a string for "o", diga sim.
  Se a string for "a", diga sim.
  Se a string for "os", diga sim.
  Se a string for "as", diga sim.
  Se a string for algum pronome demonstrativo adjacente, diga sim.
  Diga não.

Função para que se determine se uma string é algum pronome demonstrativo adjacente:
  Se a string for "este", diga sim.
  Se a string for "esta", diga sim.
  Se a string for "estes", diga sim.
  Se a string for "estas", diga sim.
  Diga não.

Função para que se determine se uma string é alguma conjunção:
  \# verificar depois o uso dos termos: "ambos", "mas" e "nenhum"
  Se a string for "e", diga sim.
  Se a string for "ou", diga sim.
  Se a string for "nem", diga sim.
  \CAL
  Se a string for "neither", diga sim.
  Se a string for "nor", diga sim.
  Diga não.

Função para que se determine se uma string é algum possessivo inglês:
  Se a string for "'s", diga sim.
  Se a string for "'", diga sim.
  Diga não.

Função para que se determine se uma string é algum verbo:
  \PAL
  Se a string for "deve", diga sim.
  Se a string for "deveria", diga sim.
  Se a string for "deveriam", diga sim.
  Se a string for "devem", diga sim.
  Se a string for "estar", diga sim.
  Se a string for "ser", diga sim.
  Se a string for "for", diga sim.
  Se a string for "forem", diga sim.
  Se a string for "estiver", diga sim.
  Se a string for "estiverem", diga sim.
  Se a string for "estamos", diga sim.
  Se a string for "há", diga sim.
  Se a string for "houver", diga sim.
  Se a string for "é", diga sim.
  Se a string for "está", diga sim.
  Se a string for "são", diga sim.
  Se a string for "estão", diga sim.
  Se a string for "foi", diga sim.
  Se a string for "estava", diga sim.
  Se a string for "foram", diga sim.
  Se a string for "estavam", diga sim.
  Se a string for "será", diga sim.
  Se a string for "estará", diga sim.
  Se a string for "serão", diga sim.
  Se a string for "estarão", diga sim.
  Se a string for "existir", diga sim.
  Se a string for "existe", diga sim.
  \Se a string for "seja", diga sim.
  Se a string for "supera", diga sim.
  Se a string for "superam", diga sim.
  Se a string for "excede", diga sim.
  Se a string for "excedem", diga sim.
  Se a string for "pode", diga sim.
  Se a string for "puder", diga sim.
  Se a string for "puderem", diga sim.
  Se a string for "podem", diga sim.
  Se a string for "poderia", diga sim.
  Se a string for "poderia", diga sim.
  Se a string for "podemos", diga sim.
  Se a string for "tem", diga sim.
  Se a string for "têm", diga sim.
  Se a string for "ter", diga sim.
  Se a string for "possui", diga sim.
  Se a string for "possuem", diga sim.
  Se a string for "possuir", diga sim.
  \\ trouble makers
  Se a string for "inicia", diga sim.
  Se a string for "iniciar", diga sim.
  Se a string for "começa", diga sim.
  Se a string for "começar", diga sim.
  Se a string for "termina", diga sim.
  Se a string for "terminar", diga sim.
  Se a string for "finaliza", diga sim.
  Se a string for "finalizar", diga sim.
  Se a string for "parece", diga sim.
  Se a string for "necessita", diga sim.
  Se a string for "necessitar", diga sim.
  Se a string for "requer", diga sim.
  \\ trouble makers
  Diga não.

Função para que se determine se uma string é algum operador aritmético:
  Se a string for "mais", diga sim.
  Se a string for "menos", diga sim.
  Se a string for "vezes", diga sim.
  Se a string for "dividido", diga sim.
  Se a string for "depois", diga sim.
  Se a string for algum operador de concatenação, diga sim.
  \Se a string for "seguido", diga sim.
  \Se a string for "juntamente", diga sim.
  \Se a string for "junto", diga sim.
  \Se a string for "acompanhado", diga sim.
  Diga não.

Função para que se determine se um percorredor está sobre alguma preposição:
  Atribua o segmento inicial deste percorredor para um subtexto.
  Se o percorredor estiver sobre algum preposição conectiva, diga sim. \ "a" no sentido de "para"
  Se o subtexto for "a_partir_de", diga sim.
  Se o subtexto for "abaixo", diga sim.
  \Se o subtexto for "baixo", diga sim.
  Se o subtexto for "acima", diga sim.
  \Se o subtexto for "cima", diga sim.
  Se o subtexto for "ante", diga sim.
  Se o subtexto for "perante", diga sim.
  Se o subtexto for "antes", diga sim.
  Se o subtexto for "debaixo", diga sim.
  Se o subtexto for "sob", diga sim.
  Se o subtexto for "acerca", diga sim.
  Se o subtexto for "cerca", diga sim.
  Se o subtexto for "cuja", diga sim.
  Se o subtexto for "cujo", diga sim.
  Se o subtexto for "cujas", diga sim.
  Se o subtexto for "cujos", diga sim.
  \Se o subtexto for "próximo", diga sim.
  Se o subtexto for "perto", diga sim.
  Se o subtexto for "com", diga sim.
  \Se o subtexto for "contendo", diga sim.
  Se o subtexto for "como", diga sim.
  Se o subtexto for "contra", diga sim.
  Se o subtexto for "dada", diga sim.
  Se o subtexto for "dado", diga sim.
  Se o subtexto for "dando", diga sim.
  Se o subtexto for "gerando", diga sim.
  Se o subtexto for "resultando", diga sim.
  Se o subtexto for "retornando", diga sim.
  Se o subtexto for "desde", diga sim.
  Se o subtexto for "depois", diga sim.
  Se o subtexto for "após", diga sim.
  Se o subtexto for "durante", diga sim.
  Se o subtexto for "em", diga sim.
  Se o subtexto for "entre", diga sim.
  Se o subtexto for "dentre", diga sim.
  Se o subtexto for "até", diga sim.
  \Se o subtexto for "que", diga sim.
  \Se o subtexto for "esquerda", diga sim.
  Se o subtexto for "mediante", diga sim.
  Se o subtexto for "para", diga sim.
  Se o subtexto for "via", diga sim.
  Se o subtexto for "segundo", diga sim.
  Se o subtexto for "acordo", diga sim.
  Se o subtexto for "sem", diga sim.
  Se o subtexto for "então", diga sim.
  Se o subtexto for "sobre", diga sim.
  Se o subtexto for "usando", diga sim.
  Se o subtexto for "versus", diga sim.
  Se o subtexto for "enquanto", diga sim.
  Se o subtexto for "aproximadamente", diga sim.
  Se o subtexto for "através", diga sim.
  Se o subtexto for "algum", diga sim.
  Se o subtexto for "sob", diga sim.
  Se o subtexto for "debaixo", diga sim.
  Se o subtexto for "entre", diga sim.
  \Se o subtexto for "baixo", diga sim. -> erro
  Se o subtexto for "por", diga sim.
  Se o subtexto for "usando", diga sim.
  Se o subtexto for "pertencente", diga sim.
  Se o subtexto for "pertencente", diga sim.
  Se o subtexto for "pertinente", diga sim.
  Se o subtexto for "relativo", diga sim.
  Se o subtexto for "relativa", diga sim.
  Se o subtexto for "concernente", diga sim.
  Se o subtexto for "atinente", diga sim.
  Se o subtexto for "pertinente", diga sim.
  Se o subtexto for "retornando", diga sim.
  Se o subtexto for "começando", diga sim.
  Se o subtexto for "começando", diga sim.
  Se o subtexto for "iniciando", diga sim.
  Se o subtexto for "usando", diga sim.
  Se o subtexto for "via", diga sim.
  Se o subtexto for "com", diga sim.
  Se o subtexto for "aproada", diga sim.
  Se o subtexto for "aproado", diga sim.
  Se o subtexto for "aproando", diga sim.
  Se o subtexto for "orientada", diga sim.
  Se o subtexto for "orientado", diga sim.
  Se o subtexto for "orientando", diga sim.
  Se o subtexto for "orientando-se", diga sim.
  Se o subtexto for "voltada", diga sim.
  Se o subtexto for "voltado", diga sim.
  Se o subtexto for "virada", diga sim.
  Se o subtexto for "virado", diga sim.
  Se o subtexto for "virando", diga sim.
  Se o subtexto for "virando-se", diga sim.
  Se o subtexto for "tão", diga sim.
  Se o subtexto for "tanto", diga sim.
  Se o subtexto for "quanto", diga sim.
  Se o subtexto for "quão", diga sim.
  Se o subtexto for "after", diga sim.
  Se o subtexto for "regressivamente", diga sim.
  Se o subtexto for "dentro de", diga sim.
  Se o subtexto for "dentro", diga sim.
  Se o subtexto for "parecida", diga sim.
  Se o subtexto for "parecido", diga sim.
  Se o subtexto for "semelhante", diga sim.
  Se o subtexto for "similar", diga sim.
  Se o subtexto for "em comprimento", diga sim.
  Se o subtexto for "d'", diga sim.
  Se o subtexto for "d'", diga sim.
  Se o subtexto for "só", diga sim.
  Se o subtexto for "somente", diga sim.
  Se o subtexto for "unicamente", diga sim.
  Se o subtexto for "exclusivamente", diga sim.
  Se o subtexto for "apenas", diga sim.
  Se o subtexto for "fora", diga sim.
  Se o subtexto for "menores", diga sim.
  Se o subtexto for "alta", diga sim.
  Se o subtexto for "alto", diga sim.
  Se o subtexto for "comprido", diga sim.
  Se o subtexto for "comprida", diga sim.
  Se o subtexto for "largo", diga sim.
  Se o subtexto for "larga", diga sim.
  Diga não.

Função para que se determine se uma string é algum qualificador:
  Se a string estiver em branco, diga não.
  Se o conteúdo deste caractere inicial desta string for o parênteses esquerdo, diga sim.
  Diga não.

Função para que se determine se uma string é algum valor literal:
  Se a string for algum ponteiro literal, diga sim.
  Se a string for algum valor numérico literal, diga sim.
  Se a string for algum string literal, diga sim.
  \Se a string for algum sinalizador literal, diga sim. ***
  Se a string for algum valor hexadecimal literal, diga sim.
  Diga não.

Função para que se determine se uma string é uma palavra-chave de designação:
  Se a string for "chamado", diga sim.
  Se a string for "chamados", diga sim.
  Se a string for "chamada", diga sim.
  Se a string for "chamadas", diga sim.
  Se a string for "denominado", diga sim.
  Se a string for "denominados", diga sim.
  Se a string for "denominada", diga sim.
  Se a string for "denominadas", diga sim.
  Diga não.

Função para que se determine se uma string é algum operador de atribuição composto:
  Se a string for "igual", diga sim.
  Diga não.

Rotina para que se expanda uma string com uma segunda string:
  Se a segunda string estiver em branco, retorne.
  Se a string não estiver em branco, 
    Acrescente o caractere de espaço para a string.
  Acrescente a segunda string para a string.

Função para que se determine se um percorredor está sobre algum indicador de fim de variável:
  \ compare com indicador de início de variável
  Se o segmento inicial deste percorredor for algum sinal de pontuação, diga sim.
  Se o segmento inicial deste percorredor for algum símbolo, diga sim.
  Se o segmento inicial deste percorredor for algum artigo, diga sim.
  Se o segmento inicial deste percorredor for alguma conjunção, diga sim.
  Se o segmento inicial deste percorredor for algum possessivo inglês, diga sim.
  Se o percorredor estiver sobre algum possessivo reverso, diga sim. \ 
  Se o segmento inicial deste percorredor for algum verbo, diga sim.
  Se o segmento inicial deste percorredor for algum operador aritmético, diga sim.
  Se o percorredor estiver sobre alguma preposição, diga sim.
  Se o segmento inicial deste percorredor for algum qualificador, diga sim.
  Se o segmento inicial deste percorredor for algum valor literal, diga sim.
  Se o segmento inicial deste percorredor for uma palavra-chave de designação, diga sim.
  Se o segmento inicial deste percorredor for "então", diga sim.
  Se o segmento inicial deste percorredor for algum operador de atribuição composto, diga sim.
  Se o segmento inicial deste percorredor estiver em branco, diga sim.
  Se o segmento inicial deste percorredor for algum advérbio de negação, diga sim.
  Diga não.

Função para que se determine se um percorredor está sobre algum possessivo reverso:
  Preserve o percorredor.
  Se o segmento inicial deste percorredor não for "de", diga não.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for algum pronome demonstrativo, diga sim.
  Diga não.

Função para que se determine se uma string é algum pronome demonstrativo:
  Se a string for algum pronome demonstrativo adjacente, diga sim.
  Se a string for algum pronome demonstrativo abrangente, diga sim.
  Diga não.

Rotina para que se pluralize uma string (strings em português):
  Lance um percorredor sobre a string.
  Itere.
    Mova o percorredor (usando diretrizes de compilação).
    Se o segmento inicial deste percorredor estiver em branco, pare.
    Se uma string plural não estiver em branco,
      Acrescente " " para a string plural.
    Acrescente o segmento inicial deste percorredor para a string plural.
    Se o segmento inicial deste percorredor for "de",
      Ative um sinalizador;
      Reitere. \ PLURAL
    Se o sinalizador não estiver ativo, 
      Pluralize a string plural (português - regras comuns) .
  Reitere.
  Atribua a string plural à string.

Rotina para que se pluralize uma string (português - regras comuns) :
  \# https://www.normaculta.com.br/singular-e-plural/
  \# palavras que são exceções às regras
  \Se a string for "caráter",
    \Atribua "carateres" à string;
    \Retorne.
  Se a string for "júnior",
    Atribua "juniores" à string;
    Retorne.
  Se a string for "sênior",
    Atribua "seniores" à string;
    Retorne.
  \# advérbios principais
  Se a string for "muito", retorne.
  Se a string for "pouco", retorne.
  Se a string for "mais", retorne.
  Se a string for "menos", retorne.
  Se a string for "bastante", retorne.
  Se a string for "quase", retorne.
  Se a string for "demais", retorne.
  Se a string for "bem", retorne.
  Se a string for "deveras", retorne.
  Se a string for "mal", retorne.
  Se a string for "melhor", retorne.
  Se a string for "pior", retorne.
  \# palavras terminadas com "ão"
  Se a string termina com "ão",
    Pluralize a string (terminada com "ão");
    Retorne.
  \# palavras terminadas com "d"
  Se a string termina com "d",
    Pluralize a string (terminada com outras letras);
    Retorne.
  \# palavras terminadas com "l"
  Se a string termina com "l",
    Pluralize a string (terminada com "l");
    Retorne.
  \# palavra terminadas com "m"
  Se a string termina com "m",
    Remova o último caractere desde a string;
    Acrescente "ns" para a string;
    Retorne.
  \# palavra terminadas com "n" (essa regra é preferível porque mantém o acento da palavra, se houver)
  Se a string termina com "n",
    Acrescente "es" para a string;
    Retorne.
  \# palavras terminadas com "r"
  Se a string termina com "r",
    Pluralize a string (terminada com "r");
    Retorne.
  \# palavras terminadas com "s"
  Se a string termina com "s",
    Pluralize a string (terminada com "s");
    Retorne.
  \# palavras terminadas com "t"
  Se a string termina com "t",
    Pluralize a string (terminada com outras letras);
    Retorne.
  \# palavra terminadas com "x"
  Se a string termina com "x",
    Pluralize a string (terminada com "x");
    Retorne.
  \# palavras terminadas com "z"
  Se a string termina com "z",
    Pluralize a string (terminada com "z");
    Retorne.
  Se a string termina com "#",
    Acrescente "s" para a string;
    Retorne.
  Se a string não termina com alguma vogal ou com alguma consoante,
    Acrescente "s" para a string;
    Retorne.
  \# regra padrão
  [Caso contrário,]
  Acrescente "s" para a string. \ Só acrescenta o "s" caso nenhuma das condições acima tenha siddo correspondida.
  \Volte.

Rotina para que se pluralize uma string (terminada com "ão"):
  \A formação do plural dos substantivos terminados -ão pode ser feita de três formas distintas: -ões, -ãos, -ães.
  \Alguns substantivos terminados em -ão admitem duas (ou até três) formas no plural:
  \refrão - refrãos ou refrães;
  \corrimão - corrimões ou corrimãos;
  \guardião - guardiões ou guardiães;
  \vilão - vilões, vilãos ou vilães.
    \TODOS os substantivos paroxítonos terminados em -ão formam o plural com -ãos.
  \ALGUNS substantivos oxítonos também têm o seu plural formado segundo essa regra:
  \órfão - órfãos;
  \sótão - sótãos;
  \órgão - órgãos;
  \cidadão - cidadãos;
  \irmão - irmãos;
  \cristão - cristãos.
  Se a string for "cidadão",
    Acrescente "s" para a string;
    Retorne.
  Se a string for "irmão",
    Acrescente "s" para a string;
    Retorne.
  Se a string for "cristão",
    Acrescente "s" para a string;
    Retorne.
  Se a string for "refrão",
    Acrescente "s" para a string;
    Retorne.
  Se a string for "mão",
    Acrescente "s" para a string;
    Retorne.
  Se a string for "são",
    Acrescente "s" para a string;
    Retorne.
  \-ão no singular para -ães no plural:
  \Alguns substantivos terminados em -ão formam o plural com -ães.
  Se a string for "pão",
    Remova o último caractere desde a string;
    Acrescente "es" para a string;
    Retorne.
  Se a string for "capitão",
    Remova o último caractere desde a string;
    Acrescente "es" para a string;
    Retorne.
  Se a string for "alemão",
    Remova o último caractere desde a string;
    Acrescente "es" para a string;
    Retorne.
  Se a string for "charlatão",
    Remova o último caractere desde a string;
    Acrescente "es" para a string;
    Retorne.
  Lance um subtexto sobre a string.
  Subtraia 2 desde o caractere final deste subtexto.   \ remova o "ão". Acho que não precisa
  \caso encontre acentos em sílabas prévias, faça o seguinte
  Se o subtexto possui alguma vogal acentuada,
    Acrescente "s" para a string;
    Retorne. \-> exemplo: órgão
  \# regra padrão
  \A maioria dos substantivos terminados em -ão forma o plural com -ões:
  \opinião - opiniões;
  \coração - corações;
  \eleição - eleições.
  Remova os dois últimos caracteres desde a string. Acrescente "ões" para a string.\ Retorne.

Rotina para que se pluralize uma string (terminada com outras letras):
  Acrescente "s" para a string. \ Retorne.

Rotina para que se pluralize uma string (terminada com "l"):
  \# palavras terminadas com "al"
  Se a string termina com "al",
    Pluralize a string (terminada com "al");
    Retorne. \ MAL -> MALES
  \# palavras terminadas com "el"
  Se a string termina com "el",
    Pluralize a string (terminada com "el");
    Retorne. \PASTEL - PASTÉIS
  \# palavras terminadas com "il"
  Se a string termina com "il",
    Pluralize a string (terminada com "il");
    Retorne. \-> FUZIL -> FUZIS
  \# palavras terminadas com "ol"
  Se a string termina com "ol",
    Pluralize a string (terminada com "ol");
    Retorne. \- LENÇOL -> LENÇÓIS
  \# palavras terminadas com "ul"
  Se a string termina com "ul",
    Pluralize a string (terminada com "ul");
    Retorne. \ AZUL -> AZUIS \ Cônsul - cônsules
  [Caso a string seja uma sigla, tipo URL]
  Acrescente "s" para a string. \ Retorne.

Rotina para que se pluralize uma string (terminada com "al"):
  Se a string for "mal",
    Atribua "males" para a string;
    Retorne.
  Remova o último caractere desde a string. \remova a letra L
  Acrescente "is" para a string. \ Retorne.

Rotina para que se pluralize uma string (terminada com "el"):
  \Se a string for "pixel", atribua "pixels" para a string; Retorne.
  \# acentos em sílabas prévias
  Lance um subtexto sobre a string.
  Subtraia 2 desde o caractere final deste subtexto. \ remova o el
  Se o subtexto possui alguma vogal acentuada,
    Remova o último caractere desde a string;
    Acrescente "is" para a string;
    Retorne.
  Remova os dois últimos caracteres desde a string.
  Acrescente "éis" para a string. \ Retorne.

Rotina para que se pluralize uma string (terminada com "il"):
  \Se a string for "canil", atribua "canis" para a string; Retorne.
  \Se a string for "covil", atribua "covis" para a string; Retorne.
  \Se a string for "funil", atribua "funis" para a string; Retorne.
  \Se a string for "barril", atribua "barris" para a string; Retorne.
  \Se a string for "fuzil", atribua "fuzis" para a string; Retorne.
  \Se a string for "redil", atribua "redis" para a string; Retorne.
  \# acentos em sílabas prévias
  Lance um subtexto sobre a string.
  Subtraia 2 desde o caractere final deste subtexto.
  Se o subtexto possui alguma vogal acentuada,
    Remova os dois últimos caracteres desde a string;
    Acrescente "eis" para a string;
    Retorne.
  Remova o último caractere desde a string. \ remova a letra L
  Acrescente "s" para a string. \ Retorne.

Rotina para que se pluralize uma string (terminada com "ol"):
  \# acentos em sílabas prévias
  Lance um subtexto sobre a string.
  Subtraia 2 desde o caractere final deste subtexto.
  Se o subtexto possui alguma vogal acentuada,
    Remova o último caractere desde a string;
    Acrescente "is" para a string;
    Retorne.
  Remova os dois últimos caracteres desde a string.
  Acrescente "óis" para a string. \ Retorne.

Rotina para que se pluralize uma string (terminada com "ul"):
  Se a string for "cônsul",
    Atribua "cônsules" à string;
    Retorne.
  Remova o último caractere desde a string. \ remova o L
  Acrescente "is" para a string. \ Retorne.

Rotina para que se pluralize uma string (terminada com "r"):
  \# acentos em sílabas prévias
  Lance um subtexto sobre a string.
  Subtraia 2 desde o caractere final deste subtexto.
  Se o subtexto possui alguma vogal acentuada,
    Acrescente "es" para a string;
    Retorne.
  \# hiatos
  Se a string termina com "air",
    Remova os dois últimos caracteres desde a string;
    Acrescente "íres" para a string;
    Retorne.
  Se a string termina com "aur",
    Remova os dois últimos caracteres desde a string;
    Acrescente "úres" para a string;
    Retorne.
  \# regra padrão
  Acrescente "es" para a string. \ Retorne.

Rotina para que se pluralize uma string (terminada com "s"):
\Quando os substantivos terminados em -s são paroxítonos, a formação do plural fica invariável:.
  \# proparoxítonas/paroxítonas terminadas com "as", "es", "os"
  Se a string termina com "as",
    Acrescente "es" para a string;
    Retorne. \atlas
  Se a string termina com "es",
      Acrescente "es" para a string;
    Retorne. \atlas
  Se a string termina com "os",
      Acrescente "es" para a string;
    Retorne. \atlas
  \# hiatos acentuados
  Se a string termina com "aís",
    Acrescente "es" para a string;
    Retorne.
  Se a string termina com "aús",
    Acrescente "es" para a string;
    Retorne.
  \# oxítonas terminadas com "ás", "âs", "és", "ês", "ís", "ós", "ôs", "ús"
  Se a string termina com "ás",
    Remova os dois últimos caracteres desde a string;
    Acrescente "ases" para a string;
    Retorne.
  Se a string termina com "âs",
    Remova os dois últimos caracteres desde a string;
    Acrescente "ases" para a string;
    Retorne.
  Se a string termina com "és",
    Remova os dois últimos caracteres desde a string;
    Acrescente "eses" para a string;
    Retorne.
  Se a string termina com "ês",
    Remova os dois últimos caracteres desde a string;
    Acrescente "eses" para a string;
    Retorne.
  Se a string termina com "ís",
    Remova os dois últimos caracteres desde a string;
    Acrescente "ises" para a string;
    Retorne.
  Se a string termina com "ós",
    Remova os dois últimos caracteres desde a string;
    Acrescente "oses" para a string;
    Retorne.
  Se a string termina com "ôs",
    Remova os dois últimos caracteres desde a string;
    Acrescente "oses" para a string;
    Retorne.
  Se a string termina com "ús",
    Remova os dois últimos caracteres desde a string;
    Acrescente "uses" para a string;
    Retorne.
  \# palavras terminadas com "is", "us"
  Se a string termina com "is",
    Pluralize a string (terminada com "is" ou com "us");
    Retorne.
  Se a string termina com "us",
    Pluralize a string (terminada com "is" ou com "us");
    Retorne. \ônibus / vírus
  \Se a string termina com "ts", exit.
  \# regra padrão
  Acrescente "es" para a string. \ Retorne.

Rotina para que se pluralize uma string (terminada com "is" ou com "us"):
  \# acentos em sílabas prévias
  Lance um subtexto sobre a string.
  Subtraia 2 desde o caractere final deste subtexto.
  Se o subtexto possui alguma vogal acentuada, retorne.
  \# hiatos
  Se a string termina com "ais",
    Remova os dois últimos caracteres desde a string;
    Acrescente "íses" para a string;
    Retorne. \cais não varia....
  Se a string termina com "aus",
    Remova os dois últimos caracteres desde a string;
    Acrescente "úses" para a string;
    Retorne.
  \# regra padrão
  Acrescente "es" para a string. \ Retorne.

Rotina para que se pluralize uma string  (terminada com "x"):
  \Se a string for "px",
    \acrescente "pxs" para a string;
    \Retorne.
  Se a string for "fax",
    Acrescente "es" para a string;
    Retorne.
  Acrescente "s" para a string. \ tratamento de exceções
   \ Retorne.

Rotina para que se pluralize uma string (terminada com "z"):
  \# hiatos acentuados
  Se a string termina com "aíz",
    Acrescente "es" para a string;
    Retorne.
  Se a string termina com "aúz",
    Acrescente "es" para a string;
    Retorne.
  \# palavras terminas em "áz", "âz", "éz", "êz", "íz", "óz", "ôz", "úz"
  Se a string termina com "áz",
    Remova os dois últimos caracteres desde a string;
    Acrescente "azes" para a string;
    Retorne.
  Se a string termina com "âz",
    Remova os dois últimos caracteres desde a string;
    Acrescente "azes" para a string;
    Retorne.
  Se a string termina com "éz",
    Remova os dois últimos caracteres desde a string;
    Acrescente "ezes" para a string;
    Retorne.
  Se a string termina com "êz",
    Remova os dois últimos caracteres desde a string;
    Acrescente "ezes" para a string;
    Retorne.
  Se a string termina com "íz",
    Remova os dois últimos caracteres desde a string;
    Acrescente "izes" para a string;
    Retorne.
  Se a string termina com "óz",
    Remova os dois últimos caracteres desde a string;
    Acrescente "ozes" para a string;
    Retorne.
  Se a string termina com "ôz",
    Remova os dois últimos caracteres desde a string;
    Acrescente "ozes" para a string;
    Retorne.
  Se a string termina com "úz",
    Remova os dois últimos caracteres desde a string;
    Acrescente "uzes" para a string;
    Retorne.
  \# acentos em sílabas prévias
  Lance um subtexto sobre a string.
  Subtraia 2 desde o caractere final deste subtexto.
  Se o subtexto possui alguma vogal acentuada,
    Acrescente "es" para a string;
    Retorne.
  \# hiatos
  Se a string termina com "aiz",
    Remova os dois últimos caracteres desde a string;
    Acrescente "ízes" para a string;
    Retorne.
  Se a string termina com "auz",
    Remova os dois últimos caracteres desde a string;
    Acrescente "úzes" para a string;
    Retorne.
  \# regra padrão
  Acrescente "es" para a string. \ Retorne.

Rotina para que se pluralize uma string:
  Lance um percorredor sobre a string.
  Itere.
    Mova o percorredor (usando diretrizes de compilação).
    Se o segmento inicial deste percorredor estiver em branco, pare.
    Se uma string plural não estiver em branco, acrescente " " para a string plural.
    Acrescente o segmento inicial deste percorredor para a string plural.
    Se o segmento inicial deste percorredor for "de",
      Ative um sinalizador;
      Reitere. \ PLURAL
    Se o sinalizador não estiver ativo, 
      Pluralize a string plural (português - regras comuns).
  Reitere.
  Atribua a string plural à string.

Rotina para que se examine um tipo usando um percorredor (cláusula 'tem'):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Atribua "estrutura" ao nome do tipo primitivo deste tipo.
  Examine os campos deste tipo usando o percorredor.
  Se o segmento inicial deste percorredor não for o ponto final,
    Apresente uma mensagem de erro contendo "Erro #015. Esperado '.' no final da estrutura. Encontrado '" 
    junto com o segmento inicial deste percorredor seguido de "'." e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Catalogue o tipo.

Rotina para que se examine uns campos usando um percorredor:
  [Itere.]
    Se existir algum problema de compilação, retorne.
    Adicione um campo para os campos usando "campo" e o caractere inicial deste segmento inicial deste percorredor.
    Examine o campo usando o percorredor.
    Se o segmento inicial deste percorredor não for alguma pausa, retorne.
    Examine algum pauses usando o percorredor.
  Reitere.

Rotina para que se adicione uma variável para umas variáveis usando um categoria e um endereço local:
  Crie a variável usando a categoria.
  Acrescente a variável para as variáveis.
  Atribua o endereço local ao endereço local desta variável.

Rotina para que se crie uma variável usando um categoria:
  Aloque memória para a variável.
  Atribua a categoria à categoria desta variável.
  Atribua 1 à contagem desta variável.

Rotina para que se examine um campo usando um percorredor:
  Se existir algum problema de compilação, retorne.
  Examine o campo usando o percorredor (tipo geral).
  Itere.
    Se existir algum problema de compilação, retorne.
    Se o segmento inicial deste percorredor for uma palavra-chave de designação,
      Examine o campo usando o percorredor (cláusula designadora);
      Reitere.
    Se o segmento inicial deste percorredor for "sob",
      Examine o campo usando o percorredor (cláusula de redefinição);
      Reitere.
    \Se o segmento inicial deste percorredor for "equivalente a", 
      \ Examine o campo usando o percorredor (cláusula de redefinição); 
      \ Reitere.
    \Se o segmento inicial deste percorredor for "análogo a", 
      \ Examine o campo usando o percorredor (cláusula de redefinição); 
      \ Reitere.
    \Se o segmento inicial deste percorredor for "análoga a",
      \Examine o campo usando o percorredor (cláusula de redefinição); 
      \ Reitere.
    Se o segmento inicial deste percorredor for "em",
      Examine o campo usando o percorredor (cláusula de redefinição);
      Reitere.
    \Se o segmento inicial deste percorredor for "sob",
      \Examine o campo usando o percorredor (cláusula de redefinição);
      \Reitere.
    Se o segmento inicial deste percorredor for "sobre",
      Examine o campo usando o percorredor (cláusula de redefinição);
      Reitere.
    Se o segmento inicial deste percorredor for uma palavra-chave de referenciamento,
      Examine o campo usando o percorredor (cláusula de referência);
      Reitere.
  [Caso nenhuma condição acima seja satisfeita, pare (sai do loop)]

Rotina para que se examine um campo usando um percorredor (tipo geral):
  Se existir algum problema de compilação, retorne.
  Se o segmento inicial deste percorredor for algum valor numérico literal,
    Examine o campo usando o percorredor (tipo: array de bytes);
    Retorne.
  Examine o campo usando o percorredor (tipo normal).

Rotina para que se examine um campo usando um percorredor (tipo: array de bytes):
  Se existir algum problema de compilação, retorne.
  Converta o segmento inicial deste percorredor para uma proporção.
  Reduza a proporção.
  Se o denominador desta proporção não for 1,
    Apresente uma mensagem de erro contendo "Erro #016. Erro de sintaxe. Arrays devem possuir tamanhos não fracionários." e o percorredor;
    Retorne.
  Atribua o numerador desta proporção à contagem deste campo.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for "byte" ou "bytes",
    Apresente a mensagem de erro contendo "Erro #017. Erro de sintaxe. É necessário escrever a palavra 'bytes' após informar a quantidade correspondente." e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Atribua "byte" ao nome do tipo deste campo.

Rotina para que se examine um campo usando um percorredor (tipo normal):
  Se existir algum problema de compilação, retorne.
  Se o segmento inicial deste percorredor não for algum artigo indefinido,
    Apresente uma mensagem de erro contendo "Erro #018. Erro de sintaxe. Esperado 'um/uma'. Encontrado: '" 
    junto com o segmento inicial deste percorredor seguido de "'." e o percorredor;
    Retorne.
  \Se o segmento inicial deste percorredor for "outra", 
    \Atribua "outra" ao nome deste campo.
  \Se o segmento inicial deste percorredor for "outras", 
    \Atribua "outras" ao nome deste campo.
  \Se o segmento inicial deste percorredor for "outro", 
    \Atribua "outro" ao nome deste campo.
  \Se o segmento inicial deste percorredor for "outros", 
    \Atribua "outros" ao nome deste campo.
  Se o segmento inicial deste percorredor for "segundo", 
    Atribua "segundo" ao nome deste campo.
  Se o segmento inicial deste percorredor for "segundos", 
    Atribua "segundos" ao nome deste campo.
  Se o segmento inicial deste percorredor for "segunda", 
    Atribua "segunda" ao nome deste campo.
  Se o segmento inicial deste percorredor for "segundas", 
    Atribua "segundas" ao nome deste campo.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Expanda o nome deste campo com o nome.

Rotina para que se examine um campo usando um percorredor (cláusula designadora):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o nome do tipo deste campo estiver em branco, 
    Atribua o nome deste campo ao nome do tipo deste campo. \ byte array type name already filled in
  Examine o nome deste campo usando o percorredor.

Rotina para que se examine um campo usando um percorredor (cláusula de redefinição):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum artigo definido,
    Apresente uma mensagem de erro contendo "Erro #019. Sintaxe incorreta. Esperado 'o/a'. Encontrado: '" 
    junto com o segmento inicial deste percorredor seguido de "'." e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine o novo nome deste campo usando o percorredor.

Função para que se determine se uma string é uma palavra-chave de referenciamento:
  Se a string for "(referência)", diga sim.
  Diga não.

Rotina para que se examine um campo usando um percorredor (cláusula de referência):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Ative o sinalizador de referência deste campo.

Função para que se determine se uma string é alguma pausa:
  Se a string for "e", diga sim.
  Se a string for "ou", diga sim.
  \default
  Se a string for ",", diga sim.
  Se a string for ";", diga sim.
  Diga não.

Rotina para que se examine algum pauses usando um percorredor:
  [Itere.]
    Se existir algum problema de compilação, retorne.
    Se o segmento inicial deste percorredor não for alguma pausa, retorne.
    Mova o percorredor (usando diretrizes de compilação).
  Reitere.

Rotina para que se examine um tipo usando um percorredor (unidade de medida):
  Se existir algum problema de compilação, retorne.
  Converta o segmento inicial deste percorredor para a razão de escala deste tipo.
  Se a razão de escala deste tipo for 0,
    Apresente uma mensagem de erro contendo "Erro #020. O valor 0 não é permitido como razão de escala." e o endereço local deste tipo;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine o nome do tipo primitivo deste tipo usando o percorredor.
  Se o segmento inicial deste percorredor não for o ponto final,
    Apresente a mensagem de erro contendo "Erro #021. Necessário um '.' no fim desta fração. Encontrado: '" 
    junto com o segmento inicial deste percorredor seguido de "'." e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Catalogue o tipo.

Função para que se determine se uma string é o início de alguma variável global:
  Se a string for algum artigo definido, diga sim.
  Diga não.

Rotina para que se examine uma variável global usando um percorredor:
  Se existir algum problema de compilação, retorne.
  Adicione a variável global para as variáveis globais usando "global" e o caractere inicial deste segmento inicial deste percorredor.
  Mova o percorredor (usando diretrizes de compilação).
  Examine o nome desta variável global usando o percorredor.
  Se o segmento inicial deste percorredor for algum operador de atribuição de estruturas compostas,
    Examine a variável global usando o percorredor (cláusula 'tem');
    Retorne.
  Se o segmento inicial deste percorredor não for algum operador de atribuição simples,
    Apresente uma mensagem de erro contendo "Erro #022. Erro de sintaxe. Esperado: 'é/está'. Encontrado: '" 
    junto com o segmento inicial deste percorredor seguido de "'." e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum artigo indefinido,
    Examine a variável global usando o percorredor (literal termo);
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine o nome do tipo desta variável global usando o percorredor.
  Se o segmento inicial deste percorredor for o início de algum dado complementar,
    Examine a variável global usando o percorredor (dados complementares);
    Retorne.
  Se o segmento inicial deste percorredor for algum operador de atribuição composto,
    Examine a variável global usando o percorredor (data part);
    Retorne.
  Se o segmento inicial deste percorredor não for o ponto final,
    Apresente a mensagem de erro contendo "023. Erro de sintaxe. Declaração de variáveis globais devem terminar com um '.'" e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Catalogue a variável global.

Função para que se determine se uma string é algum operador de atribuição de estruturas compostas:
  Se a string for "tem", diga sim.
  Se a string for "têm", diga sim.
  Se a string for "contém", diga sim.
  Se a string for "contêm", diga sim.
  \Se a string for "possui", diga sim.
  Diga não.

Rotina para que se examine uma variável global usando um percorredor (cláusula 'tem'):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Atribua "~inline " junto com o nome desta variável global seguido de " tipo" para um nome. \ 
  Atribua o nome seguido de "s" para um nome plural. \ PLURAL - mudar aqui
  Adicione um tipo para os tipos usando o nome e o nome plural e "estrutura" e o endereço local desta variável global. \ mudar aqui
  Catalogue o tipo.
  Atribua o nome deste tipo ao nome do tipo desta variável global.
  Examine os campos deste tipo usando o percorredor.
  Se o segmento inicial deste percorredor não for o ponto final,
    Apresente uma mensagem de erro contendo "Erro #023. Erro de sintaxe. Necessário inserir um '.' ao final de declarações de estruturas" e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Catalogue a variável global.

Rotina para que se catalogue uma variável global:
  Se existir algum problema de compilação, retorne.
  Se a variável global for inexistente, retorne.
  Se o nome desta variável global estiver no catálogo de variáveis globais,
    Apresente uma mensagem de erro contendo "Erro #024. O identificador '" 
    junto com o nome desta variável global seguido de "' já foi definido anteriormente como variável global." e o endereço local desta variável global;
    Retorne.
  Catalogue a variável global usando o nome desta variável global e o catálogo de variáveis globais.

Função para que se determine se uma string é algum operador de atribuição simples:
  Se a string for "é", diga sim.
  Se a string for "está", diga sim.
  Se a string for "são", diga sim.
  Se a string for "estão", diga sim.
  Se a string for "estamos", diga sim.
  Se a string for "for", diga sim.
  Se a string for "forem", diga sim.
  Se a string for "estiverem", diga sim.
  Se a string for "estarem", diga sim.
  Se a string for "possui", diga sim.
  \Se a string for "ocupa", diga sim.
  \Se a string for "tem", diga sim.
  Diga não.

Rotina para que se examine uma variável global usando um percorredor (literal termo):
  Se existir algum problema de compilação, retorne.
  Examine o corpo de variável global desta variável global usando o percorredor.
  Se o segmento inicial deste percorredor não for o ponto final,
    Apresente uma mensagem de erro contendo "Erro #025. Erro de sintaxe. Necessário inserir um '.' após a atribuição de um valor numérico ou textual." e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Catalogue a variável global.

Rotina para que se examine um corpo de variável global usando um percorredor:
  Se existir algum problema de compilação, retorne.
  Se o segmento inicial deste percorredor estiver em branco, retorne.
  Atribua o caractere inicial deste segmento inicial deste percorredor ao caractere inicial deste corpo de variável global.
  Atribua -1 ao caractere final deste corpo de variável global.
  Itere.
    Se existir algum problema de compilação, retorne.
    Se o segmento inicial deste percorredor estiver em branco, retorne.
    Se o segmento inicial deste percorredor for o sinal de dois pontos, retorne.
    Se o segmento inicial deste percorredor for o ponto final, retorne.
    Atribua o caractere final deste segmento inicial deste percorredor ao caractere final deste corpo de variável global.
    Mova o percorredor (usando diretrizes de compilação).
  Reitere.

Rotina para que se examine uma variável global usando um percorredor (dados complementares):
  Se existir algum problema de compilação, retorne.
  Atribua "~inline " junto com o nome desta variável global seguido de " tipo" para um nome.
  Atribua o nome seguido de "s" para um nome plural. \ aqui pode estar o erro na formação do plural
  Adicione um tipo para os tipos usando o nome e o nome plural e o nome do tipo desta variável global e o endereço local desta variável global.
  Catalogue o tipo.
  Atribua o nome deste tipo ao nome do tipo desta variável global.
  Examine algum dado complementar para o tipo usando o percorredor.
  Se o segmento inicial deste percorredor não for o ponto final,
    Apresente uma mensagem de erro contendo "Erro #026. Erro de sintaxe. Necessário incluir um '.' após a declaração de informações complementares." e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Catalogue a variável global.

\Rotina para que se examine algum dado complementar de um tipo usando um percorredor:
Rotina para que se examine algum dado complementar para um tipo usando um percorredor:
  Se existir algum problema de compilação, retorne.
  \Se o segmento inicial deste percorredor for "to",
    \Examine algum dado complementar para o tipo usando o percorredor (ponteiros);
    \Retorne.
  Se o segmento inicial deste percorredor for "para",
    Examine algum dado complementar para o tipo usando o percorredor (ponteiros);
    Retorne.
  Se o segmento inicial deste percorredor for alguma palavra-chave de complementação,
    Examine algum dado complementar para o tipo usando o percorredor (estrutura);
    Retorne.

Rotina para que se examine algum dado complementar para um tipo usando um percorredor (ponteiros):
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum artigo indefinido,
    Apresente uma mensagem de erro contendo "Erro #027. Sintaxe incorreta no comando 'Aponte para um(a)'. Expressão encontrada: '" 
    junto com o segmento inicial deste percorredor seguido de "'." e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine o nome do conteúdo deste tipo usando o percorredor.

Função para que se determine se uma string é alguma palavra-chave de complementação:
  Se a string for "com", diga sim.
  Se a string for "contendo", diga sim.
  Diga não.

Rotina para que se examine algum dado complementar para um tipo usando um percorredor (estrutura):
  Mova o percorredor (usando diretrizes de compilação).
  Examine os campos deste tipo usando o percorredor.

Rotina para que se examine uma variável global usando um percorredor (data part):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum to,
    Apresente uma mensagem de erro contendo "Erro #028. Erro de sintaxe na declaração da variável global." 
    junto com " O compilador esperava encontrar a expressão: 'igual a'. Expressão encontrada: '" 
    junto com o segmento inicial deste percorredor seguido de "'." e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine o corpo de variável global desta variável global usando o percorredor.
  Se o segmento inicial deste percorredor não for o ponto final,
    Apresente a mensagem de erro contendo "Erro #029. Erro de sintaxe. Esperado '.' ao final de uma declaração variável variável global." e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Catalogue a variável global.

Função para que se determine se uma string é algum to: \ igual a 
  Se a string for "a", diga sim. 
  \Se a string for "para", diga sim.
  Diga não.

Função para que se determine se uma string é o início de alguma rotina:
  \PAL
  Se a string for "Rotina", diga sim.
  Se a string for "Função", diga sim.
  Se a string for "Para", diga sim.
  Se a string for "Passos", diga sim.
  Se a string for "Etapas", diga sim.
  Se a string for "Procedimento", diga sim.
  Diga não.

Rotina para que se examine uma rotina usando um percorredor:
    \ Define o cabeçalho de rotina.
  Se existir algum problema de compilação, retorne.
  Adicione a rotina para as rotinas usando o caractere inicial deste segmento inicial deste percorredor.
  Se o segmento inicial deste percorredor for syntatic sugar, 
    Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for "para",
    Apresente uma mensagem de erro contendo "Erro #030. Erro de sintaxe. É necessário incluir a palavra-chave 'para' '" 
    junto com o segmento inicial deste percorredor seguido de "' neste cabeçalho de rotina." e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação). \ ignora o "para" e obtém o próximo segmento inicial
  Se o segmento inicial deste percorredor for "que", 
    Mova o percorredor (usando diretrizes de compilação).
  \Se o segmento inicial deste percorredor não for "que",
    \apresente uma mensagem de erro contendo "Você precisa colocar um 'que' antes da palavra: " 
    \junto com o segmento inicial deste percorredor seguido de "." e o percorredor;
    \Retorne.
  \Mova o percorredor (usando diretrizes de compilação). \ ignora o "que" e obtém o próximo segmento inicial
  Se o segmento inicial deste percorredor for "se", 
    Mova o percorredor (usando diretrizes de compilação).
  \Se o segmento inicial deste percorredor não for "se",
    \apresente uma mensagem de erro contendo "Você precisa colocar um 'se' antes da palavra: " 
    \junto com o segmento inicial deste percorredor seguido de "." e o percorredor;
    \Retorne.
  \Mova o percorredor (usando diretrizes de compilação). \ ignora o "se" e obtém o próximo segmento inicial
  Examine a cabeçalho de rotina desta rotina usando o percorredor.
  Se o segmento inicial deste percorredor for o ponto&vírgula,
    Examine a rotina usando o percorredor (sobrecarga de métodos);
    Retorne. \ *** usado para nomes alternativos de rotinas
  Se o segmento inicial deste percorredor não for o sinal de dois pontos,
    Apresente a mensagem de erro contendo "Erro #031. Erro de sintaxe. ':' ausente ou mal posicionado" e o endereço local desta rotina;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine as instruções desta rotina usando o percorredor.

Rotina para que se adicione uma rotina para umas rotinas usando um endereço local:
  Crie a rotina.
  Acrescente a rotina para as rotinas.
  Atribua o endereço local ao endereço local desta rotina.

Função para que se determine se uma string é syntatic sugar:
  \PAL
  Se a string for "Passos", diga sim.
  Se a string for "Etapas", diga sim.
  Se a string for "Procedimento", diga sim.
  Se a string for "Rotina", diga sim.
  Se a string for "Função", diga sim.
  Diga não.

Rotina para que se examine uma rotina usando um percorredor (sobrecarga de métodos):
  \ *** para nomes alternativos de rotinas
  Preserve o percorredor.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for o início de alguma rotina,
    Apresente uma mensagem de erro contendo "Erro #032. Erro de sintaxe. ';' ausente ou mal posicionado" e o percorredor original;
    Retorne.
  Atribua o caractere inicial deste segmento inicial deste percorredor original ao caractere inicial destas instruções desta rotina.
  Atribua o caractere final deste segmento inicial deste percorredor original ao caractere final destas instruções desta rotina.
  Mova o percorredor original (usando diretrizes de compilação).

Rotina para que se examine umas instruções usando um percorredor:
  Se existir algum problema de compilação, retorne.
  Se o segmento inicial deste percorredor estiver em branco, retorne.
  Se o segmento inicial deste percorredor for o enunciado de alguma rotina ou variável, retorne.
  Atribua o caractere inicial deste segmento inicial deste percorredor ao caractere inicial destas instruções.
  Itere.
    Se existir algum problema de compilação, retorne.
    Se o segmento inicial deste percorredor estiver em branco, retorne.
    Atribua o caractere final deste segmento inicial deste percorredor ao caractere final destas instruções.
    Se o segmento inicial deste percorredor for o sinal de dois pontos,
      Apresente uma mensagem de erro contendo "033. Insira ':' ao final do cabeçalho desta rotina." e o percorredor;
      Retorne.
    Se o segmento inicial deste percorredor não for o ponto final,
      Mova o percorredor (usando diretrizes de compilação);
      Reitere.
    Mova o percorredor (usando diretrizes de compilação).
    Se o segmento inicial deste percorredor for o enunciado de alguma rotina ou variável, retorne.
  Reitere.

Função para que se determine se uma string é o enunciado de alguma rotina ou variável:
  Se a string for syntatic sugar, diga sim.
  \default
  Se a string for algum artigo indefinido, diga sim.
  Se a string for algum artigo definido, diga sim.
  Diga não.

Rotina para que se compile um endereço da pasta (identificação dos tipos das variáveis): \ Etapa #004
  Se existir algum problema de compilação, retorne.
  Escreva "Identificando os tipos das variáveis..." junto com o texto CRLF para StdOut.
  Comece o temporizador de resolução de tipos.
  Destrinche os tipos (expansão de listas).
  Destrinche os tipos (registro de plurais).
  Destrinche os tipos (tipos de dados primitivos).
  Destrinche os tipos (dados complementares).
  Suspenda o temporizador de resolução de tipos.

Rotina para que se destrinche uns tipos (expansão de listas):
  [Itere.]
    Se existir algum problema de compilação, retorne.
    Obtenha um tipo desde o tipos.
    Se o tipo for inexistente, retorne. \ Após o último tipo da lista, não haverão mais tipos a serem analisados.
    Destrinche o tipo (expand lista).
  Reitere.

Rotina para que se destrinche um tipo (expand lista): 
  \ Usado quando o tipo base do tipo ainda não pode ser determinado
  Se existir algum problema de compilação, retorne.
  Se o tipo for inexistente, retorne. \ se o tipo não existir é porque chegamos ao fim dos tipos da lista
  Se o tipo base deste tipo NÃO for inexistente, retorne. \ se o tipo BASE existir é porque o compilador já o determinou anteriormente
  Se o nome deste tipo for "lista", retorne. \ 
  \Se o nome deste tipo for "elemento", retorne.
  Se o tipo não puder ser reduzido para "lista" usando o nome do tipo primitivo, retorne. \ 
  Encontre um tipo base usando o nome do tipo primitivo deste tipo e o catálogo de tipos.
  \ O trecho abaixo cria uma estrutura denominada lista estruturada 
  \ O número campos "secretos" está codificado rigidamente em 2 lugares. Pesquise por "do que 4" (era "do que 6")
  Atribua o nome deste tipo seguido de " estruturada" para um nome.
  Atribua o nome deste tipo seguido de " estruturadas" para um nome plural.
  Atribua o nome deste tipo base seguido de " estruturada" para um nome do tipo primitivo.
  Adicione um tipo estruturado para os tipos usando o nome e o nome plural e o nome do tipo primitivo.
  Adicione um campo para os campos deste tipo estruturado usando 
    "próximo " junto com 
    O nome deste tipo e 
    "próximo" e 
    O nome deste tipo e
    O sinalizador de ignição.
  Adicione um campo português para os campos deste tipo estruturado usando 
    "próxima " junto com 
    O nome deste tipo e 
    "próxima" e 
    O nome deste tipo e 
    O sinalizador de ignição.
  Atribua "próximo " junto com o nome deste tipo ao novo nome deste campo português.
  Adicione um segundo campo para os campos deste tipo estruturado usando 
    "precedente " junto com 
    O nome deste tipo e 
    "precedente" e 
    O nome deste tipo e 
    O sinalizador de ignição.
  Adicione um segundo campo português para os campos deste tipo estruturado usando 
    O nome deste tipo seguido de 
    " anterior" e 
    "anterior" e \ vem antes do nome do tipo
    O nome deste tipo e 
    O sinalizador de ignição.
  Atribua "precedente " junto com o nome deste tipo ao novo nome deste segundo campo português.
  Se os campos deste tipo não estiverem vazios, 
    Acrescente os campos deste tipo para os campos deste tipo estruturado.
  Catalogue o tipo estruturado.
  \ fix up original tipo para look like um ponteiro
  Atribua o nome deste tipo estruturado ao nome do conteúdo deste tipo.
  \ LISTAS
  Adicione um tipo encadeado para os tipos usando o nome plural deste tipo e "" e o nome plural deste tipo base.
  Adicione um terceiro campo para os campos deste tipo encadeado usando "primeiro " 
    junto com o nome deste tipo e "primeiro" e o nome deste tipo e o sinalizador de ignição.
  Adicione um terceiro campo português para os campos deste tipo encadeado usando "primeira " 
    junto com o nome deste tipo e "primeira" e o nome deste tipo e o sinalizador de ignição.

Função para que se determine se um tipo pode ser reduzido para uma string usando o nome do tipo primitivo:
  Se o tipo for inexistente, diga não.
  Se o nome deste tipo for[igual] a string, diga sim.
  Se o sinalizador de recursividade deste tipo estiver ativo, diga não.
  Ative o sinalizador de recursividade deste tipo.
  Encontre um tipo base usando o nome do tipo primitivo deste tipo e o catálogo de tipos.
  Se o tipo base for inexistente,
    Desative o sinalizador de recursividade deste tipo;
    Diga não.
  Se o tipo base puder ser reduzido para a string usando o nome do tipo primitivo,
    Desative o sinalizador de recursividade deste tipo;
    Diga sim.
  Desative o sinalizador de recursividade deste tipo.
  Diga não.

Função para que se determine se um tipo pode ser reduzido para um nome do tipo:
  Se o tipo for inexistente, diga não.
  Preserve o tipo.
  Itere.
    Se o tipo for inexistente, diga não.
    Se o nome deste tipo for o nome do tipo, diga sim.
    Se o tipo base deste tipo for o tipo, diga não.
    Atribua o tipo base deste tipo ao tipo.
  Reitere.

Rotina para que se adicione um campo para uns campos usando um nome e um apelido e um nome do tipo e um sinalizador de referência:
  Adicione o campo para os campos usando "campo" e nil.
  Atribua o nome ao nome deste campo.
  Atribua o apelido ao apelido deste campo.
  Atribua o nome do tipo ao nome do tipo deste campo.
  Atribua o sinalizador de referência ao sinalizador de referência deste campo.

Rotina para que se destrinche uns tipos (registro de plurais):
  [Itere.]
    Se existir algum problema de compilação, retorne.
    Obtenha um tipo desde o tipos.
    Se o tipo for inexistente, retorne.
    Destrinche o tipo (registro de plurais).
  Reitere.

Rotina para que se destrinche um tipo (registro de plurais):
  Se existir algum problema de compilação, retorne.
  Se o tipo for inexistente, retorne.
  Se o nome plural deste tipo estiver em branco, retorne.
  Se o tipo puder ser reduzido para "lista" usando o nome do tipo primitivo, retorne.
  Catalogue o tipo usando o nome plural deste tipo.

Rotina para que se destrinche uns tipos (tipos de dados primitivos): 
  \ Rotina recursiva.
  [Itere.]
    Se existir algum problema de compilação, retorne.
    Obtenha um tipo desde o tipos.
    Se o tipo for inexistente, retorne.
    Destrinche o tipo (tipos de dados primitivos).
  Reitere.

Rotina para que se destrinche um tipo (tipos de dados primitivos):
  Se existir algum problema de compilação, retorne.
  Se o tipo for inexistente, retorne.
  Se o tipo base deste tipo não for inexistente, retorne.
  Encontre o tipo base deste tipo usando o nome do tipo primitivo deste tipo e o catálogo de tipos.
  Se o tipo base deste tipo for inexistente,
    Apresente uma mensagem de erro contendo "Erro #034. O identificador '" 
    junto com o nome do tipo primitivo deste tipo seguido de "' não possui um tipo base pré-definido." e o endereço local deste tipo;
    Retorne.
  Ative o sinalizador de recursividade deste tipo.
  Se o sinalizador de recursividade deste tipo base deste tipo estiver ativo,
    Apresente a mensagem de erro contendo "Erro #035. Detectado uma efinição recursiva no tipo '" 
    junto com o nome do tipo primitivo deste tipo seguido de "'." e o endereço local deste tipo;
    Retorne.
  Destrinche o tipo base deste tipo (tipos de dados primitivos). \ RECURSÃO
  Desative o sinalizador de recursividade deste tipo.

Rotina para que se destrinche uns tipos (dados complementares):
  [Itere.]
    Se existir algum problema de compilação, retorne.
    Obtenha um tipo desde o tipos.
    Se o tipo for inexistente, retorne.
    Destrinche o tipo (dados complementares).
  Reitere.

Rotina para que se destrinche um tipo (dados complementares):
  Se existir algum problema de compilação, retorne.
  Se o tipo for inexistente, retorne.
  Se o sinalizador de informações complementares deste tipo estiver ativo, retorne.
  Se o tipo base deste tipo for o [próprio] tipo, retorne. \ para os tipos pré-definidos. Ver nota explicativa abaixo.
  Verifique por informações opcionais inválidas no tipo.
  Ative o sinalizador de recursividade deste tipo.
  Destrinche o tipo base deste tipo (dados complementares).
  \ A seção abaixo somente é executada após encontrar o tipo base pré-definido, onde a rotina retorna para a versão anterior de si mesma devido a recursividade
  Se o tipo puder ser reduzido para "ponteiro", 
    Destrinche o tipo (dados opcionais - ponteiro).
  Se o tipo puder ser reduzido para "estrutura", 
    Destrinche o tipo (dados opcionais - conjunto). \ mudar aqui
  Se o tipo puder ser reduzido para "número", 
    Destrinche o tipo (dados opcionais - scale).
  Desative o sinalizador de recursividade deste tipo.
  Ative o sinalizador de informações complementares deste tipo.

Rotina para que se verifique por informações opcionais inválidas em um tipo:
  Se existir algum problema de compilação, retorne.
  Se o tipo for inexistente, retorne.
  Se o nome do conteúdo deste tipo não estiver em branco, 
    Verifique por informações opcionais inválidas no tipo (conteúdo).
  Se o campos deste tipo não estiverem vazios, 
    Verifique por informações opcionais inválidas no tipo (campos).
  Se a razão de escala deste tipo não for 0, 
    Verifique por informações opcionais inválidas no tipo (tipos fracionários).

Rotina para que se verifique por informações opcionais inválidas em um tipo (conteúdo):
  Se existir algum problema de compilação, retorne.
  Se o tipo não puder ser reduzido para "ponteiro",
    Apresente uma mensagem de erro contendo "Erro #036. Só é possível apontar para variáveis do tipo ponteiro." e o endereço local deste tipo;
    Retorne.

Rotina para que se verifique por informações opcionais inválidas em um tipo (campos):
  Se existir algum problema de compilação, retorne.
  Se o tipo não puder ser reduzido para "estrutura",
    Apresente uma mensagem de erro contendo "Erro #037. Campos só podem ser adicionados nos tipos derivados de 'estrutura' ou 'lista'." e o endereço local deste tipo; \ ABCDE
    Retorne. 

Rotina para que se verifique por informações opcionais inválidas em um tipo (tipos fracionários):
  Se existir algum problema de compilação, retorne.
  Se o tipo não puder ser reduzido para "número",
    Apresente uma mensagem de erro contendo "Erro #038. Proporções e escalas de medida só podem ser utilizadas em tipos numéricos." e o endereço local deste tipo;
    Retorne.

Rotina para que se destrinche um tipo (dados opcionais - ponteiro):
  Se existir algum problema de compilação, retorne.
  Se o tipo do conteúdo deste tipo não for inexistente, retorne.
  Se o nome do conteúdo deste tipo estiver em branco,
    Atribua o tipo do conteúdo deste tipo base deste tipo ao tipo do conteúdo deste tipo;
    Retorne.
  Encontre o tipo do conteúdo deste tipo usando o nome do conteúdo deste tipo e o catálogo de tipos.
  Se o tipo do conteúdo deste tipo for nulo,
    Apresente uma mensagem de erro contendo "Erro #039. Ponteiro com referência nula no tipo '" 
    junto com o nome deste tipo seguido de "'." e o endereço local deste tipo;
    Retorne.

Rotina para que se destrinche um tipo (dados opcionais - conjunto):
  Se existir algum problema de compilação, retorne.
  Se os campos deste tipo estiverem vazios,
    Copie os campos deste tipo base deste tipo aos campos deste tipo;
    Retorne.
  Itere.
    Se existir algum problema de compilação, retorne.
    Obtenha um campo desde os campos deste tipo (regressivamente).
    Se o campo for inexistente, pare.
    Se o campo estiver duplicado nos campos deste tipo,
      Apresente uma mensagem de erro contendo "Erro #040. O campo '" 
      junto com o nome deste campo seguido de "' está definido mais de uma vez nesta estrutura." e o endereço local deste campo;
      Retorne.
    Destrinche o campo.
    Se existir algum problema de compilação, retorne.
    Se o sinalizador de recursividade deste tipo deste campo estiver ativo,
      Apresente a mensagem de erro contendo "Erro #041. Definição recursiva encontrada no campo '" 
      \junto com o nome deste campo seguido de "'. Tipo detectado: '" 
      junto com o nome deste tipo deste campo seguido de "'." e o endereço local deste campo;
      Retorne.
    Destrinche o tipo deste campo (dados complementares). \ de novo
    Se o sinalizador de referência deste campo não estiver ativo, 
      Reitere.
    Se o tipo deste campo não puder ser reduzido para "ponteiro",
      Apresente a mensagem de erro contendo "Erro #042. Não é possível colocar '(referência)' no campo '"
      junto com o nome deste campo seguido de "' pois referências somente são aplicáveis a ponteiros." e o endereço local deste campo;
      Retorne.
  Reitere.
  Elimine apelidos duplicados desde os campos deste tipo.
  Se o tipo não puder ser reduzido para "lista estruturada", retorne.
  Se a contagem destes campos deste tipo for maior do que 4, retorne. \ already copied? was 2 por próximo e prev, now 6 para included Spanish redefiniions
  Copie os campos deste tipo base deste tipo aos campos deste tipo (apenas campos de dados).

Rotina para que se copie uns campos para uns segundo campos:
  [Itere]
    Obtenha um campo desde o campos.
    Se o campo for inexistente, retorne.
    Copie o campo para um segundo campo.
    Acrescente o segundo campo para o segundo campos.
  Reitere.

Rotina para que se copie um campo para um segundo campo:
  Se o campo for inexistente,
    Esvazie o segundo campo;
    Retorne.
  Aloque memória para o segundo campo.
  Atribua o endereço local deste campo ao endereço local deste segundo campo.
  Atribua o nome deste campo ao nome deste segundo campo.
  Atribua o apelido deste campo ao apelido deste segundo campo.
  Atribua o nome do tipo deste campo ao nome do tipo deste segundo campo.
  Atribua o tipo deste campo ao tipo deste segundo campo.
  Atribua a contagem deste campo à contagem deste segundo campo.
  Atribua o novo nome deste campo ao novo nome deste segundo campo.
  Atribua o sinalizador de referência deste campo ao sinalizador de referência deste segundo campo.
  Atribua o deslocamento deste campo ao deslocamento deste segundo campo.

Função para que se determine se uma variável está duplicado em umas variáveis;
Função para que se determine se uma variável está duplicada em umas variáveis:
  [Itere.]
    Obtenha uma segunda variável desde as variáveis.
    Se a segunda variável for inexistente, diga não.
    Se o nome desta segunda variável estiver em branco, reitere.
    Se a segunda variável for a variável, reitere.
    Se o nome desta segunda variável for o nome desta variável, diga sim.
  Reitere.

Rotina para que se destrinche um campo:
  Se existir algum problema de compilação, retorne.
  Se o campo for inexistente, retorne.
  Destrinche o campo como uma variável.
  Se o apelido deste campo não for algum nome de campo válido, 
    Limpe o apelido deste campo. \it
  Se o nome deste campo não for algum nome de campo válido,
    Apresente uma mensagem de erro contendo "Erro #043. O identificador '" 
    junto com o nome deste campo seguido de "' não corresponde a um nome de campo válido." e o endereço local deste campo;
    Retorne.

Rotina para que se destrinche uma variável:
  Se existir algum problema de compilação, retorne.
  Se a variável for inexistente, retorne.
  Se o tipo desta variável não for inexistente, retorne. \ tipo já foi definido
  Se o nome do tipo desta variável não estiver em branco,
    Destrinche a variável (usando o nome do tipo declarado);
    Retorne.
  Encontre o tipo desta variável e o apelido desta variável usando o nome desta variável.
  Se o tipo desta variável não for inexistente,
    Atribua o nome deste tipo desta variável ao nome do tipo desta variável;
    Retorne.
  [Se o tipo desta variável for inexistente,]
  Apresente uma mensagem de erro contendo "Erro #044. Não foi possível determinar o tipo da variável '" 
  junto com o nome desta variável seguido de "'." e o endereço local desta variável.

Rotina para que se destrinche uma variável (usando o nome do tipo declarado):
  Encontre o tipo desta variável usando o nome do tipo desta variável e o catálogo de tipos.
  Se o tipo desta variável for inexistente,
    Apresente uma mensagem de erro contendo "Erro #045. Não foi possível encontrar o tipo da variável '" 
    junto com o nome do tipo desta variável seguido de "' no catálogo de tipos." e o endereço local desta variável;
    Retorne.

Rotina para que se encontre um tipo e um apelido usando um nome:
  Esvazie o tipo.
  Limpe o apelido.
  Encontre o tipo e o apelido usando o nome (progressivamente).
  Se o tipo não for inexistente, retorne.
  Encontre o tipo e o apelido usando o nome (regressivamente).
  \ TRECHO DA VERSÃO ANTIGA
  \ Lance um subtexto sobre o nome.
  \ Itere.
    \ Se o subtexto estiver em branco, retorne.
    \ Encontre o tipo usando o subtexto e o catálogo de tipos.
    \ Se o tipo não for inexistente, pare.
    \ Passe para a próxima palavra  no subtexto.
  \ Reitere.
  \ Atribua o caractere inicial deste nome para caractere inicial deste segundo subtexto. \ está errado
  \ Atribua o caractere inicial deste subtexto menos 2 ao caractere final deste segundo subtexto.
  \ Se o segundo subtexto não estiver em branco, atribua o segundo subtexto ao apelido.
  \ Se o segundo subtexto estiver em branco, atribua o subtexto ao apelido.

Rotina para que se encontre um tipo e um apelido usando um nome (progressivamente):
  \ original - sem alterações
  Esvazie o tipo.
  Limpe o apelido.
  Lance um subtexto sobre o nome.
  Itere.
    Se o subtexto estiver em branco, retorne.
    Encontre o tipo usando o subtexto e o catálogo de tipos.
    Se o tipo não for inexistente, pare. \ Se encontrar o tipo, pare.
    Passe para a próxima palavra  no subtexto. \próximo tipo
  Reitere.
  Atribua o caractere inicial deste nome para o caractere inicial dum segundo subtexto.
  Atribua o caractere inicial deste subtexto menos 2 ao caractere final deste segundo subtexto.
  Se o segundo subtexto não estiver em branco, 
    Atribua o segundo subtexto ao apelido.
  Se o segundo subtexto estiver em branco, 
    Atribua o subtexto ao apelido.

Rotina para que se passe para a próxima palavra  em um subtexto:
  [Itere.]
    Se o subtexto estiver em branco, retorne.
    Se o conteúdo deste caractere inicial deste subtexto for irrelevante, pare.
    Adicione 1 para o caractere inicial deste subtexto.
  Reitere.
  Ignore os caracteres ignoráveis no início no subtexto.

Rotina para que se encontre um tipo e um apelido usando um nome (regressivamente):
  Esvazie o tipo.
  Limpe o apelido.
  Lance um subtexto sobre o nome.
  Itere.
    Se o subtexto estiver em branco, retorne.
    Encontre o tipo usando o subtexto e o catálogo de tipos.
    Se o tipo não for inexistente, pare.
    Passe para a palavra anterior no subtexto.
  Reitere.
  Atribua o caractere final deste nome para o caractere final dum segundo subtexto.
  Atribua o caractere final deste subtexto mais 2 ao caractere inicial deste segundo subtexto.
  Se o segundo subtexto não estiver em branco, 
    Atribua o segundo subtexto ao apelido.
  Se o segundo subtexto estiver em branco, 
    Atribua o subtexto ao apelido.

Rotina para que se passe para a palavra anterior em um subtexto:
  [Itere.]
    Se o subtexto estiver em branco, retorne.
    Se o conteúdo deste caractere final deste subtexto for irrelevante, pare.
    Subtraia 1 desde o caractere final deste subtexto.
  Reitere.
  Ignore algum caractere ignorável final no subtexto.

Rotina para que se ignore algum caractere ignorável final em um subtexto:
  Itere.
    Se o subtexto estiver em branco, retorne.
    Se o conteúdo deste caractere final deste subtexto não for irrelevante, retorne.
    Subtraia 1 desde o caractere final deste subtexto.
  Reitere.

Função para que se determine se um nome é algum nome de campo válido:
  Se o nome for alguma palavra-chave de obtenção de tamanho de variável, diga não.
  Se o nome for algum conteúdo, diga não.
  Se o nome for algum endereçamento, diga não.
  Diga sim.

Função para que se determine se um nome é alguma palavra-chave de obtenção de tamanho de variável:
  Se o nome for "magnitude", diga sim.  \ A "magnitude" retorna o tamanho em bytes de algo
  \Se o nome for "grandeza", diga sim.
  \Se o nome for " grandiosidade", diga sim.
  \Se o nome for " envergadura", diga sim.
  \ Exemplo: a magnitude duma string
  Diga não.

Função para que se determine se um nome é algum conteúdo:
  Se o nome for "conteúdo", diga sim.
  \Este comando é usado apenas com ponteiros (endereços de memória).
  \ Serve pra saber para quais valores o ponteiro está apontando, ou seja, o conteúdo do ponteiro .
  \"Um endereço de byte" ou "O ponteiro do byte", por exemplo, refere-se ao endereço de um byte.
  \"O conteúdo deste endereço de byte" refere-se, portanto aos dados no contidos no byte
  Diga não.

Função para que se determine se um nome é algum endereçamento:
  Se o nome for "endereçamento", diga sim.  \ retorna o endereço do dado
  Diga não.

Rotina para que se destrinche um tipo (dados opcionais - scale):
  Se existir algum problema de compilação, retorne.
  Atribua o tipo base deste tipo para um tipo base.
  Se a razão de escala deste tipo for 0,
    Atribua a razão de escala deste tipo base deste tipo à razão de escala deste tipo;
    Retorne.
  Se a razão de escala deste tipo base for 0, retorne.
  Multiplique a razão de escala deste tipo pela razão de escala deste tipo base.
  Atribua o tipo base deste tipo base ao tipo base deste tipo.

Rotina para que se compile um endereço da pasta (identificação de variáveis globais): \ Etapa #005
  Se existir algum problema de compilação, retorne.
  Escreva "Identificando variáveis globais..." junto com o texto CRLF para StdOut.
  Comece o temporizador de resolução de variáveis globais.
  Destrinche as variáveis globais.
  Suspenda o temporizador de resolução de variáveis globais.

Rotina para que se destrinche umas variáveis globais:
  [Itere.]
    Se existir algum problema de compilação, retorne.
    Obtenha uma variável global desde as variáveis globais.
    Se a variável global for inexistente, retorne.
    Destrinche a variável global.
  Reitere.

Rotina para que se destrinche uma variável global:
  Se a variável global for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Se o corpo de variável global desta variável global não estiver em branco, 
    Destrinche a variável global (compile corpo).
  Se o nome do tipo desta variável global estiver em branco,
    Apresente uma mensagem de erro contendo "Erro #046. O identificador '" 
    junto com o nome desta variável global 
    seguido de "' possui um tipo inválido (o nome do tipo está em branco)." e o endereço local desta variável global;
    Retorne.
  Destrinche a variável global como uma variável.

Rotina para que se destrinche uma variável global (compile corpo):
  Se a variável global for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Lance um percorredor sobre o corpo de variável global desta variável global.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum valor literal,
    Apresente uma mensagem de erro contendo "Erro #047. É necessário que o identificador '" 
    junto com o segmento inicial deste percorredor seguido de "' seja algum valor literal." e o percorredor;
    Retorne.
  Compile um valor literal usando o percorredor. \ 
  Se existir algum problema de compilação, retorne.
  Se o segmento inicial deste percorredor não estiver em branco,
    Apresente a mensagem de erro contendo "Erro #048. Esperado '.' " e o percorredor;
    Retorne.
  Se o nome do tipo desta variável global estiver em branco, 
    Atribua o nome deste tipo deste valor literal ao nome do tipo desta variável global.
  Atribua o valor literal ao valor literal desta variável global.
  Catalogue o valor literal. \ 

Rotina para que se compile um valor literal usando um percorredor:
  Se existir algum problema de compilação, retorne.
  Adicione o valor literal para os valores literais usando o caractere inicial deste segmento inicial deste percorredor .
  \Se o segmento inicial deste percorredor for algum sinalizador literal, compile o valor literal usando o percorredor (valores booleanos); Retorne.
  \Se o segmento inicial deste percorredor for algum número ordinal,
    \Compile o valor literal usando o percorredor (números ordinais);
    \Retorne.
  Se o segmento inicial deste percorredor for algum valor hexadecimal literal,
    Compile o valor literal usando o percorredor (valores hexadecimais);
    Retorne.
  Se o segmento inicial deste percorredor for algum valor numérico literal,
    Compile o valor literal usando o percorredor (valor numérico - análise preliminar);
    Retorne.
  Se o segmento inicial deste percorredor for algum ponteiro literal,
    Compile o valor literal usando o percorredor (ponteiros);
    Retorne.
  Se o segmento inicial deste percorredor for algum string literal,
    Compile o valor literal usando o percorredor (cadeia de caracteres);
    Retorne.
  Apresente uma mensagem de erro contendo "Erro interno #44. O identificador '" 
  junto com o segmento inicial deste percorredor  seguido de "' não pode ser compilado." e o percorredor.

Rotina para que se adicione um valor literal para umas variáveis usando um endereço local:
  Adicione o valor literal como uma variável para as variáveis usando "literal" e o endereço local.
  Gere o nome deste valor literal usando "~L".

Rotina para que se gere um nome usando uma string:
  Atribua a string ao nome.
  Adicione 1 para a contagem de nomes deste compilador.
  Converta a contagem de nomes deste compilador para uma segunda string.
  Acrescente a segunda string para o nome.

Função para que se determine se uma string é algum valor hexadecimal literal:
  Se a string estiver em branco, diga não.
  Se o conteúdo deste caractere inicial desta string for o cifrão, diga sim.
  Diga não.

Rotina para que se compile um valor literal usando um percorredor (valores hexadecimais):
  Se existir algum problema de compilação, retorne.
  Atribua o segmento inicial deste percorredor para um parte da cifra binária.
  Adicione 1 para o caractere inicial desta parte da cifra binária.
  Converta a parte da cifra binária para o data deste valor literal.
  Mova o percorredor (usando diretrizes de compilação).
  Atribua "texto hexadecimal" ao nome do tipo deste valor literal.
  Destrinche o valor literal.

\Rotina para que se converta uma parte da cifra binária para uma string:
  \Empregue converta uma cifra hexadecimal para um texto hexadecimal.

Rotina para que se compile um valor literal usando um percorredor (valor numérico - análise preliminar):
  Se existir algum problema de compilação, retorne.
  Se o percorredor estiver acompanhado por algum unidade de medida,
    Compile o valor literal usando o percorredor (valor numérico - unidade de medida);
    Retorne.
  Se o segmento inicial deste percorredor for algum número inteiro,
    Compile o valor literal usando o percorredor (valor numérico - números inteiros);
    Retorne.
  Se o segmento inicial deste percorredor for algum proporção literal,
    Compile o valor literal usando o percorredor (valor numérico - números fracionários);
    Retorne.
  Se o segmento inicial deste percorredor for algum numeral misto literal,
    Compile o valor literal usando o percorredor (valor numérico - números fracionários);
    Retorne.

Função para que se determine se um percorredor está acompanhado por algum unidade de medida:
  Preserve o percorredor.
  Mova o percorredor (usando diretrizes de compilação).
  Se o percorredor não estiver sobre algum indicador de início de variável, diga não.
  Examine um nome usando o percorredor.
  Encontre um tipo usando o nome e o catálogo de tipos.
  Se o tipo for inexistente, diga não.
  Se o nome não for algum operador de multiplicação, diga sim.
  \Se o nome não for "vezes", diga sim. \ necessário porque o termo 'vezes' é um operador de multiplicação e uma unidade de medida
  Se o segmento inicial deste percorredor for o início de alguma expressão matemática, diga não.
  Diga sim.

Função para que se determine se uma string é algum operador de multiplicação:
  Se a string for "vezes", diga sim.
  Diga não.

Função para que se determine se uma string é o início de alguma expressão matemática:
  Se a string for algum sinal aritmético, diga sim.
  Se a string for algum artigo indefinido, diga sim.
  Se a string for algum artigo definido, diga sim.
  Se a string for algum valor literal, diga sim.
  Diga não.

Rotina para que se compile um valor literal usando um percorredor (valor numérico - unidade de medida):
  Se existir algum problema de compilação, retorne.
  Converta o segmento inicial deste percorredor para uma proporção.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Encontre um tipo usando o nome e o catálogo de tipos.
  Se o tipo for inexistente,
    Apresente uma mensagem de erro contendo "Erro #049. O identificador '" 
    junto com o nome seguido de "' corresponde a uma unidade de medida inexistente." e o endereço local deste valor literal;
    Retorne.
  Se o tipo não puder ser reduzido para "número",
    Apresente a mensagem de erro contendo "Erro #050. O identificador '" 
    junto com o nome seguido de "'  corresponde a um tipo de dado não numérico." e o endereço local deste valor literal;
    Retorne.
  Atribua a razão de escala deste tipo para uma proporção denominada final proporção. \ TRADUZIR
  Se a razão de escala deste tipo for 0, 
    Atribua 1/1 para a final proporção.
  Multiplique a final proporção pelo proporção.
  Reduza a final proporção.
  Se o denominador deste final proporção for 0,
    Apresente a mensagem de erro contendo "Erro #051. Proporção inválida. Denominador igual a zero." e o endereço local deste valor literal.
  Atribua o numerador deste final proporção dividido pelo denominador deste final proporção para um número.
  Atribua o nome deste tipo ao nome do tipo deste valor literal.
  Converta o número para o data deste valor literal.
  Destrinche o valor literal.

Rotina para que se compile um valor literal usando um percorredor (valor numérico - números inteiros):
  Se existir algum problema de compilação, retorne.
  Converta o segmento inicial deste percorredor para um número.
  Converta o número para os data deste valor literal.
  Mova o percorredor (usando diretrizes de compilação).
  Atribua "número" ao nome do tipo deste valor literal.
  Destrinche o valor literal.

Rotina para que se compile um valor literal usando um percorredor (valor numérico - números fracionários):
  Se existir algum problema de compilação, retorne.
  Converta o segmento inicial deste percorredor para uma proporção.
  Converta a proporção para o data deste valor literal.
  Mova o percorredor (usando diretrizes de compilação).
  Atribua "proporção" ao nome do tipo deste valor literal.
  Destrinche o valor literal.

Função para que se determine se uma string é algum ponteiro literal:
  Se a string for "nulo", diga sim.
  Se a string for "nula", diga sim.
  Se a string for "nulos", diga sim.
  Se a string for "nulas", diga sim.
  Se a string for "inexistente", diga sim.
  Se a string for "inexistentes", diga sim.
  Se a string for "zerado", diga sim.
  \CAL
  Se a string for "nil", diga sim.
  Diga não.

Rotina para que se compile um valor literal usando um percorredor (ponteiros):
  Se existir algum problema de compilação, retorne.
  Converta 0 para os data deste valor literal. \ era nulo ao invés de 0
  Mova o percorredor (usando diretrizes de compilação).
  Atribua "ponteiro" ao nome do tipo deste valor literal.
  Destrinche o valor literal.

Rotina para que se compile um valor literal usando um percorredor (cadeia de caracteres):
  Se existir algum problema de compilação, retorne.
  Atribua o segmento inicial deste percorredor aos data deste valor literal.
  Remova as aspas de os data deste valor literal.
  Mova o percorredor (usando diretrizes de compilação).
  Atribua "string" ao nome do tipo deste valor literal.
  \Atribua "texto" ao nome do tipo deste valor literal.
  Destrinche o valor literal.

Rotina para que se catalogue um valor literal:
  Se existir algum problema de compilação, retorne.
  Se o valor literal for inexistente, retorne.
  Se o nome deste valor literal estiver no catálogo de variáveis hexadecimais,
    Apresente uma mensagem de erro contendo "Erro interno #124. O nome deste valor literal já foi catalogado anteriormente" 
    e o endereço local deste valor literal;
    Retorne.
  Catalogue o valor literal usando o nome deste valor literal e o catálogo de variáveis hexadecimais.

Rotina para que se compile um endereço da pasta (cabeçalhos de rotinas): \ Etapa #006
  Se existir algum problema de compilação, retorne.
  Escreva "Agrupando os nomes das rotinas..." junto com o texto CRLF para StdOut.
  Comece o temporizador de compilação de cabeçalhos de rotina.
  Compile os cabeçalhos pertencentes às rotinas.
  Suspenda o temporizador de compilação de cabeçalhos de rotina.

Rotina para que se compile os cabeçalhos pertencentes para umas rotinas:
  [Itere.]
    Se existir algum problema de compilação, retorne.
    Obtenha uma rotina desde as rotinas.
    Se a rotina for inexistente, retorne.
    Compile o cabeçalho pertencente à rotina.
  Reitere.

Rotina para que se compile o cabeçalho pertencente para uma rotina:
  Se a rotina for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Lance um percorredor sobre a cabeçalho de rotina desta rotina.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for algum comando de deliberação,
    Compile o cabeçalho pertencente à rotina usando o percorredor (rotina deliberativa);
    Retorne.
  Se o percorredor for o início de alguma função possessiva reversa,
    Compile o cabeçalho pertencente à rotina usando o percorredor (função do possessivo reverso);
    Retorne.
  Se o percorredor for o início de alguma função,
    Compile o cabeçalho pertencente à rotina usando o percorredor (função);
    Retorne.
  Se o segmento inicial deste percorredor for "compativelmente",
    Compile o cabeçalho pertencente à rotina usando o percorredor (modo de compatibilidade);
    Retorne.
  [else]
  Compile o cabeçalho pertencente à rotina usando o percorredor (procedimento).

Função para que se determine se uma string é algum comando de deliberação:
  Se a string for "decida", diga sim.
  Se a string for "determine", diga sim.
  Se a string for "esclareça", diga sim.
  Diga não.

Rotina para que se compile o cabeçalho pertencente para uma rotina usando um percorredor (rotina deliberativa):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum comando condicional,
    Apresente uma mensagem de erro contendo "Erro #052. Sintaxe inválida na 'Função para que se determine se' " e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Ative o sinalizador de deliberação desta rotina.
  Compile as unidades semânticas desta rotina e os parâmetros desta rotina usando o percorredor. \ 
  Se algumas dentre as unidades semânticas desta rotina forem advérbios de negação,
    Apresente a mensagem de erro contendo "Erro #053. A palavra-chave 'não' não é permitida em cabeçalhos de funções booleanas." e o percorredor;
    Retorne.
  Converta as unidades semânticas desta rotina para a representação interna da rotina desta rotina.
  Se a representação interna da rotina desta rotina estiver no catálogo geral de rotinas,
    Apresente a mensagem de erro contendo "Erro #054. A 'Rotina para que se '" 
    junto com a representação interna da rotina desta rotina seguido de "' já foi definida anteriormente." e o endereço local desta rotina;
    Retorne.
  Catalogue a rotina usando as unidades semânticas desta rotina e o catálogo geral de rotinas.

Função para que se determine se uma string é algum comando condicional:
  Se a string for "se", diga sim.
  Se a string for "quando", diga sim.
  Diga não.

Rotina para que se compile umas unidades semânticas e uns parâmetros usando um percorredor:
  Se existir algum problema de compilação, retorne.
  Se o segmento inicial deste percorredor estiver em branco, retorne.
  Se o segmento inicial deste percorredor for algum artigo definido,
    Compile as unidades semânticas e o parâmetros usando o percorredor (artigo definido); \ 
    Reitere.
  Se o percorredor estiver sobre algum artigo indefinido,
    Compile as unidades semânticas e o parâmetros usando o percorredor (artigo indefinido);
    Reitere.
  Se o percorredor estiver sobre alguma unidade semântica relevante,
    Compile as unidades semânticas e o parâmetros usando o percorredor (string de unidade semântica);
    Reitere.
  Apresente uma mensagem de erro contendo "Erro #055. A 'Rotina para que se " 
  junto com o segmento inicial deste percorredor seguido de " ainda não foi declarada neste projeto." e o percorredor.

Rotina para que se compile umas unidades semânticas e uns parâmetros usando um percorredor (artigo definido):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Se existir algum problema de compilação, retorne.
  Anteponha "O " para o nome.
  Adicione uma unidade semântica para as unidades semânticas usando o nome.

 \ Unifica o sentido de diferentes termos usados em proposições, verbos e conjunções.
Rotina para que se adicione uma unidade semântica para umas unidades semânticas usando uma string: \ creio que isso aqui ajude nas funções
  Crie a unidade semântica.
  Acrescente a unidade semântica para as unidades semânticas.
  \\ conjunções
  Se a string for "e",
    Atribua "e" à string desta unidade semântica;
    Retorne. \ and
  Se a string for "ou",
    Atribua "ou" à string desta unidade semântica;
    Retorne. \ or
  \ usando
  Se a string for "desde",
    Atribua "usando" à string desta unidade semântica;
    Retorne.
  \Se a string for "de", atribua "usando" à string desta unidade semântica; Retorne.
  Se a string for "dada",
    Atribua "usando" à string desta unidade semântica;
    Retorne.
  Se a string for "dado",
    Atribua "usando" à string desta unidade semântica;
    Retorne.
  Se a string for "dadas",
    Atribua "usando" à string desta unidade semântica;
    Retorne.
  Se a string for "dados",
    Atribua "usando" à string desta unidade semântica;
    Retorne.
  Se a string for "com",
    Atribua "usando" à string desta unidade semântica;
    Retorne.
  Se a string for "usando",
    Atribua "usando" à string desta unidade semântica;
    Retorne.
  Se a string for "contendo",
    Atribua "usando" à string desta unidade semântica;
    Retorne.
  Se a string for "dizendo",
    Atribua "usando" à string desta unidade semântica;
    Retorne.
  \\ para
  Se a string for "em", 
    Atribua "para" à string desta unidade semântica; 
    Retorne.
  Se a string for "a",
    Atribua "para" à string desta unidade semântica;
    Retorne. \  ver isso aqui com calma
  Se a string for "para",
    Atribua "para" à string desta unidade semântica;
    Retorne.
  \\ VERBO SER/ESTAR
  Se a string for "é",
    Atribua "é" à string desta unidade semântica;
    Retorne.
  Se a string for "está",
    Atribua "é" à string desta unidade semântica;
    Retorne.
  Se a string for "for",
    Atribua "é" à string desta unidade semântica;
    Retorne.
  Se a string for "foi",
    Atribua "é" à string desta unidade semântica;
    Retorne.
  Se a string for "foram",
    Atribua "é" à string desta unidade semântica;
    Retorne.
  Se a string for "forem",
    Atribua "é" à string desta unidade semântica;
    Retorne.
  Se a string for "estiver",
    Atribua "é" à string desta unidade semântica;
    Retorne.
  Se a string for "estiverem",
    Atribua "é" à string desta unidade semântica;
    Retorne.
  Se a string for "estamos",
    Atribua "é" à string desta unidade semântica;
    Retorne.
  Se a string for "há",
    Atribua "há" à string desta unidade semântica;
    Retorne.
  Se a string for "houver",
    Atribua "há" à string desta unidade semântica;
    Retorne.
  Se a string for "seja",
    Atribua "é" à string desta unidade semântica;
    Retorne.
  Se a string for "sejam",
    Atribua "é" à string desta unidade semântica;
    Retorne.
  \Se a string for "tem", atribua "tem" à string desta unidade semântica; Retorne.
  \Se a string for "tiver", atribua "tem" à string desta unidade semântica; Retorne.
  Se a string for "são",
    Atribua "é" à string desta unidade semântica;
    Retorne.
  Se a string for "estão",
    Atribua "é" à string desta unidade semântica;
    Retorne.
  Se a string for "forem",
    Atribua "é" à string desta unidade semântica;
    Retorne.
  Se a string for "estiverem",
    Atribua "é" à string desta unidade semântica;
    Retorne.
  Se a string for "puder",
    Atribua "pode" à string desta unidade semântica;
    Retorne.
  Se a string for "puderem",
    Atribua "pode" à string desta unidade semântica;
    Retorne.
  Se a string for "existe",
    Atribua "existe" à string desta unidade semântica;
    Retorne.
  Se a string for "existir",
    Atribua "existe" à string desta unidade semântica;
    Retorne.
  Se a string for "há",
    Atribua "há" à string desta unidade semântica;
    Retorne.
  Se a string for "houver",
    Atribua "há" à string desta unidade semântica;
    Retorne.
  Se a string for "possuir",
    Atribua "possui" à string desta unidade semântica;
    Retorne.
  \\ allocates e destroys
  \Se a string for "aloque", atribua "allocate" à string desta unidade semântica; Retorne.
  Se a string for "pelo",
    Atribua "por o" à string desta unidade semântica;
    Retorne.
  Se a string for "pela",
    Atribua "por o" à string desta unidade semântica;
    Retorne.
  \Se a string for "desaloque", atribua "desaloque" à string desta unidade semântica; Retorne.
  \Se a string for "esvazie", atribua "deallocate" à string desta unidade semântica; Retorne.
  \Se a string for "destrua", atribua "destrua" à string desta unidade semântica; Retorne.
  \ é
  Se a string for "is",
    Atribua "é" à string desta unidade semântica;
    Retorne.
  \ sobre
  Se a string for "sob",
    Atribua "sobre" à string desta unidade semântica;
    Retorne.
  Se a string for "sobre",
    Atribua "sobre" à string desta unidade semântica;
    Retorne.
  Se a string for "começa",
    Atribua "começa" à string desta unidade semântica;
    Retorne.
  Se a string for "começar",
    Atribua "começa" à string desta unidade semântica;
    Retorne.
  Se a string for "termina",
    Atribua "termina" à string desta unidade semântica;
    Retorne.
  Se a string for "terminar",
    Atribua "termina" à string desta unidade semântica;
    Retorne.
  Se a string for "cabe",
    Atribua "cabe" à string desta unidade semântica;
    Retorne.
  Se a string for "couber",
    Atribua "cabe" à string desta unidade semântica;
    Retorne.
  Se a string for "sobre",
    Atribua "sobre" à string desta unidade semântica;
    Retorne.
  \ other
  Atribua a string à string desta unidade semântica.

Rotina para que se compile umas unidades semânticas e uns parâmetros usando um percorredor (artigo indefinido):
  Se existir algum problema de compilação, retorne.
  Adicione um parâmetro para os parâmetros usando "parâmetro" e o caractere inicial deste segmento inicial deste percorredor.
  \PAL
  \Se o segmento inicial deste percorredor for "outra", 
    \Atribua "outra" ao nome deste parâmetro.
  \Se o segmento inicial deste percorredor for "outras", 
    \Atribua "outras" ao nome deste parâmetro.
  \Se o segmento inicial deste percorredor for "outro", 
    \Atribua "outro" ao nome deste parâmetro.
  \Se o segmento inicial deste percorredor for "outros", 
    \Atribua "outros" ao nome deste parâmetro.
  \Se o segmento inicial deste percorredor for "segundo", 
    \Atribua "segundo" ao nome deste parâmetro.
  \Se o segmento inicial deste percorredor for "segunda", 
    \Atribua "segunda" ao nome deste parâmetro.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Expanda o nome deste parâmetro com o nome.
  Se o segmento inicial deste percorredor for uma palavra-chave de designação, 
    Compile a parte designadora usando o percorredor e o parâmetro.
  Destrinche o parâmetro.
  Se o parâmetro estiver duplicado nos parâmetros,
    Apresente uma mensagem de erro contendo "Erro #056. O identificador '" 
    junto com o nome deste parâmetro seguido de "' corresponde a um parâmetro já declarado anteriormente." e o endereço local deste parâmetro;
    Retorne.
  Adicione uma unidade semântica para as unidades semânticas usando o tipo deste parâmetro.

Rotina para que se compile a parte designadora usando um percorredor e uma variável:
  Se existir algum problema de compilação, retorne.
  Se a variável for inexistente, retorne.
  Atribua o nome desta variável ao nome do tipo desta variável.
  Mova o percorredor (usando diretrizes de compilação).
  Examine o nome desta variável usando o percorredor.

Rotina para que se adicione uma unidade semântica para umas unidades semânticas usando um tipo:
  Crie a unidade semântica.
  Acrescente a unidade semântica para as unidades semânticas.
  Atribua o tipo ao tipo desta unidade semântica.

Rotina para que se compile umas unidades semânticas e uns parâmetros usando um percorredor (string de unidade semântica):
  Se existir algum problema de compilação, retorne.
  Adicione uma unidade semântica para as unidades semânticas usando o segmento inicial deste percorredor.
  Mova o percorredor (usando diretrizes de compilação).

\ Rotina nova criada pelo Dahn para - funções de atribuição do possessivo reverso
\ Exemplo: Para que se atribua o X deste Y para o |
\ O compilador converte isso para "Para que se atribua o Y's X para o Z"
Rotina para que se compile o cabeçalho pertencente para uma rotina usando um percorredor (função do possessivo reverso):
  Se existir algum problema de compilação, retorne.
  Ative o sinalizador de função desta rotina.
  Adicione uma unidade semântica para as unidades semânticas desta rotina usando "Atribua".
  Mova o percorredor (usando diretrizes de compilação). \ ignora o "Atribua"
  Mova o percorredor (usando diretrizes de compilação). \ ignora "O" / "A" / "Os" / "As"
  Examine um nome usando o percorredor. \ Analisa o nome do campo da estrutura
  Mova o percorredor (usando diretrizes de compilação). \ ignora o "deste" / "desta" / "destes" / "destas"
  Se o segmento inicial deste percorredor for algum artigo indefinido, 
    \Ative um sinalizador.
  \Se o sinalizador estiver ativo, 
    Compile as unidades semânticas desta rotina e o parâmetros desta rotina usando o percorredor (artigo indefinido).
  \Se o sinalizador não estiver ativo, 
  Se o segmento inicial deste percorredor for algum artigo definido, \ NOVO
    Compile as unidades semânticas desta rotina e o parâmetros desta rotina usando o percorredor (artigo definido).
  Adicione uma segunda unidade semântica para as unidades semânticas desta rotina usando "'s " junto com o nome.
  Se o segmento inicial deste percorredor não for alguma função possessiva reversa into,
    Apresente uma mensagem de erro contendo "Erro #057. Erro de sintaxe. O compilador esperava encontrar um 'para' ou um 'em'. Termo encontrado: '" 
    junto com o segmento inicial deste percorredor seguido de "'." e o percorredor;
    Retorne.
  Adicione uma terceira unidade semântica para as unidades semânticas desta rotina usando "para".
  Converta as unidades semânticas desta rotina para uma representação interna da rotina.
  Se a representação interna da rotina estiver no catálogo geral de rotinas,
    Apresente a mensagem de erro contendo "Erro #058. Erro. A 'Rotina para que se " 
    junto com a representação interna da rotina seguido de "' já foi definida anteriormente." e o endereço local desta rotina;
    Retorne.
  Catalogue a rotina usando as unidades semânticas desta rotina e o catálogo geral de rotinas.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum artigo indefinido,
    Apresente a mensagem de erro contendo "Erro #059. Erro. Esperado 'um/uma'. Encontrado: '" 
    junto com o segmento inicial deste percorredor seguido de "'." e o percorredor;
    Retorne.
  Compile as unidades semânticas desta rotina e o parâmetros desta rotina usando o percorredor (artigo indefinido).
  Se o segmento inicial deste percorredor não estiver em branco,
    Apresente a mensagem de erro contendo "Erro #060. Comandos inválidos no final desta rotina." e o percorredor;
    Retorne.
  Converta as unidades semânticas desta rotina para a representação interna da rotina desta rotina.
  Catalogue a rotina usando as unidades semânticas desta rotina e o catálogo geral de rotinas. \ Para uso nos employs

Função para que se determine se uma string é alguma função possessiva reversa into:
  Se a string for "em", diga sim.
  Se a string for "para", diga sim.
  Diga não.

Função para que se determine se uma representação interna da rotina está em um catálogo:
  Encontre um referência usando a representação interna da rotina e o catálogo.
  Se o referência for inexistente, diga não.
  Se o ponteiro deste referência for inexistente, diga não.
  Diga sim.

Rotina para que se catalogue uma rotina usando umas unidades semânticas e um catálogo:
  Se a rotina for inexistente, retorne.
  Limpe um cabeçalho compactado.
  Itere.
    Obtenha uma unidade semântica desde as unidades semânticas.
    Se a unidade semântica for inexistente, retorne.
    Acrescente a unidade semântica para o cabeçalho compactado.
    Se a unidade semântica for a última unidade semântica destas unidades semânticas, pare.
    Catalogue o cabeçalho compactado usando o catálogo (especial).
  Reitere.
  Catalogue a rotina usando o cabeçalho compactado como uma representação interna da rotina e o catálogo (especial).

Rotina para que se catalogue um cabeçalho compactado usando um catálogo (especial):
  Encontre uma referência usando o cabeçalho compactado e o catálogo.
  Se a referência não for inexistente, retorne.
  Catalogue o cabeçalho compactado no catálogo.

Rotina para que se catalogue uma rotina usando uma representação interna da rotina e um catálogo (especial):
  Encontre uma referência usando a representação interna da rotina e o catálogo.
  Se a referência não for inexistente,
    Atribua a rotina ao ponteiro desta referência;
    Retorne.
  Catalogue a rotina usando a representação interna da rotina e o catálogo.

Rotina para que se converta umas unidades semânticas para uma representação interna da rotina:
  Converta as unidades semânticas para a representação interna da rotina usando a última unidade semântica destas unidades semânticas.

Rotina para que se converta umas unidades semânticas para uma representação interna da rotina usando uma unidade semântica:
  Limpe a representação interna da rotina.
  Itere.
    Obtenha uma unidade semântica denominada unidade semântica atual desde as unidades semânticas.
    Se a unidade semântica atual for inexistente, retorne.
    Acrescente a unidade semântica atual para a representação interna da rotina.
    Se a unidade semântica atual for a unidade semântica, retorne.
  Reitere.

Rotina para que se compile o cabeçalho pertencente para uma rotina usando um percorredor (função): \ POSSESSIVO REVERSO
  Se existir algum problema de compilação, retorne.
  Ative o sinalizador de função desta rotina.
  Adicione uma unidade semântica para as unidades semânticas desta rotina usando "Atribua".
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for algum artigo indefinido, 
    \Ative um sinalizador.
  \Se o sinalizador estiver ativo, 
    Compile as unidades semânticas desta rotina e os parâmetros desta rotina usando o percorredor (artigo indefinido).
  Se o segmento inicial deste percorredor for algum artigo definido, 
    Compile as unidades semânticas desta rotina e os parâmetros desta rotina usando o percorredor (artigo definido).
  Se o segmento inicial deste percorredor não for algum possessivo inglês,
    Apresente uma mensagem de erro contendo "Erro #061. Possessivos requerem um  's após o nome da estrutura." e o percorredor;
    Retorne. \ 
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Adicione uma segunda unidade semântica para as unidades semânticas desta rotina usando "'s " junto com o nome.
  Se o segmento inicial deste percorredor não for "para",
    Apresente a mensagem de erro contendo "Erro #062. Palavra-chave 'para' ausente. Encontrado o termo: " 
    junto com o segmento inicial deste percorredor seguido de "." e o percorredor;
    Retorne. \ 
  Adicione uma terceira unidade semântica para as unidades semânticas desta rotina usando "para".
  Converta as unidades semânticas desta rotina para uma representação interna da rotina.
  Se a representação interna da rotina estiver no catálogo geral de rotinas,
    Apresente a mensagem de erro contendo "Erro #063. A 'Rotina para que se '" 
    junto com a representação interna da rotina seguido de "' já foi definida." e o endereço local desta rotina;
    Retorne. \ 
  Catalogue a rotina usando as unidades semânticas desta rotina e o catálogo geral de rotinas.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum artigo indefinido,
    Apresente a mensagem de erro contendo "Erro #064. Sintaxe esperada: 'Atribua a estrutura's membro para UM/UMA identificador. Encontrado '" 
    junto com o segmento inicial deste percorredor seguido de "'." e o percorredor;
    Retorne. 
  Compile as unidades semânticas desta rotina e os parâmetros desta rotina usando o percorredor (artigo indefinido).
  Se o segmento inicial deste percorredor não estiver em branco,
    Apresente a mensagem de erro contendo "Erro #065. Encontrado termo inválido após 'Atribua a estrutura's membro para UM/UMA identificador." e o percorredor;
    Retorne. 
  Converta as unidades semânticas desta rotina para a representação interna da rotina desta rotina.
  Catalogue a rotina usando as unidades semânticas desta rotina e o catálogo geral de rotinas. \ para uso nos employs

Rotina para que se compile o cabeçalho pertencente para uma rotina usando um percorredor (modo de compatibilidade): \ callback
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Ative o sinalizador de compatibilidade desta rotina.
  Compile as unidades semânticas desta rotina e os parâmetros desta rotina usando o percorredor.
  Converta as unidades semânticas desta rotina para a representação interna da rotina desta rotina.
  Se a representação interna da rotina desta rotina estiver no catálogo geral de rotinas,
    Apresente uma mensagem de erro contendo "Erro #066. A 'Rotina para que se " 
    junto com a representação interna da rotina desta rotina seguido de "' já foi definida anteriormente." 
    e o endereço local desta rotina;
    Retorne.
  Catalogue a rotina usando as unidades semânticas desta rotina e o catálogo geral de rotinas.

Rotina para que se compile o cabeçalho pertencente para uma rotina usando um percorredor (procedimento):
  Se existir algum problema de compilação, retorne.
  Compile as unidades semânticas desta rotina e os parâmetros desta rotina usando o percorredor.
  Converta as unidades semânticas desta rotina para a representação interna da rotina desta rotina.
  Se a representação interna da rotina desta rotina estiver no catálogo geral de rotinas,
    Apresente uma mensagem de erro contendo "Erro #067. A 'Rotina para que se " 
    junto com a representação interna da rotina desta rotina seguido de "' já foi definida anteriormente." e o endereço local desta rotinas;
    Retorne.
  Catalogue a rotina usando as unidades semânticas desta rotina e o catálogo geral de rotinas.

Rotina para que se compile um endereço da pasta (cálculo de tamanhos e deslocamentos): \ Etapa #007
  Se existir algum problema de compilação, retorne.
  Escreva "Calculando tamanhos de variáveis e deslocamentos de memória..." junto com o texto CRLF para StdOut.
  Comece o temporizador de etapas de cálculo.
  Calcule a quantidade de bytes ocupados pelos tipos.
  Calcule os deslocamentos nos tipos.
  Calcule os deslocamentos das redefinições nos tipos.
  Suspenda o temporizador de etapas de cálculo.

Rotina para que se calcule a quantidade de bytes ocupados por uns tipos:
  [Itere.]
    Se existir algum problema de compilação, retorne.
    Obtenha um tipo desde o tipos.
    Se o tipo for inexistente, retorne.
    Calcule a quantidade de bytes ocupados pelo tipo.
  Reitere.

Rotina para que se calcule a quantidade de bytes ocupados por um tipo:
  Se o tipo for inexistente, retorne.
  Se a quantidade de caracteres deste tipo não for -1, retorne. \ recursão
  Calcule a quantidade de bytes ocupados pelo tipo base deste tipo.
  Se os campos deste tipo estiverem vazios,
    Atribua a quantidade de caracteres deste tipo base deste tipo à quantidade de caracteres deste tipo;
    Retorne.
  Atribua 0 à quantidade de caracteres deste tipo.
  Itere.
    Se existir algum problema de compilação, retorne.
    Obtenha um campo desde o campos deste tipo.
    Se o campo for inexistente, retorne.
    Se o novo nome deste campo não estiver em branco, reitere.
    Calcule a quantidade de bytes ocupados pelo tipo deste campo.
    Adicione a quantidade de caracteres deste tipo deste campo vezes a contagem deste campo para a quantidade de caracteres deste tipo.
  Reitere.

Rotina para que se calcule os deslocamentos em uns tipos:
  [Itere.]
    Se existir algum problema de compilação, retorne.
    Obtenha um tipo desde o tipos.
    Se o tipo for inexistente, retorne.
    Calcule os deslocamentos no tipo.
  Reitere.

Rotina para que se calcule os deslocamentos em um tipo:
  Se o tipo for inexistente, retorne.
  Atribua 0 para um deslocamento.
  Itere.
    Se existir algum problema de compilação, retorne.
    Obtenha um campo desde os campos deste tipo.
    Se o campo for inexistente, retorne.
    Se o novo nome deste campo não estiver em branco, reitere.
    Atribua o deslocamento ao deslocamento deste campo.
    Adicione a quantidade de caracteres deste tipo deste campo vezes a contagem deste campo para o deslocamento.
  Reitere.

Rotina para que se calcule os deslocamentos das redefinições em uns tipos:
  [Itere.]
    Se existir algum problema de compilação, retorne.
    Obtenha um tipo desde os tipos.
    Se o tipo for inexistente, retorne.
    Calcule os deslocamentos das redefinições no tipo.
  Reitere.

Rotina para que se calcule os deslocamentos das redefinições em um tipo:
  Se o tipo for inexistente, retorne.
  Itere.
    Se existir algum problema de compilação, retorne.
    Obtenha um campo desde os campos deste tipo.
    Se o campo for inexistente, retorne.
    Se o novo nome deste campo estiver em branco, reitere.
    Encontre um segundo campo usando o novo nome deste campo e os campos deste tipo.
    Se o segundo campo for inexistente,
      Apresente uma mensagem de erro contendo "Erro #068. O campo '" 
      junto com o nome deste tipo seguido de "' não foi encontrado na estrutura '"
      junto com o novo nome deste campo seguido de "'.' Verifique se há erros de digitação."  e o endereço local deste campo;
      Retorne.
    Atribua o deslocamento deste segundo campo ao deslocamento deste campo.
  Reitere.

Rotina para que se encontre uma variável usando um nome e umas variáveis:
  Esvazie a variável.
  Itere.
    Obtenha a variável desde as variáveis.
    Se a variável for inexistente, retorne.
    Se o nome desta variável for o nome, retorne.
    Se o apelido desta variável for o nome, retorne.
  Reitere.

Rotina para que se compile um endereço da pasta (adição de rotinas de memória incorporadas): \ Etapa #008
  Se existir algum problema de compilação, retorne.
  Escreva "Adicionando tarefas predefinidas na memória..." junto com o texto CRLF para StdOut.
  Comece o temporizador de adição de rotinas pré-definidas de mémoria .
  Adicione as rotinas de alocação e desalocação e finalização e destruição.
  Suspenda o temporizador de adição de rotinas pré-definidas de mémoria .

Rotina para que se adicione as rotinas de alocação e desalocação e finalização e destruição:
  [Itere.]
    Se existir algum problema de compilação, retorne.
    Obtenha um tipo desde os tipos.
    Se o tipo for inexistente, retorne.
    Adicione a rotina de finalização para o tipo.
    Adicione a rotina de alocação para o tipo.
    Adicione a rotina de desalocação para o tipo.
    Adicione a rotina de destruição para o tipo.
  Reitere.

Rotina para que se adicione a rotina de finalização para um tipo:
  Se o tipo for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Se o tipo não deveria ser finalizado, retorne. \ isto é, se ele não deveria ser desalocado de forma automática
  Se o nome deste tipo for "string",
    Adicione a rotina de finalização para o tipo (cadeia de caracteres);
    Retorne.
  Se o nome deste tipo for "texto",
    Adicione a rotina de finalização para o tipo (cadeia de caracteres);
    Retorne.
  Se o nome deste tipo for "cadeia de caracteres",
    Adicione a rotina de finalização para o tipo (cadeia de caracteres);
    Retorne.
  Se o tipo puder ser reduzido para "string", retorne. \ impede a geração de finalizaores para tipos derivados de string
  Se o tipo puder ser reduzido para "texto", retorne.
  Se o tipo puder ser reduzido para "cadeia de caracteres", retorne.
  Adicione a rotina de finalização para o tipo (estrutura).

Função para que se determine se um tipo deveria ser finalizado: [determina se o compilador deveria liberar a memória alocada para algum tipo]
  \The frase "should be finalized" means "ought to be/needs to be automatically deallocated".
  Se o tipo for inexistente, diga não.
  Se o tipo puder ser reduzido para "subtexto", diga não.\ substrings apontam para (partes de) strings reais que já serão desalocadas posteriormente
  Se o tipo puder ser reduzido para "string", diga sim.\ regra padrão
  Se o tipo puder ser reduzido para "texto", diga sim.\ idem
  Se os campos deste tipo deveriam ser finalizados, diga sim.\ para strings dentro de estruturas
  Diga não.

Função para que se determine se uns campos deveriam ser finalizados;
Função para que se determine se uns campos deveria ser finalizado:
  [Itere.]
    Obtenha um campo desde o campos.
    Se o campo for inexistente, diga não.
    Se o tipo deste campo deveria ser finalizado, diga sim.
  Reitere.

Rotina para que se adicione a rotina de finalização para um tipo (cadeia de caracteres):
  Se o tipo for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Adicione uma rotina para as rotinas usando nil.
  Acrescente "~Finalize um " junto com o nome deste tipo para a string do cabeçalho desta rotina.
  Acrescente "Decodifique $50. " para a string do corpo desta rotina. \ push eax -> Empilha os 4 bytes do registrador EAX na stack
  \ A instrução push primeiro subtrai 4 do valor presente em ESP, depois coloca o operando no valor apontado por [ESP].
  \ A subtração ocorre já que a stack x86 stack cresce pra baixo - ou seja, começa do maior endereço até chegar no menor
  Acrescente "Desassocie o caractere inicial de esta string . " para a string do corpo desta rotina. \ traduzir string aqui
  Acrescente "Decodifique $58." para a string do corpo desta rotina. \ pop eax -> remove o valor do topo da stack e salva na localização EAX.  
  \ Para isso ela move o valor da presente em [SP]  para o registrador e então adiciona 4 para [SP] .
  Lance a cabeçalho de rotina desta rotina sobre a string do cabeçalho desta rotina.
  Lance as instruções desta rotina sobre a string do corpo desta rotina.
  Compile o cabeçalho pertencente à rotina.

Rotina para que se adicione a rotina de finalização para um tipo (estrutura):
  Se o tipo for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Adicione uma rotina para as rotinas usando nil.
  Acrescente "~Finalize um " junto com o nome deste tipo para a string do cabeçalho desta rotina.
  Acrescente "Decodifique $50. " para a string do corpo desta rotina. \ push eax
  Itere.
    Obtenha um campo desde os campos deste tipo.
    Se o campo for inexistente, pare.
    Se o tipo deste campo não deveria ser finalizado, reitere.
    Acrescente "~Finalize o " junto com o nome deste tipo seguido de "'s "  \ TRADUZIR AQUI 
    junto com o nome deste campo seguido de ". " para a string do corpo desta rotina.
  Reitere.
  Acrescente "Decodifique $58." para a string do corpo desta rotina. \ pop eax
  Lance a cabeçalho de rotina desta rotina sobre a string do cabeçalho desta rotina.
  Lance as instruções desta rotina sobre a string do corpo desta rotina.
  Compile o cabeçalho pertencente à rotina.

Rotina para que se adicione a rotina de alocação para um tipo:
  Se o tipo for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Se o tipo não puder ser reduzido para "ponteiro", retorne.
  Se o tipo do conteúdo deste tipo for inexistente, retorne.
  Adicione uma rotina para as rotinas usando nil.
  Acrescente "Aloque memória para um " junto com o nome deste tipo para a string do cabeçalho desta rotina. \ traduzir aqui
  Acrescente "Associe o " junto com o nome deste tipo seguido de " usando " para a string do corpo desta rotina. \Nomeie
  Acrescente a quantidade de caracteres deste tipo do conteúdo deste tipo seguido de "." para a string do corpo desta rotina.
  Lance a cabeçalho de rotina desta rotina sobre a string do cabeçalho desta rotina.
  Lance as instruções desta rotina sobre a string do corpo desta rotina.
  Compile o cabeçalho pertencente à rotina.

Rotina para que se adicione a rotina de desalocação para um tipo:
  Se o tipo for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Se o tipo não puder ser reduzido para "ponteiro", retorne.
  Se o tipo do conteúdo deste tipo for inexistente, retorne.
  Adicione uma rotina para as rotinas usando nil.
  Acrescente "Desaloque um " junto com o nome deste tipo para a string do cabeçalho desta rotina.
  Acrescente "Se o " junto com o nome deste tipo seguido de " for inexistente, retorne. " para a string do corpo desta rotina.
  Se o tipo do conteúdo deste tipo deveria ser finalizado [automaticamente por uma rotina],
    Acrescente "~Finalize o conteúdo de este " junto com o nome deste tipo seguido de ". " para a string do corpo desta rotina.
  \ Chamado quando o tipo precisa ter uma rotina de destruição gerada automaticamente para ele
  Acrescente "Desassocie o " junto com o nome deste tipo seguido de "." para a string do corpo desta rotina. \ Desaloque memória para o
  Lance a cabeçalho de rotina desta rotina sobre a string do cabeçalho desta rotina.
  Lance as instruções desta rotina sobre a string do corpo desta rotina.
  Compile o cabeçalho pertencente à rotina.

Rotina para que se adicione a rotina de destruição para um tipo:
  Se o tipo for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Se o tipo não deveria ser ignorado, retorne.
  Se o tipo puder ser reduzido para "listas",
    Adicione a rotina de destruição para o tipo (listas);
    Retorne.
  Se o tipo puder ser reduzido para "ponteiro",
    Adicione a rotina de destruição para o tipo (ponteiros);
    Retorne.

Função para que se determine se um tipo deveria ser ignorado: [ou seja, o compilador não deveria finalizar esse tipo de forma automática]
  \ ou seja, pode ser desalocado / pecisa de uma rotina de desalocação pra ele
  \See page 93 of the manual.
  Se o tipo for inexistente, diga não.
  Se o nome deste tipo for "lista", diga não. 
  \ não, porque o tipo primitivo não é alocado nem desalocado. Ele existe para que possamos usar os campos secretos (próximo e anterior)
  Se o nome deste tipo for "listas", diga não. \ porque  nesse nós "magically" generate to anchor lists of things, o mesmo aí de cima
  Se o tipo puder ser reduzido para "listas", diga sim. \ yes, because (though it seems to contradict the line immediately above of ) this is a an actual list of things that we can destroy, for example "some pages".
  Se o tipo não puder ser reduzido para "ponteiro", diga não. \  no, because a pointer variable is a static variable (it is the address in the variable that is dynamic); 
  \ the pointer variable itself is not something that can be dynamically allocated, so no destroy is necessary
  Se o tipo do conteúdo deste tipo for inexistente, diga não. \ no, because it's a pointer to nothing, so there's nothing to destroy.
  Se o tipo do conteúdo deste tipo não puder ser reduzido para "ponteiro", diga sim.\ yes, because it's a pointer to something allocated, not a pointer to another pointer. Pointers to pointers are handled with the próximo recursive line
  Se o tipo do conteúdo deste tipo não deveria ser ignorado, diga não.\ no, because it's a pointer to something that shouldn't be destroyed. For example, a pointer to a thing
  Diga sim.\ The último condition is the hardest to wrap one's head around since it is recursive.

Rotina para que se adicione a rotina de destruição para um tipo (listas):
  Se o tipo for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Se o primeiro campo destes campos deste tipo for inexistente,
    Apresente uma mensagem de erro contendo "Erro #069. O campo '" 
    junto com o nome deste primeiro campo destes campos deste tipo seguido de "' é inválido.'";
    Retorne. \
  Se o tipo deste primeiro campo destes campos deste tipo for inexistente,
    Apresente a mensagem de erro contendo "Erro #070'. O tipo '" 
    junto com o nome deste tipo deste primeiro campo destes campos deste tipo seguido de "' é inválido.'";
    Retorne.
  Atribua "Destrua [" junto com o nome deste tipo seguido de "]" para uma representação interna da rotina.
  Se a representação interna da rotina estiver no catálogo geral de rotinas, retorne.
  Adicione uma rotina para as rotinas usando nil.
  Acrescente "Destrua um " junto com o nome deste tipo para a string do cabeçalho desta rotina.
  Acrescente "Se o primeiro " junto com o nome deste tipo deste primeiro campo destes campos deste tipo
  junto com " de este " junto com o nome deste tipo seguido de " for inexistente, retorne. " para a string do corpo desta rotina. \ listas duplamente encadeadas
  Atribua o nome deste tipo deste primeiro campo destes campos deste tipo para um nome.
  Acrescente "Atribua o primeiro " junto com o nome junto com " de este " 
  junto com o nome deste tipo seguido de " para um " junto com o nome seguido de ". " para a string do corpo desta rotina.\ traduzir
  Acrescente "Remova o " junto com o nome seguido de " desde o " junto com o nome deste tipo seguido de ". " para a string do corpo desta rotina.
  Acrescente "Destrua o " junto com o nome seguido de ". " para a string do corpo desta rotina.
  Acrescente "Reitere. " para a string do corpo desta rotina.
  Lance a cabeçalho de rotina desta rotina sobre a string do cabeçalho desta rotina.
  Lance as instruções desta rotina sobre a string do corpo desta rotina.
  Compile o cabeçalho pertencente à rotina.

Rotina para que se adicione a rotina de destruição para um tipo (ponteiros):
  Se o tipo for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Atribua "Destrua [" junto com o nome deste tipo seguido de "]" para uma representação interna da rotina.
  Se a representação interna da rotina estiver no catálogo geral de rotinas, retorne.
  Adicione uma rotina para as rotinas usando nil.
  Acrescente "Destrua um " junto com o nome deste tipo para a string do cabeçalho desta rotina.
  Acrescente "Se o " junto com o nome deste tipo seguido de " for inexistente, retorne. " para a string do corpo desta rotina.
  Se o tipo do conteúdo deste tipo puder ser reduzido para "ponteiro", 
    Acrescente "Destrua o conteúdo de este " junto com o nome deste tipo seguido de "'. " para a string do corpo desta rotina.
  Se o tipo do conteúdo deste tipo puder ser reduzido para "listas", 
    Acrescente "Destrua o conteúdo de este " junto com o nome deste tipo seguido de "'. " para a string do corpo desta rotina.
  Itere.
    Obtenha um campo desde os campos deste tipo do conteúdo deste tipo.
    Se o campo for inexistente, pare.
    Se o sinalizador de referência deste campo estiver ativo, reitere.
    Se o tipo deste campo não deveria ser ignorado, reitere.
    Acrescente "Destrua o " junto com o nome deste campo seguido de " de este " 
    junto com o nome deste tipo seguido de ". " para a string do corpo desta rotina.
  Reitere.
  Acrescente "Desaloque o " junto com o nome deste tipo seguido de ". " para a string do corpo desta rotina. \ traduzir aqui
  Lance a cabeçalho de rotina desta rotina sobre a string do cabeçalho desta rotina.
  Lance as instruções desta rotina sobre a string do corpo desta rotina.
  Compile o cabeçalho pertencente à rotina.

Rotina para que se compile um endereço da pasta (catalogue as rotinas por utilização): \ Etapa #009
  Se existir algum problema de compilação, retorne.
  Escreva "Catalogando tarefas..." junto com o texto CRLF para StdOut.
  Comece o temporizador de ferramentas de catalogação.
  Catalogue as rotinas por utilização.
  Scrub o catálogo de rotinas úteis.
  Organize o catálogo de rotinas úteis.
  Suspenda o temporizador de ferramentas de catalogação.

Rotina para que se scrub um catálogo: \ limpar, filtrar, refinar
  Itere.
    Obtenha um recipiente usando o catálogo.
    Se o recipiente for inexistente,
      Retorne.
    Se as referências deste recipiente estiverem vazios,
      Reitere.
    Scrub as referências deste recipiente.
  Reitere.

Rotina para que se scrub umas referências:
  Permute as referências com umas novas referências.
  Itere.
    Atribua a primeira referência destas novas referências para uma referência.
    Se a referência for inexistente,
      Retorne.
    [Se a referência não for nula,]
    Remova a referência desde as novas referências.
    Se o ponteiro desta referência for inexistente,
      Destrua a referência;
      Reitere.
    [Se o ponteiro desta referência não for nulo,]
    Acrescente a referência para as referências.
  Reitere.

Rotina para que se organize o catálogo de rotinas úteis:
    Se existir algum problema de compilação, retorne.
    Obtenha um recipiente usando o catálogo de rotinas úteis.
    Se o recipiente for inexistente, retorne.
    Se as referências deste recipiente estiverem vazios, reitere.
    Organize o catálogo de rotinas úteis usando as referências deste recipiente.
  Reitere.

Rotina para que se organize o catálogo de rotinas úteis usando umas referências:
    Obtenha uma referência desde as referências.
    Se a referência for inexistente, retorne.
    Atribua o ponteiro desta referência para uma rotina.
    Se a rotina for inexistente,
      Apresente uma mensagem de erro contendo "Erro #071 (interno). A rotina não foi localizada";
      Retorne.
    Copie as unidades semânticas desta rotina para umas unidades semânticas.
    Reduza as unidades semânticas por utilização.
    Catalogue a rotina usando as unidades semânticas e o catálogo geral de rotinas.
    Destrua as unidades semânticas.
  Reitere.

Rotina para que se copie umas unidades semânticas para umas segunda unidades semânticas:
  Destrua as segunda unidades semânticas.
  Itere.
    Obtenha uma unidade semântica desde as unidades semânticas.
    Se a unidade semântica for inexistente, retorne.
    Copie a unidade semântica para uma segunda unidade semântica.
    Acrescente a segunda unidade semântica para as segunda unidades semânticas.
  Reitere.

Rotina para que se copie uma unidade semântica para uma segunda unidade semântica:
  Se a unidade semântica for inexistente,
    Esvazie a segunda unidade semântica;
    Retorne.
  Aloque memória para o segunda unidade semântica.
  Atribua a string desta unidade semântica à string desta segunda unidade semântica.
  Atribua o tipo desta unidade semântica ao tipo desta segunda unidade semântica.
  Atribua a variável desta unidade semântica à variável desta segunda unidade semântica.
  \ não copia subtexto
  Atribua o tipo atual desta unidade semântica ao tipo atual desta segunda unidade semântica.

Rotina para que se reduza umas unidades semânticas por utilização:
  [Itere.]
    Obtenha uma unidade semântica desde as unidades semânticas.
    Se a unidade semântica for inexistente, retorne.
    Se o tipo desta unidade semântica for inexistente, reitere.
    Reduza o tipo desta unidade semântica para um tipo por utilização.
    Se o tipo não for inexistente, 
      Atribua o tipo ao tipo desta unidade semântica.
  Reitere.

Rotina para que se reduza um tipo para um segundo tipo por utilização:
  Atribua o tipo ao segundo tipo.
  Itere.
    Se o segundo tipo for inexistente, retorne.
    Se o nome deste segundo tipo for "texto hexadecimal", retorne.
    Se o nome deste segundo tipo for "string", retorne.
    Se o nome deste segundo tipo for "texto", retorne.
    Se o nome deste segundo tipo for "número", retorne.
    Se o nome deste segundo tipo for "ponteiro", retorne.
    Se o nome deste segundo tipo for "lista",
      Esvazie o segundo tipo;
      Retorne.
    \PAL
    Se o tipo base deste segundo tipo for o segundo tipo,
      Esvazie o segundo tipo;
      Retorne.
    Atribua o tipo base deste segundo tipo ao segundo tipo.
  Reitere.

Rotina para que se compile um endereço da pasta (conteúdo das rotinas): \ Etapa #010
  Se existir algum problema de compilação, retorne.
  Escreva "Agrupando o conteúdo das rotinas..." junto com o texto CRLF para StdOut.
  Comece o temporizador de compilação do conteúdo das rotinas.
  Compile os corpos de todas as rotinas.
  Suspenda o temporizador de compilação do conteúdo das rotinas.

Rotina para que se compile os corpos de todas as rotinas:
  Compile o corpo pertencente à rotina denominada "Inicialize antes da execução".
  Compile o corpo pertencente à rotina denominada "Execute o programa".
  Compile o corpo pertencente à rotina denominada "Finalize após execução".

Rotina para que se compile o corpo pertencente para uma rotina:
  Se a rotina for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Se o sinalizador de compilação desta rotina estiver ativo, retorne.
  Ative o sinalizador de compilação desta rotina.
  Lance um percorredor sobre as instruções desta rotina.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for o ponto&vírgula,
    Compile o corpo pertencente à rotina usando o percorredor (sobrecarga de métodos);
    Retorne. \ *** alternate wording
  \Se o segmento inicial deste percorredor for uma palavra-chave de reutilização de rotina, \ EMPLOY
    \Compile o corpo pertencente à rotina usando o percorredor (cláusula de reutilização); 
    \Retorne.
  Atribua a rotina utilizada atualmente para uma rotina denominada nova rotina.
  Atribua a rotina à rotina utilizada atualmente.
  Crie o catálogo de apelidos desta rotina usando 101.
  Elimine apelidos duplicados desde os parâmetros desta rotina usando o catálogo de apelidos desta rotina.
  Compile o corpo pertencente à rotina (etapa preliminar).
  Itere.
    Se existir algum problema de compilação, retorne.
    Se o segmento inicial deste percorredor estiver em branco, pare.
    Compile a próxima instrução usando o percorredor.
  Reitere.
  Compile o corpo pertencente à rotina (etapa conclusiva).
  Atribua a nova rotina à rotina utilizada atualmente.
  \Destrua o catálogo de apelidos desta rotina.

Rotina para que se compile o corpo pertencente para uma rotina usando um percorredor (sobrecarga de métodos):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação). \ TODO:  verificar se essa linha é necessária
  Atribua a próxima rotina desta rotina para um rotina alvo.
  Se a rotina alvo for inexistente,
    Apresente uma mensagem de erro contendo "Erro #17. Não foi possível encontrar o cabeçalho alternativo desta rotina." e o percorredor;
    Retorne.
  Atribua a representação interna da rotina deste rotina alvo para a representação de emprego desta rotina.
  Compile o corpo pertencente à rotina alvo.

Rotina para que se elimine apelidos duplicados desde umas variáveis usando um catálogo:
  Se o catálogo for inexistente, retorne.
  Itere.
    Obtenha uma variável desde as variáveis.
    Se a variável for inexistente, retorne.
    Elimine apelidos duplicados usando a variável e o catálogo.
  Reitere.

Rotina para que se elimine apelidos duplicados usando uma variável e um catálogo:
  Se a variável for inexistente, retorne.
  Se o catálogo for inexistente, retorne.
  Encontre uma segunda variável usando o apelido desta variável e o catálogo.
  Se a segunda variável for inexistente, 
    Encontre a segunda variável usando o nome desta variável e o catálogo.
  Se a segunda variável for inexistente,
    Catalogue a variável usando o apelido desta variável e o catálogo;
    Retorne.
  Limpe o apelido desta segunda variável.
  Limpe o apelido desta variável.

Rotina para que se compile o corpo pertencente para uma rotina (etapa preliminar):
  Se a rotina for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Adicione um fragmento usando a etiqueta preliminar.
  Adicione um segundo fragmento usando a etiqueta de laço.

Rotina para que se adicione um fragmento usando uma etiqueta:
  Se a rotina utilizada atualmente for inexistente,
    Esvazie o fragmento;
    Retorne.
  Crie o fragmento usando a etiqueta.
  Acrescente o fragmento para os fragmentos desta rotina utilizada atualmente.

Rotina para que se crie um fragmento usando uma etiqueta:
  Aloque memória para o fragmento.
  Atribua a etiqueta à etiqueta deste fragmento.

Rotina para que se compile a próxima instrução usando um percorredor:
  Se existir algum problema de compilação, retorne.
  Se o segmento inicial deste percorredor for algum comando condicional,
    Compile a próxima instrução usando o percorredor (cláusula de condicional);
    Retorne.
  Se o segmento inicial deste percorredor for algum comando de percorrimento,
    Compile a próxima instrução usando o percorredor (cláusula de inicio de laço);
    Retorne.
  Se o segmento inicial deste percorredor for algum comando de proteção,
    Compile a próxima instrução usando o percorredor (cláusula de isolamento);
    Retorne.
  Se o segmento inicial deste percorredor não for o início de alguma declaração,
    Apresente uma mensagem de erro contendo "Erro #50. Esperado declaração. Encontrado: " 
    junto com o segmento inicial deste percorredor seguido de "." e o percorredor;
    Retorne.
  Compile a próxima instrução usando o percorredor (demais cláusulas).
  Se o segmento inicial deste percorredor não for o ponto final,
    Apresente a mensagem de erro contendo "Erro #51. Este comando está incorreto ou é uma palavra-chave reservada." e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).

Rotina para que se compile a próxima instrução usando um percorredor (cláusula de condicional):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile umas unidades semânticas usando o percorredor.
  Remova alguns termos negativos desde as unidades semânticas retornando um sinalizador.
  Encontre uma rotina usando as unidades semânticas.
  Se a rotina não for inexistente, adicione push fragmentos usando as unidades semânticas.
  Se a rotina for inexistente, converta as unidades semânticas para uma representação interna da rotina.
  Destrua as unidades semânticas.
  Se a rotina for inexistente,
    Apresente uma mensagem de erro contendo "Erro #61. A rotina para que se determine se '"
    junto com a representação interna da rotina seguido de "' não existe." e o percorredor;
    Retorne.
  Se o sinalizador de deliberação desta rotina não estiver ativo,
    Apresente a mensagem de erro contendo "Erro #62. Necessário utilizar um decisor." e o percorredor;
    Retorne.
  \ Se o segmento inicial deste percorredor não for a vírgula, apresente a mensagem de erro contendo "Acho que você esqueceu de uma vírgula, eu achei isso aqui: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; Retorne.
  Se o segmento inicial deste percorredor não for qualquer separador de comandos,
    Apresente a mensagem de erro contendo "Erro #63. Necessário incluir uma vírgula ao invés de: "
    junto com o segmento inicial deste percorredor seguido de "." e o percorredor;
    Retorne.
  Adicione um fragmento usando a etiqueta de demanda interna e a rotina.
  Se o sinalizador estiver ativo, adicione um segundo fragmento usando a etiqueta de negação lógica.
  Adicione um terceiro fragmento usando o etiqueta de desvio falso.
  Mova o percorredor (usando diretrizes de compilação).
  Itere.
    Compile a próxima instrução usando o percorredor (demais cláusulas).
    Se existir algum problema de compilação, retorne.
    Se o segmento inicial deste percorredor for o ponto&vírgula,
    Mova o percorredor (usando diretrizes de compilação);
    Reitere.
    Se o segmento inicial deste percorredor não for o ponto final,
    Apresente a mensagem de erro contendo "Erro #64. Necessário incluir um '.' ao invés de: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Adicione um quarto fragmento usando o etiqueta delimitadora de bloco condicional.

Rotina para que se compile umas unidades semânticas usando um percorredor:
  [Itere.]  
    Se existir algum problema de compilação, retorne.
    Se o percorredor estiver sobre alguma unidade semântica relevante, \
      Adicione uma unidade semântica para as unidades semânticas usando o segmento inicial deste percorredor;
      Mova o percorredor (usando diretrizes de compilação); Reitere.
    Se o segmento inicial deste percorredor não for o início de alguma expressão matemática, retorne.
    Compile uma expressão matemática usando o percorredor.
    Se existir algum problema de compilação, retorne.
    Adicione uma segunda unidade semântica para as unidades semânticas usando a expressão matemática.
  Reitere.

Função para que se determine se um percorredor está sobre alguma unidade semântica relevante:
  Se o segmento inicial deste percorredor estiver em branco, diga não.
  Se o percorredor estiver sobre algum artigo definido, diga não.
  Se o percorredor estiver sobre algum artigo indefinido, diga não.
  Se o segmento inicial deste percorredor for algum possessivo inglês, diga não.
  Se o segmento inicial deste percorredor for algum valor literal, diga não.
  Se o segmento inicial deste percorredor for algum sinal de pontuação, diga não.
  Se o segmento inicial deste percorredor for algum símbolo, diga não.
  Se o segmento inicial deste percorredor for "então", diga não.
  Diga sim.

Rotina para que se compile uma expressão matemática usando um percorredor:
  Se existir algum problema de compilação, retorne.
  Compile um termo usando o percorredor.
  Atribua o termo ao expressão matemática.
  Itere.
    Se existir algum problema de compilação, retorne.
    Se o segmento inicial deste percorredor não for algum operador aritmético, retorne.
    Se o segmento inicial deste percorredor for algum operador de divisão,
      Compile a expressão matemática usando o percorredor (operador de divisão); \ 
      Reitere.
    Se o segmento inicial deste percorredor for algum operador de subtração,
      Compile a expressão matemática usando o percorredor (operador de subtração);
      Reitere.
    Se o segmento inicial deste percorredor for algum operador de adição,
      Compile a expressão matemática usando o percorredor (operador de adição);
      Reitere.
    Se o segmento inicial deste percorredor for algum operador de concatenação,
      Compile a expressão matemática usando o percorredor (operador de concatenação);
      Reitere.
    Se o segmento inicial deste percorredor for algum operador de multiplicação,
      Compile a expressão matemática usando o percorredor (operador de multiplicação);
      Reitere.
    \Se o segmento inicial deste percorredor for "junto",
      \Compile a expressão matemática usando o percorredor (operador de concatenação);
      \Reitere.
    \Se o segmento inicial deste percorredor for "juntamente",
      \Compile a expressão matemática usando o percorredor (operador de concatenação);
      \Reitere.
    \Se o segmento inicial deste percorredor for "seguido",
      \Compile a expressão matemática usando o percorredor (operador de concatenação);
      \Reitere.
    \Se o segmento inicial deste percorredor for "acompanhado",
      \Compile a expressão matemática usando o percorredor (operador de concatenação);
      \Reitere.

Rotina para que se compile uma expressão matemática usando um percorredor (operador de divisão):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum objeto indireto,
    Apresente uma mensagem de erro contendo "Erro #22. Você deve usar o termo 'dividido POR'." e o percorredor;
    Retorne.
  Se a variável desta expressão matemática for inexistente,
    Apresente a mensagem de erro contendo "Erro #23. Comando 'dividido por' inválido. A variável '" 
    junto com a frase desta expressão matemática seguido de "' é nula." e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile um termo usando o percorredor.
  Se existir algum problema de compilação, retorne.
  Se a variável deste termo for inexistente,
    Apresente a mensagem de erro contendo "Erro #24. O comando 'dividido por', está errado. Não é possível dividir por '" 
    junto com a frase deste termo seguido de "'." e o percorredor;
    Retorne.
  Adicione uma variável intermediária usando 
    o nome do tipo desta expressão matemática e 
    o caractere inicial deste segmento inicial deste percorredor.
  Adicione fragmentos diversos usando 
    "Atribua" e a variável desta expressão matemática e 
    "para" e 
    a variável intermediária e 
    o caractere inicial deste segmento inicial deste percorredor.
  Adicione fragmentos diversos usando 
    "Divida" e 
    a variável intermediária e 
    "por" e 
    a variável deste termo e 
    o caractere inicial deste segmento inicial deste percorredor.
  Atribua a variável intermediária à variável desta expressão matemática.
  Limpe a frase desta expressão matemática.

Função para que se determine se uma string é algum objeto indireto:
  Se a string for "via", diga sim. 
  Se a string for "por", diga sim. \ TODO: Testar a compatibilidade
  Diga não.


Rotina para que se compile um termo usando um percorredor:
  Limpe o termo.
  Se existir algum problema de compilação, retorne.
  Compile o termo usando o percorredor (análise preliminar).
  Se o percorredor estiver sobre algum simile, retorne. \ added for invisible turtle project ***
  \Se o segmento inicial deste percorredor for "as", 
    \Compile o termo usando o percorredor (cláusula comparativa). \preposição
  Se o segmento inicial deste percorredor for "quão", 
    Compile o termo usando o percorredor (cláusula comparativa).
  Se o segmento inicial deste percorredor for "quanto", 
    Compile o termo usando o percorredor (cláusula comparativa).
  Se o segmento inicial deste percorredor for "como", 
    Compile o termo usando o percorredor (cláusula comparativa).
  \Se o segmento inicial deste percorredor for "que nem", 
    \Compile o termo usando o percorredor (cláusula comparativa).
  Se o segmento inicial deste percorredor for "/", 
    Compile o termo usando o percorredor (proporção de execução).

Rotina para que se compile um termo usando um percorredor (análise preliminar):
  Se existir algum problema de compilação, retorne.
  Se o segmento inicial deste percorredor for o sinal de subtração,
    Compile o termo usando o percorredor (subtração de termo);
    Retorne.
  Se o segmento inicial deste percorredor for o sinal de adição,
    Compile o termo usando o percorredor (adição de termo);
    Retorne.
  Se o segmento inicial deste percorredor for o início de alguma variável,
    Compile o termo usando o percorredor (variável);
    Retorne.
  Se o segmento inicial deste percorredor for o início de alguma variável local,
    Compile o termo usando o percorredor (nova variável local);
    Retorne.
  Se o segmento inicial deste percorredor for algum valor literal,
    Compile o termo usando o percorredor (valor literal);
    Retorne.
  Apresente uma mensagem de erro contendo "Erro #95. O Compilador esperava encontrar um termo. Encontrado: '"
  junto com o segmento inicial deste percorredor seguido de "'." e o percorredor.

Rotina para que se compile um termo usando um percorredor (subtração de termo):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile um novo termo usando o percorredor.
  Se existir algum problema de compilação, retorne.
  Se a variável deste novo termo for inexistente,
    Apresente uma mensagem de erro contendo "Erro #99. Identificador inválido após o sinal de subtração. O termo  '"
    junto com a frase deste novo termo seguido de "' não foi encontrado." e o percorredor;
    Retorne.
  Adicione uma variável intermediária usando o nome do tipo deste novo termo e o caractere inicial deste segmento inicial deste percorredor.
  Adicione fragmentos diversos usando "Atribua" e a variável deste novo termo e "para" e a variável intermediária e o endereço local deste novo termo.
  Adicione outros dois fragmentos usando "Inverta o sinal de" e a variável intermediária e o caractere inicial deste segmento inicial deste percorredor.
  Atribua a variável intermediária à variável deste termo.
  Limpe a frase deste termo.

Rotina para que se adicione uma variável intermediária usando um nome do tipo e um endereço local:
  Se a rotina utilizada atualmente for inexistente,
    Esvazie a variável intermediária;
    Retorne.
  Adicione a variável intermediária para as variáveis locais desta rotina utilizada atualmente usando "local" e o endereço local.
  Gere o nome desta variável intermediária usando "~I".
  Atribua o nome do tipo ao nome do tipo desta variável intermediária.
  Destrinche a variável intermediária.

Rotina para que se adicione fragmentos diversos usando uma string e uma variável e uma segunda string e uma segunda variável e um endereço local:
  Adicione um fragmento usando o etiqueta de inserção de endereço [na stack] e a segunda variável.
  Adicione um segundo fragmento usando o etiqueta de inserção de endereço [na stack] e a variável.
  Adicione uma unidade semântica para umas unidades semânticas usando a string.
  Adicione uma segunda unidade semântica para as unidades semânticas usando o tipo desta variável.
  Adicione uma terceira unidade semântica para as unidades semânticas usando a segunda string.
  Adicione uma quarta unidade semântica para as unidades semânticas usando o tipo desta segunda variável.
  Encontre uma rotina usando as unidades semânticas.
  Se a rotina for inexistente, 
    Converta as unidades semânticas para uma representação interna da rotina.
  Destrua as unidades semânticas.
  Se a rotina for inexistente,
    Apresente uma mensagem de erro contendo "Erro #003. A 'Rotina para que se " 
    junto com a representação interna da rotina seguido de "' não foi encontrada." e o endereço local;
    Retorne.
  Adicione um terceiro fragmento usando a etiqueta de demanda interna e a rotina.

Rotina para que se adicione um fragmento usando uma etiqueta e uma variável:
  Se a rotina utilizada atualmente for inexistente,
    Esvazie o fragmento;
    Retorne.
  Crie o fragmento usando a etiqueta.
  Acrescente o fragmento para os fragmentos desta rotina utilizada atualmente.
  Atribua a variável à variável deste fragmento.
  Ative o sinalizador de compilação na variável.

Rotina para que se encontre uma rotina usando umas unidades semânticas:
  Esvazie a rotina.
  Encontre a rotina usando 
    Uma representação interna da rotina e 
    A primeira unidade semântica destas unidades semânticas e 
    O catálogo geral de rotinas.

Rotina para que se encontre uma rotina usando uma representação interna da rotina e uma unidade semântica e um catálogo:
  Se a unidade semântica for inexistente, retorne.
  Esvazie a rotina.
  Preserve a representação interna da rotina.
  Atribua o tipo desta unidade semântica ao tipo atual desta unidade semântica.
  Lance o subtexto atual desta unidade semântica sobre a string desta unidade semântica.
  Itere.
    Acrescente a unidade semântica para a representação interna da rotina (inserção de colchetes).
    Encontre uma referência usando a representação interna da rotina e o catálogo.
    Se a referência não for inexistente, atribua o ponteiro deste referência à rotina.
    Se a referência não for inexistente, encontre a rotina usando a representação interna da rotina e a próxima unidade semântica desta unidade semântica e o catálogo.
    Se a rotina não for inexistente, pare.
    Defina o tipo de a unidade semântica.
    Se a unidade semântica estiver indefinida, pare.
    Atribua a representação interna da rotina original para a representação interna da rotina.
  Reitere.

Rotina para que se acrescente uma unidade semântica para uma representação interna da rotina (inserção de colchetes):
  Se a unidade semântica for inexistente, retorne.
  Se a representação interna da rotina não estiver em branco, 
    Acrescente o caractere de espaço para a representação interna da rotina.
  Se o subtexto atual desta unidade semântica não estiver em branco,
    Acrescente o subtexto atual desta unidade semântica para a representação interna da rotina ;
    Retorne.
  Se o tipo atual desta unidade semântica não for inexistente,
    Acrescente "[" e o nome deste tipo atual desta unidade semântica e "]" para a representação interna da rotina (rapidamente);
    \ colchetes monikettes
    Retorne.

\ Rotina para que se acrescente 3 strings distintas para uma string.
Rotina para que se acrescente uma string e uma segunda string e uma terceira string para uma quarta string (rapidamente):
  Atribua a quantidade de caracteres desta quarta string para uma quantidade de caracteres.
  Adicione a quantidade de caracteres desta string para a quantidade de caracteres. \ Atribua a quantidade de caracteres da 1ª string para a quantidade de caracteres.
  Adicione a quantidade de caracteres desta segunda string para a quantidade de caracteres.
  Adicione a quantidade de caracteres desta terceira string para a quantidade de caracteres.
  Reaponte um ponteiro usando a quantidade de caracteres.
  Atribua o ponteiro para um endereço de byte .
  Copie bytes desde o caractere inicial desta quarta string para o endereço de byte pela quantidade de caracteres desta quarta string.
  Adicione a quantidade de caracteres desta quarta string para o endereço de byte .
  Copie bytes desde o caractere inicial desta string para o endereço de byte pela quantidade de caracteres desta string.
  Adicione a quantidade de caracteres desta string para o endereço de byte .
  Copie bytes desde o caractere inicial desta segunda string para o endereço de byte pela quantidade de caracteres desta segunda string.
  Adicione a quantidade de caracteres desta segunda string para o endereço de byte .
  Copie bytes desde o caractere inicial desta terceira string para o endereço de byte pela quantidade de caracteres desta terceira string.
  Desassocie o caractere inicial desta quarta string.
  Atribua o ponteiro ao caractere inicial desta quarta string.
  Atribua o ponteiro mais a quantidade de caracteres menos 1 ao caractere final desta quarta string.

Rotina para que se adicione um fragmento usando uma etiqueta e uma rotina:
  Se a rotina utilizada atualmente for inexistente,
    Esvazie o fragmento;
    Retorne.
  Crie o fragmento usando a etiqueta.
  Acrescente o fragmento para os fragmentos desta rotina utilizada atualmente.
  Atribua a rotina à rotina deste fragmento.
  Compile o corpo pertencente à rotina.

Rotina para que se adicione outros dois fragmentos usando uma string e uma variável e um endereço local:
  Adicione um fragmento usando o etiqueta de inserção de endereço [na stack] e a variável.
  Adicione uma unidade semântica para umas unidades semânticas usando a string.
  Adicione uma segunda unidade semântica para as unidades semânticas usando o tipo desta variável.
  Encontre uma rotina usando as unidades semânticas.
  Se a rotina for inexistente, 
    Converta as unidades semânticas para uma representação interna da rotina.
  Destrua as unidades semânticas.
  Se a rotina for inexistente,
    Apresente uma mensagem de erro contendo "Erro. A 'Rotina para que se "
    junto com a representação interna da rotina seguido de "' ainda não foi definida." e o endereço local;
    Retorne.
  Adicione um segundo fragmento usando a etiqueta de demanda interna e a rotina.

Rotina para que se compile um termo usando um percorredor (adição de termo):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile o termo usando o percorredor.
  Se a variável deste termo for inexistente,
    Apresente uma mensagem de erro contendo "Erro #103. Identificador inválido após o sinal de adição. O termo '" 
    junto com a frase deste termo seguido de "' não foi localizado." e o percorredor;
    Retorne.
  Limpe a frase deste termo.

Função para que se determine se uma string é o início de alguma variável:
  Se a string for algum artigo definido, diga sim.
  \Se a string for "do", diga sim. \ this is iffy, here for reverse-possessives
  Diga não.

Rotina para que se compile um termo usando um percorredor (variável):
  Se existir algum problema de compilação, retorne.
  Se a rotina utilizada atualmente for inexistente,
    Apresente uma mensagem de erro contendo "Erro #110. Rotina inexistente. Impossível empilhar o identificador especificado." e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Se o percorredor estiver sobre algum possessivo reverso,
    Compile o termo usando o percorredor e o nome (possessivo reverso);
    Retorne.
  Encontre uma variável usando o nome.
  Atribua a variável à variável deste termo.
  Atribua "O " à frase deste termo.
  Acrescente o nome para a frase deste termo.
  Compile o termo usando o percorredor (possessivos).

Função para que se determine se uma string é algum possessivo reverso:
  Se a string for "de", diga sim.
  \Se a string for "do", diga sim. \ short por "de o", expanded em "compile um termo usando um percorredor e um campo nome (possessivo reverso)"
  Diga não.

Rotina para que se compile um termo usando um percorredor e um campo nome (possessivo reverso):
  \ função recursiva
  \ Rotina nova criada pelo Dahn para version 2
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação). \ após o starter do possessivo reverso
  \Se o segmento inicial deste percorredor não for "del", mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum artigo,
    Apresente uma mensagem de erro contendo "Erro #111. Esperado artigo. Encontrado '" 
    junto com o segmento inicial deste percorredor seguido de "'.";
    Retorne.
  Atribua o segmento inicial deste percorredor para um article segmento inicial.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Se o percorredor estiver sobre algum possessivo reverso, 
    Ative um sinalizador de possessivo reverso.
  Se o sinalizador de possessivo reverso estiver ativo, 
    Compile o termo usando o percorredor e o nome (possessivo reverso).
  Se o sinalizador de possessivo reverso não estiver ativo, 
    Compile o termo usando o percorredor e o nome e o article (reversão de contrações do possessivo). \?
  Compile o termo usando o campo nome e o percorredor (possessivo reverso).

Rotina para que se compile um termo usando um percorredor e uma variável nome e um article segmento inicial (reversão de contrações do possessivo):
  \ Rotina nova criada pelo Dahn para a versão 2
  Se o article for o início de alguma variável,
    Compile o termo usando o percorredor e a variável nome e o article (reversão de contrações de variáveis do possessivo);
    Retorne.
  Compile o termo usando o percorredor e a variável nome (decomposição do possessivo reverso - variável local).

Rotina para que se compile um termo usando um percorredor e uma variável nome e um article segmento inicial (reversão de contrações de variáveis do possessivo):
  \ Rotina nova criada pelo Dahn para a versão 2
  Encontre uma variável usando a variável nome.
  Se a variável for inexistente,
    Apresente uma mensagem de erro contendo "Erro #112. Não foi possível encontrar a variável '" 
    junto com a variável nome seguido de "'.".
  Atribua a variável à variável deste termo.
  Atribua "O " à frase deste termo.
  Acrescente a variável nome para a frase deste termo.

Rotina para que se compile um termo usando um percorredor e uma variável nome (decomposição do possessivo reverso - variável local):
  \ Rotina nova criada pelo Dahn para a versão 2
  Se existir algum problema de compilação, retorne.
  Adicione uma variável local para as variáveis locais desta rotina utilizada atualmente 
  usando "local" e o caractere inicial deste segmento inicial deste percorredor.
  \PAL
  \Se o segmento inicial deste percorredor for "outra", 
    \Atribua "outra" ao nome desta variável local.
  \Se o segmento inicial deste percorredor for "outro", 
    \Atribua "outro" ao nome desta variável local.
  \Se o segmento inicial deste percorredor for "segundo", 
    \Atribua "segundo" ao nome desta variável local.
  \Se o segmento inicial deste percorredor for "segunda", 
    \Atribua "segunda" ao nome desta variável local.
  Expanda o nome desta variável local com a variável nome.
  Se o segmento inicial deste percorredor for uma palavra-chave de designação, 
    Compile a parte designadora usando o percorredor e a variável local.
  Destrinche a variável local.
  Se a variável local estiver duplicada em os parâmetros desta rotina utilizada atualmente,
    Apresente uma mensagem de erro contendo "Erro #113. O identificador: "
    junto com o nome desta variável local seguido de "' já está sendo usado como parâmetro." e o endereço local desta variável local;
    Retorne.
  Se a variável local estiver duplicada em as variáveis locais desta rotina utilizada atualmente,
    Apresente a mensagem de erro contendo "Erro #114. O identificador: " 
    junto com o nome desta variável local seguido de "' já está sendo usado coma variável local." e o endereço local desta variável local;
    Retorne.
  Elimine apelidos duplicados usando a variável local e o catálogo de apelidos desta rotina utilizada atualmente.
  Atribua a variável local à variável deste termo.
  Limpe a frase deste termo.

Rotina para que se compile um termo usando um campo nome e um percorredor (possessivo reverso):
  \ similar à rotina "compile um termo usando um percorredor (possessivo)" 
  \ Rotina nova criada pelo Dahn 
  Se existir algum problema de compilação, retorne.
  Se o campo nome for alguma palavra-chave de obtenção de tamanho de variável,
    Compile o termo usando o percorredor (possessivo - magnitude);
    Retorne.
  Se o campo nome for algum conteúdo,
    Compile o termo usando o percorredor (possessivo - conteúdo);
    Retorne.
  Se o campo nome for algum endereçamento,
    Compile o termo usando o percorredor (possessivo - endereçamento);
    Retorne.
  Compile o termo usando o percorredor e o campo nome (possessivo - campo).


Função para que se determine se uma string é o início de alguma variável local:
  Se a string for algum artigo indefinido, diga sim.
  Diga não.

Rotina para que se compile um termo usando um percorredor (possessivos):
  [Itere.]
  Se existir algum problema de compilação, retorne.
    Se o segmento inicial deste percorredor não for algum possessivo inglês, retorne.
    Compile o termo usando o percorredor (possessivo).
  Reitere.



















Rotina para que se compile um endereço da pasta (adição e compilação da rotina de inicialização): \ Etapa #011
  Se existir algum problema de compilação, retorne.
  Escreva "Adicionando e agrupando as tarefas padrão de inicialização.." junto com o texto CRLF para StdOut.
  Comece o temporizador de adição de rotinas pré-definidas de inicialização.
  Adicione e compile as rotinas de inicialização pré-execução e finalização pós-execução.
  Suspenda o temporizador de adição de rotinas pré-definidas de inicialização.

Rotina para que se compile um endereço da pasta (deslocamento de parâmetros e variáveis): \ Etapa #012
  Se existir algum problema de compilação, retorne.
  Escreva "Deslocando parâmetros e variáveis..." junto com o texto CRLF para StdOut.
  Comece o temporizador de deslocamentos.
  Alinhe o parâmetros na rotinas.
  Alinhe as variáveis locais na rotinas.
  Suspenda o temporizador de deslocamentos.

Rotina para que se compile um endereço da pasta (endereço): \ Etapa #013
  Se existir algum problema de compilação, retorne.
  Escreva "Obtendo endereço dos itens..." junto com o texto CRLF para StdOut.
  Comece o temporizador de endereçamento.
  Atribua 4096 para um endereço.
  Atribua o endereço à endereço base desta Seção de DLLs.
  Enderece as DLLs usando o endereço.
  Atribua o endereço menos a endereço base desta Seção de DLLs à quantidade de caracteres desta Seção de DLLs.
  Arredonde o endereço para cima usando o múltiplo imediato de 4096.
  Atribua o endereço à endereço base desta Região de Dados.
  Enderece as variáveis globais usando o endereço.
  Enderece os valores literais usando o endereço.
  Atribua o endereço menos a endereço base desta Região de Dados à quantidade de caracteres desta Região de Dados.
  Arredonde o endereço para cima usando o múltiplo imediato de 4096.
  Atribua o endereço à endereço base desta Região de Código. \ Uma zona é uma estrutura que contém um endereço base, uma quantidade de caracteres e um tamanho.
  Enderece as rotinas usando o endereço.
  Atribua o endereço menos a endereço base desta Região de Código à quantidade de caracteres desta Região de Código.
  Suspenda o temporizador de endereçamento.

Rotina para que se compile um endereço da pasta (transmutação): \ Etapa #014
  Se existir algum problema de compilação, retorne.
  Escreva "Convertendo código em instruções de máquina..." junto com o texto CRLF para StdOut.
  Comece o temporizador de transmutação.
  Transforme as rotinas em código hexadecimal.
  Suspenda o temporizador de transmutação.

Rotina para que se compile um endereço da pasta (vinculação): \ Etapa #015
  Se existir algum problema de compilação, retorne.
  Escreva "Elencando arquivos.." junto com o texto CRLF para StdOut.
  Comece o temporizador de vinculação.
  Vincule.
  Suspenda o temporizador de vinculação.

Rotina para que se compile um endereço da pasta (etapa final): \ Etapa #016
  Se existir algum problema de compilação, retorne.
  Escreva "Gerando arquivo executável..." junto com o texto CRLF para StdOut.
  Comece o temporizador de escrita.
  Escreva o trecho EXE deste compilador para o endereço EXE completo deste compilador.
  \Se o erro do fluxo de entrada/saída não estiver em branco, apresente uma mensagem de erro contendo o erro do fluxo de entrada/saída.
  Se o erro do fluxo de entrada/saída não estiver em branco,
    Escreva o erro do fluxo de entrada/saída para StdOut.
  Suspenda o temporizador de escrita.

Rotina para que se compile um endereço da pasta (interrupção): \ Etapa #017
  Suspenda o temporizador deste compilador.
  Escreva "---------------------------------------" junto com o texto CRLF para StdOut.