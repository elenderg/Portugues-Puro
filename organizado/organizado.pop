 \ Este arquivo contém o código fonte do compilador da linguagem de programação "Português Puro"
 
Rotina para que se execute o programa:
  Inicialize os componentes.
  \Inicialize o compilador.
  Faça tudo.
  Finalize o compilador.
  Escreva na próxima linha em StdOut.
  Escreva "Operação finalizada." junto com o texto CRLF para StdOut.
  \Execute os eventos.\
  Feche o programa.

Rotina para que se faça tudo:
  Atribua 1252 a um número denominado codepage.
  Processe "kernel32.dll" "SetConsoleOutputCP" com o codepage retornando um número denominado status de erro.
  Se o status de erro for 0 [NULL], 
    Escreva "Erro ao definir o CodePage do Console para STDOUT." junto com o texto CRLF para STDOUT.
  Obtenha uma string desde os argumentos da linha de comando.
  Se a string estiver em branco, 
    Escreva "|-----------------------------------------------------------------------------------------------------------------------|" junto com o texto CRLF para StdOut;
    Escreva "| Aviso. Para utilizar este compilador, você deve invocá-lo através da linha de comando.                 |" junto com o texto CRLF para StdOut;
    Escreva "| Para fazer isso, abra compilador no Prompt de Comando (cmd.exe) usando a sintaxe abaixo       |" junto com o texto CRLF para StdOut;
    Escreva " " junto com o texto CRLF para StdOut;
    Escreva "| c:\endereço_do_compilador.exe\  c:\pasta_do_projeto_atual\                                                        |" junto com o texto CRLF para StdOut;
    Escreva " " junto com o texto CRLF para StdOut;
    Escreva "|-----------------------------------------------------------------------------------------------------------------------|" junto com o texto CRLF para StdOut;
  Retorne.
  Se o conteúdo deste caractere final desta string não for a barra invertida, 
    Acrescente a barra invertida para a string.
  Se a string não estiver no sistema de arquivos, 
    Escreva "Erro. O diretório '" junto com a string seguido de "' não foi encontrado." junto com o texto CRLF para StdOut;
    Retorne.
  Escreva "Compilando o diretório '" junto com a string seguido de "' ..." junto com o texto CRLF para StdOut. \ Etapa #0
  Escreva o texto CRLF para StdOut.
  Compile a string.
  Se existir algum problema de compilação, 
    Exiba o erro de compilação; 
    Retorne.
  Escreva "Tempo de compilação: " junto com a string deste temporizador deste compilador seguido de " ms" junto com o texto CRLF para StdOut.

Rotina para que se obtenha uma string desde os argumentos da linha de comando:
  Processe "kernel32.dll" "GetCommandLineA" 
    Retornando um endereço do caractere.
  Converta o endereço do caractere para uma string denominada argumentos.
  Lance um subtexto sobre os argumentos.
  Itere.
    Se o subtexto estiver em branco, 
      Limpe a string; 
      Retorne. 
    Se o conteúdo deste caractere inicial deste subtexto não for o caractere de espaço, 
      Adicione 1 para o caractere inicial deste subtexto; 
      Reitere.
    Atribua o subtexto para a string.
    Elimine os resíduos na string.
  \Reitere.

Rotina para que se compile um endereço da pasta:
  Compile o endereço da pasta (inicialização). \ Etapa #001
  Compile o endereço da pasta (arquivos de código fonte). \ Etapa #002
  Compile o endereço da pasta (análise dos arquivos fornecidos). \ Etapa #003
  Compile o endereço da pasta (identificação dos tipos das variáveis). \ Etapa #004
  Compile o endereço da pasta (identificação de variáveis globais). \ Etapa #005
  Compile o endereço da pasta (cabeçalhos de rotinas). \ Etapa #006
  Compile o endereço da pasta (cálculo de tamanhos e deslocamentos). \ Etapa #007
  Compile o endereço da pasta (adição de rotinas de memória incorporadas). \ Etapa #008
  Compile o endereço da pasta (catalogue as rotinas por utilização). \ Etapa #009
  Compile o endereço da pasta (conteúdo das rotinas). \ Etapa #010
  Compile o endereço da pasta (adição e compilação da rotina de inicialização). \ Etapa #011
  Compile o endereço da pasta (deslocamento de parâmetros e variáveis). \ Etapa #012
  Compile o endereço da pasta (endereço). \ Etapa #013
  Compile o endereço da pasta (transmutação). \ Etapa #014
  Compile o endereço da pasta (vinculação). \ Etapa #015
  Compile o endereço da pasta (etapa final). \ Etapa #016
  Compile o endereço da pasta (interrupção). \ Etapa #017


Rotina para que se compile um endereço da pasta (inicialização): \#001
  Escreva "Inicializando os componentes..." junto com o texto CRLF para StdOut.
  Finalize o compilador.
  Comece o temporizador deste compilador.
  Inicialize o compilador usando o endereço da pasta.
  Adicione os tipos primitivos.

Rotina para que se finalize o compilador:
  Destrua o catálogo de rotinas úteis.
  Destrua o catálogo geral de rotinas.
  Destrua o catálogo de variáveis hexadecimais.
  Destrua o catálogo de variáveis globais.
  Destrua o catálogo de tipos.
  \Destrua o catálogo de apelidos.
  Destrua as DLLs.
  Destrua as rotinas.
  Destrua os valores literais.
  Destrua as variáveis globais.
  Destrua as variáveis globais predefinidas.
  Destrua os tipos.
  Destrua os arquivos fontes.

Rotina para que se inicialize o compilador usando um endereço da pasta:
  Atribua o endereço da pasta ao endereço da pasta deste compilador.
  Atribua 0 à contagem de nomes deste compilador.
  Desative o sinalizador de erros deste compilador.
  Limpe a mensagem de erro deste compilador.
  Limpe o endereço do arquivo atual deste compilador.
  Atribua 0 ao número da linha de erro deste compilador.
  Esvazie a rotina utilizada atualmente.
  Crie o catálogo de tipos com 13001 [recipientes]. \ era 4027
  Crie o catálogo de variáveis globais com 13001 [recipientes]. \ era 4027
  Crie o catálogo de variáveis hexadecimais com 13001 [recipientes]. \ era 4027
  Crie o catálogo geral de rotinas com 13001 [recipientes]. \ era 7919
  Crie o catálogo de rotinas úteis com 13001 [recipientes]. \ era 4027

Rotina para que se adicione os tipos primitivos:
  Adicione um tipo primitivo usando "byte" e "bytes" e 1.
  Adicione um outro tipo primitivo usando "estrutura" e "estruturas" e 0.

Rotina para que se adicione um tipo primitivo usando um nome e um nome plural e uma quantidade de caracteres:
  Adicione o tipo primitivo para os tipos usando o nome e o nome plural e o nome. [do tipo primitivo]
  Atribua a quantidade de caracteres à quantidade de caracteres deste tipo primitivo.
  Atribua o tipo primitivo ao tipo base deste tipo primitivo.
  Catalogue o tipo primitivo.

Rotina para que se adicione um tipo para uns tipos usando um nome e um nome plural e um nome do tipo primitivo:
  Adicione o tipo para os tipos usando o nome e o nome plural e o nome do tipo primitivo e nil.

Rotina para que se adicione um tipo para uns tipos usando um nome e um nome plural e um nome do tipo primitivo e um endereço local:
  Crie o tipo.
  Acrescente o tipo para os tipos. \ Um tipo é uma lista duplamente encadeada
  Atribua o endereço local ao endereço local deste tipo.
  Atribua o nome ao nome deste tipo.
  Atribua o nome plural ao nome plural deste tipo.
  Atribua o nome do tipo primitivo ao nome do tipo primitivo deste tipo.

Rotina para que se crie um tipo:
  Aloque memória para o tipo.
  Atribua 0/1 à razão de escala deste tipo.
  Atribua -1 à quantidade de caracteres deste tipo.

Rotina para que se catalogue um tipo:
  Se o tipo for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Catalogue o tipo usando o nome deste tipo.

Função para que se determine se há algum problema de compilação;
Função para que se determine se existe algum problema de compilação:
  Se o sinalizador de erros deste compilador estiver ativado, diga sim.

Rotina para que se catalogue um tipo usando um nome:
  Se o tipo for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Encontre um existing tipo usando o nome e o catálogo de tipos.
  Se o existing tipo for inexistente,
    Catalogue o tipo usando o nome e o catálogo de tipos;
    Retorne.
  [Se o existing tipo já existir, então:]
  Atribua o endereço local deste tipo para um endereço local.
  Se o endereço local for inexistente, 
    Atribua o endereço local deste existing tipo ao endereço local. \ Aponta o erro para o tipo encontrado no código fonte, ao invés de um tipo gerado
  Se o endereço local não for inexistente,
    Apresente uma mensagem de erro contendo "Erro #001. Tipo: " junto com o nome seguido de "' duplicado." e o endereço local.

Rotina para que se apresente uma mensagem de erro contendo uma string e um endereço de byte:
  Se existir algum problema de compilação,
    Retorne.
  Ative o sinalizador de erros deste compilador.
  Atribua a string à mensagem de erro deste compilador.
  Encontre o endereço do arquivo atual deste compilador e o número da linha de erro deste compilador usando o endereço de byte .
  Se o endereço do arquivo atual deste compilador estiver em branco,
    Retorne.
  Extraia um nome do arquivo desde o endereço do arquivo atual deste compilador.
  Anteponha "Erro no arquivo '" junto com o nome do arquivo seguido de "'. " para a mensagem de erro deste compilador.

Rotina para que se encontre um endereço completo e um número da linha usando um endereço de byte:
  Limpe o endereço completo.
  Atribua 0 ao número da linha.
  Encontre um arquivo fonte usando o endereço de byte .
  Se o arquivo fonte for inexistente, retorne.
  Atribua o endereço completo deste arquivo fonte ao endereço completo.
  Encontre o número da linha usando o arquivo fonte e o endereço de byte .

Rotina para que se encontre um arquivo fonte usando um endereço de byte :
  Se o endereço de byte for inexistente,
    Esvazie o arquivo fonte;
    Retorne.
  Itere.
    Obtenha o arquivo fonte desde os arquivos fontes.
    Se o arquivo fonte for inexistente,
      Retorne.
    Se o endereço de byte for menor do que o caractere inicial deste trecho deste arquivo fonte,
      Reitere.
    Se o endereço de byte for maior do que o caractere final deste trecho deste arquivo fonte,
      Reitere.

Rotina para que se encontre um número da linha usando um arquivo fonte e um endereço de byte :
  Se o endereço de byte for inexistente,
    Atribua 0 ao número da linha;
    Retorne.
  Lance um subtexto sobre o trecho deste arquivo fonte.
  Atribua 1 ao número da linha.
  Itere.
    Se o subtexto estiver em branco, retorne.
    Se o caractere inicial deste subtexto for o endereço de byte , retorne.
    Se o conteúdo deste caractere inicial deste subtexto for o retorno de carro, 
      Adicione 1 para o número da linha.
    Adicione 1 para o caractere inicial deste subtexto.
  Reitere.

Rotina para que se compile um endereço da pasta (arquivos de código fonte): \#002
  Se existir algum problema de compilação, retorne.
  Escreva "Carregando arquivos..." junto com o texto CRLF para StdOut.
  Comece o temporizador de operacionalização.
  Carregue os arquivos fontes.
  Suspenda o temporizador de operacionalização.

Rotina para que se carregue uns arquivos fontes:
  Atribua ".pop" a uma extensão denominada extensão do arquivo.
  Anexe o caractere NULL após a  extensão do arquivo.
  Itere.
    Se existir algum problema de compilação, retorne.
    Obtenha um item desde o endereço da pasta deste compilador.
    Se o item não for encontrado, pare. \ Se não houver mais itens a analisar, pare.
    Se a categoria deste item não for "arquivo", reitere.
    Se a extensão deste  item não for a extensão do arquivo, reitere.
    \Se o item parece ser encadernável, reitere.
    Adicione um arquivo fonte para os arquivos fontes usando o endereço completo deste item.
    Carregue o arquivo fonte.
  Reitere.

Rotina para que se adicione um arquivo fonte para uns arquivos fontes usando um endereço completo:
  Crie o arquivo fonte.
  Acrescente o arquivo fonte para os arquivos fontes.
  Atribua o endereço completo ao endereço completo deste arquivo fonte.

Rotina para que se crie um arquivo fonte:
  Aloque memória para o arquivo fonte.

Rotina para que se carregue um arquivo fonte:
  Se o arquivo fonte for inexistente, retorne.
  \Carregue o endereço completo deste arquivo fonte para o trecho deste arquivo fonte.
  Carregue o endereço completo deste arquivo fonte para uma string. \ necessário para expandir contrações.
  Se o erro do fluxo de entrada/saída não estiver em branco,
    Apresente uma mensagem de erro contendo "Erro #002. Não foi possível carregar o arquivo: " 
      junto com o endereço completo deste arquivo fonte seguido de ".";
    Retorne.
  Parse a string para o trecho deste arquivo fonte (para expandir contrações).

Rotina para que se parse uma string para uma segunda string (para expandir contrações):
  Limpe a segunda string.
  Limpe uma terceira string.
  Lance o percorredor de contrações sobre a string.
  Itere.
    Se o segmento final deste percorredor de contrações estiver em branco, retorne.
    Posicione o segmento inicial deste percorredor de contrações sobre o segmento final deste percorredor de contrações.
    Mova o percorredor de contrações (englobando tudo).
    Se o conteúdo deste caractere inicial deste segmento inicial deste percorredor de contrações não for um byte ignorável,
      Acrescente o segmento inicial deste percorredor de contrações para a segunda string;
      Reitere.
    Acrescente o segmento inicial deste percorredor de contrações para a segunda string usando a terceira string (para expandir contrações).
    Atribua o segmento inicial deste percorredor de contrações à terceira string.
  Reitere.

Rotina para que se mova um percorredor (englobando tudo):
  Posicione o segmento inicial deste percorredor sobre o segmento final deste percorredor.
  Se o segmento final deste percorredor estiver em branco, retorne.
  \Se o conteúdo deste caractere inicial deste segmento final deste percorredor for "a",
  \ Avance o percorredor.
  \ Se o conteúdo deste caractere inicial deste segmento final deste percorredor for algum artigo indefinido,
  \ Recue o percorredor; atribua "para" para o percorredor.  
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for irrelevante,
    Mova o percorredor (ignorando os caracteres irrelevantes);
    Retorne.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for a barra invertida,
    Mova o percorredor (ignorando os comentários);
    Retorne.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for o colchete esquerdo,
    Mova o percorredor (ignorando as observações);
    Retorne.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for as aspas duplas,
    Mova o percorredor (conteúdo de texto);
    Retorne.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for o parênteses esquerdo,
    Mova o percorredor (qualificadores);
    Retorne.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for algum sinal de pontuação,
    Mova o percorredor (sinais de pontuação);
    Retorne.
  Se o percorredor estiver sobre algum possessivo inglês,
    Mova o percorredor (possessivo inglês);
    Retorne.
  Mova o percorredor (símbolos conectivos).

Rotina para que se mova um percorredor (ignorando os caracteres irrelevantes):
  [Itere.]
    Avance o percorredor.
    Se o segmento final deste percorredor estiver em branco, retorne.
    Se o conteúdo deste caractere inicial deste segmento final deste percorredor for irrelevante, reitere.

Rotina para que se mova um percorredor (ignorando os comentários):
  [Itere.]
    Avance o percorredor.
    Se o segmento final deste percorredor estiver em branco, retorne.
    Se o conteúdo deste caractere inicial deste segmento final deste percorredor não for o retorno de carro, reitere.

Rotina para que se mova um percorredor (ignorando as observações):
  [Itere.]
    Se o segmento final deste percorredor estiver em branco, retorne.
    Se o conteúdo deste caractere inicial deste segmento final deste percorredor for o retorno de carro, pare.
    Se o conteúdo deste caractere inicial deste segmento final deste percorredor for o colchete esquerdo, 
      Adicione 1 para uma contagem.
    Se o conteúdo deste caractere inicial deste segmento final deste percorredor for o colchete direito, 
      Subtraia 1 desde a contagem.
    Avance o percorredor.
    Se a contagem for 0, pare.
  Reitere.

Rotina para que se mova um percorredor (conteúdo de texto):
  [Itere.]
    Avance o percorredor.
    Se o segmento final deste percorredor estiver em branco, retorne.
    Se o conteúdo deste caractere inicial deste segmento final deste percorredor for o retorno de carro, retorne.
    Se o percorredor estiver sobre algum nested double-quote,
      Avance o percorredor;
      Reitere.
    Se o conteúdo deste caractere inicial deste segmento final deste percorredor for as aspas duplas,
      Avance o percorredor;
      Retorne.
  Reitere.

Função para que se determine se um percorredor está sobre algum nested double-quote:
  Se o segmento final deste percorredor começa com """""", diga sim.
  Diga não.

Rotina para que se mova um percorredor (qualificadores):
  [Itere.]
    Se o segmento final deste percorredor estiver em branco, retorne.
    Se o conteúdo deste caractere inicial deste segmento final deste percorredor for o retorno de carro, pare.
    Se o conteúdo deste caractere inicial deste segmento final deste percorredor for o parênteses esquerdo, 
      Adicione 1 para uma contagem.
    Se o conteúdo deste caractere inicial deste segmento final deste percorredor for o parênteses direito, 
      Subtraia 1 desde a contagem.
    Avance o percorredor.
    Se a contagem for 0, pare.
  Reitere.

Função para que se determine se um byte é algum sinal de pontuação:
  Se o byte for o ponto final, diga sim.
  Se o byte for o vírgula, diga sim.
  Se o byte for o ponto&vírgula, diga sim.
  Se o byte for o sinal de dois pontos, diga sim.
  Se o byte for o ponto de exclamação, diga sim.
  Se o byte for o ponto de interrogação, diga sim.
  Diga não.

Rotina para que se mova um percorredor (sinais de pontuação):
  Avance o percorredor.

Função para que se determine se um percorredor está sobre algum possessivo inglês:
  Se o segmento final deste percorredor estiver em branco, diga não.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor não for o single-quote byte, diga não. \ apóstrofo
  Se o percorredor estiver sobre algum possessivo inglês (tipo 1 - 's), diga sim.
  Se o percorredor estiver sobre algum possessivo inglês (tipo 2 - s'), diga sim.
  Diga não.

Função para que se determine se um percorredor está sobre algum possessivo inglês (tipo 1 - 's):
  Se o segmento final deste percorredor não começa com "'s", diga não.
  Preserve o percorredor.
  Adicione 2 para o caractere inicial deste segmento final deste percorredor.
  Se o segmento final deste percorredor estiver em branco, diga sim.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor não for um byte ignorável, diga sim.
  Diga não.

Função para que se determine se um percorredor está sobre algum possessivo inglês (tipo 2 - s'):
  Preserve o percorredor.
  Se o caractere inicial deste segmento final deste percorredor for o caractere inicial desta cópia da string original deste percorredor, diga não.
  Subtraia 1 desde o caractere inicial deste segmento final deste percorredor.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor não for o s minúsculo ou o S maiúsculo, diga não.
  Adicione 2 para o caractere inicial deste segmento final deste percorredor.
  Se o segmento final deste percorredor estiver em branco, diga sim.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor não for um byte ignorável, diga sim.
  Diga não.

Rotina para que se mova um percorredor (possessivo inglês):
  Avance o percorredor.
  Se o segmento final deste percorredor estiver em branco, retorne.
  Se o segmento final deste percorredor começa com "s", 
    Avance o percorredor.

Rotina para que se mova um percorredor (símbolos conectivos):
  [Itere.]
    Avance o percorredor.
    Se o segmento final deste percorredor estiver em branco, retorne.
    Se o percorredor estiver sobre algum possessivo inglês, retorne.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for um byte ignorável, reitere.

Rotina para que se acrescente uma string para uma segunda string usando uma terceira string (para expandir contrações):
  \contrações
  Se a string for "ao",
    Acrescente "a o" para a segunda string;
    Retorne.
  Se a string for "à",
    Acrescente "a a" para a segunda string;
    Retorne.
  Se a string for "aos",
    Acrescente "a os" para a segunda string;
    Retorne.
  Se a string for "às",
    Acrescente "a as" para a segunda string;
    Retorne.
  Se a string for "d'o",
    Acrescente "d' o" para a segunda string;
    Retorne.
  Se a string for "d'os",
    Acrescente "d' os" para a segunda string;
    Retorne.
  Se a string for "d'a",
    Acrescente "d' a" para a segunda string;
    Retorne.
  Se a string for "d'as",
    Acrescente "d' as" para a segunda string;
    Retorne.
  Se a string for "d'um",
    Acrescente "d' um" para a segunda string;
    Retorne.
  Se a string for "d'uns",
    Acrescente "d' uns" para a segunda string;
    Retorne.
  Se a string for "d'uma",
    Acrescente "d' uma" para a segunda string;
    Retorne.
  Se a string for "d'umas",
    Acrescente "d' umas" para a segunda string;
    Retorne.
  \Se a string estiver precisando ser decomposta, acrescente "de o" para a segunda string; Retorne.
  \Se a string for "dos", determine se a string precisa ser decomposta.
  \Se a string precisa ser decomposta, acrescente "de os" para a segunda string; exit
  \Se a string for "da", determine se a string precisa ser decomposta.
  \Se a string precisa ser decomposta, acrescente "de a" para a segunda string; exit
  \Se a string for "das", determine se a string precisa ser decomposta.
  \Se a string precisa ser decomposta, acrescente "de as" para a segunda string; exit
  \Se a string for "do", acrescente "de o" para a segunda string; Retorne.
  \Se a string for "da", acrescente "de a" para a segunda string; Retorne.
  \Se a string for "dos", acrescente "de os" para a segunda string; Retorne.
  \Se a string for "das", acrescente "de as" para a segunda string; Retorne.
  Se a string for "dum",
    Acrescente "de esse" para a segunda string;
    Retorne.
  Se a string for "duma",
    Acrescente "de essa" para a segunda string;
    Retorne.
  Se a string for "dumas",
    Acrescente "de esses" para a segunda string;
    Retorne.
  Se a string for "duns",
    Acrescente "de esses" para a segunda string;
    Retorne.
  Se a string for "daqui",
    Acrescente "de aqui" para a segunda string;
    Retorne.
  Se a string for "dali",
    Acrescente "de ali" para a segunda string;
    Retorne.
  Se a string for "dele",
    Acrescente "de ele" para a segunda string;
    Retorne.
  Se a string for "dela",
    Acrescente "de ela" para a segunda string;
    Retorne.
  Se a string for "desse",
    Acrescente "de esse" para a segunda string;
    Retorne.
  Se a string for "dessa",
    Acrescente "de essa" para a segunda string;
    Retorne.
  Se a string for "desses",
    Acrescente "de esses" para a segunda string;
    Retorne.
  Se a string for "dessas",
    Acrescente "de essas" para a segunda string;
    Retorne.
  Se a string for "deste",
    Acrescente "de este" para a segunda string;
    Retorne.
  Se a string for "desta",
    Acrescente "de esta" para a segunda string;
    Retorne.
  Se a string for "destes",
    Acrescente "de estes" para a segunda string;
    Retorne.
  Se a string for "destas",
    Acrescente "de estas" para a segunda string;
    Retorne.
  Se a string for "disso",
    Acrescente "de isso" para a segunda string;
    Retorne.
  Se a string for "disto",
    Acrescente "de isto" para a segunda string;
    Retorne.
  Se a string for "nesse",
    Acrescente "em esse" para a segunda string;
    Retorne.
  Se a string for "nesses",
    Acrescente "em esses" para a segunda string;
    Retorne.
  Se a string for "neste",
    Acrescente "em este" para a segunda string;
    Retorne.
  Se a string for "nestes",
    Acrescente "em estes" para a segunda string;
    Retorne.
  Se a string for "nisso",
    Acrescente "em isso" para a segunda string;
    Retorne.
  Se a string for "nisto",
    Acrescente "em isto" para a segunda string;
    Retorne.
  Se a string for "nessa",
    Acrescente "em essa" para a segunda string;
    Retorne.
  Se a string for "nessas",
    Acrescente "em essas" para a segunda string;
    Retorne.
  Se a string for "nesta",
    Acrescente "em esta" para a segunda string;
    Retorne.
  Se a string for "nestas",
    Acrescente "em estas" para a segunda string;
    Retorne.
  \Se a string for "donde", acrescente "de onde" para a segunda string; Retorne.
  \Se a string for "dentre", acrescente "de entre" para a segunda string; Retorne.
  \Se a string for "dantes", acrescente "de antes" para a segunda string; Retorne.
  Se a string for "dalguém",
    Acrescente "de alguém" para a segunda string;
    Retorne.
  Se a string for "dalgum",
    Acrescente "de um" para a segunda string;
    Retorne.
  Se a string for "dalguma",
    Acrescente "de uma" para a segunda string;
    Retorne.
  Se a string for "dalguns",
    Acrescente "de uns" para a segunda string;
    Retorne.
  Se a string for "dalgumas",
    Acrescente "de umas" para a segunda string;
    Retorne.
  Se a string for "nalgum",
    Acrescente "em um" para a segunda string;
    Retorne.
  Se a string for "nalguma",
    Acrescente "em uma" para a segunda string;
    Retorne.
  Se a string for "nalguns",
    Acrescente "em uns" para a segunda string;
    Retorne.
  Se a string for "nalgumas",
    Acrescente "em umas" para a segunda string;
    Retorne.
  Se a string for "doutro",
    Acrescente "de outro" para a segunda string;
    Retorne.
  Se a string for "doutra",
    Acrescente "de outra" para a segunda string;
    Retorne.
  Se a string for "doutros",
    Acrescente "de outros" para a segunda string;
    Retorne.
  Se a string for "doutras",
    Acrescente "de outras" para a segunda string;
    Retorne.
  Se a string for "noutro",
    Acrescente "em outro" para a segunda string;
    Retorne.
  Se a string for "noutra",
    Acrescente "em outra" para a segunda string;
    Retorne.
  Se a string for "noutros",
    Acrescente "em outros" para a segunda string;
    Retorne.
  Se a string for "noutras",
    Acrescente "em outras" para a segunda string;
    Retorne.
   \Se a string deveria ser expandida usando a terceira string (análise de termos compostos), atribua "desde" para a string; atribua "" para a segunda string; Retorne.
  Se a string for "na",
    Acrescente "em a" para a segunda string;
    Retorne.
  Se a string for "no",
    Acrescente "em o" para a segunda string;
    Retorne.
  Se a string for "nos",
    Acrescente "em os" para a segunda string;
    Retorne.
  Se a string for "nas",
    Acrescente "em as" para a segunda string;
    Retorne.
  \Se a string for "noutro", acrescente "em outro" para a segunda string; Retorne.
  \Se a string for "noutra", acrescente "em outra" para a segunda string; Retorne.
  \Se a string for "noutros", acrescente "em outros" para a segunda string; Retorne.
  \Se a string for "noutras", acrescente "em outras" para a segunda string; Retorne.
  Se a string for "num",
    Acrescente "em um" para a segunda string;
    Retorne.
  Se a string for "numa",
    Acrescente "em uma" para a segunda string;
    Retorne.
  Se a string for "nuns",
    Acrescente "em uns" para a segunda string;
    Retorne.
  Se a string for "numas",
    Acrescente "em umas" para a segunda string;
    Retorne.
  Se a string for "pelo",
    Acrescente "por o" para a segunda string;
    Retorne.
  Se a string for "pela",
    Acrescente "por a" para a segunda string;
    Retorne.
  Se a string for "pelos",
    Acrescente "por os" para a segunda string;
    Retorne.
  Se a string for "pelas",
    Acrescente "por as" para a segunda string;
    Retorne.
  Acrescente a string para a segunda string.

Rotina para que se compile um endereço da pasta (análise dos arquivos fornecidos): \#003
  Se existir algum problema de compilação, retorne.
  Escreva "Analisando o código fonte dos arquivos da pasta atual..." junto com o texto CRLF para StdOut.
  Comece o temporizador de análise/verificação.
  Examine os arquivos fontes.
  Suspenda o temporizador de análise/verificação.

Rotina para que se examine uns arquivos fontes:
  [Itere.] \ LOOP PRINCIPAL QUE FAZ O PARSING DOS ARQUIVOS
    Se existir algum problema de compilação, retorne.
    Obtenha um arquivo fonte desde os arquivos fontes.
    Se o arquivo fonte for inexistente, retorne.
    Examine o arquivo fonte.
  Reitere.

Rotina para que se examine um arquivo fonte:
  Se o arquivo fonte for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Lance um percorredor sobre o trecho deste arquivo fonte.
  Mova o percorredor (usando diretrizes de compilação).
  Itere. \ LOOP PRINCIPAL QUE EFETUA A ANÁLISE DO CONTEÚDO DOS ARQUIVOS
    Se existir algum problema de compilação, retorne.
    Se o segmento inicial deste percorredor estiver em branco, retorne.
    Se o segmento inicial deste percorredor for o início de algum tipo, \ ou seja, um artigo indefinido
      Examine um tipo usando o percorredor;
      Reitere.
    Se o segmento inicial deste percorredor for o início de alguma variável global, \ ou seja, um artigo definido
      Examine uma variável global usando o percorredor;
      Reitere.
    Se o segmento inicial deste percorredor for o início de alguma rotina, \ "Rotina" / "Função" / "Para"
      Examine uma rotina usando o percorredor;
      Reitere.
    Apresente uma mensagem de erro contendo "Erro #003. A expressão '" 
    junto com o segmento inicial deste percorredor seguido de "' não pode ser identificada corretamente. Verifique a sintaxe." e o percorredor.
  Reitere.

Rotina para que se mova um percorredor (usando diretrizes de compilação): \ talvez aqui conserte o comando "subtraia"
  [Itere.]
    Se o sinalizador de erros deste compilador estiver ativo,
       Limpe o segmento inicial deste percorredor;
       Retorne.
    Mova o percorredor retornando uma string de erro (englobando tudo).
    Se a string de erro não estiver em branco,
       Apresente uma mensagem de erro contendo a string de erro e o caractere inicial deste segmento inicial deste percorredor; \ Erro #004. 
       Retorne.
    \Se o segmento inicial deste percorredor for "del", recue o percorredor; Retorne. 
    Se o segmento inicial deste percorredor estiver em branco, retorne.
    Se o conteúdo deste caractere inicial deste segmento inicial deste percorredor for irrelevante, 
      Reitere.
    Se o conteúdo deste caractere inicial deste segmento inicial deste percorredor for a barra invertida, 
      Reitere.
    Se o conteúdo deste caractere inicial deste segmento inicial deste percorredor for o colchete esquerdo, 
      Reitere.

Rotina para que se mova um percorredor retornando uma string de erro (englobando tudo):
  Limpe a string de erro.
  Mova o percorredor (englobando tudo).
  Se o segmento inicial deste percorredor estiver em branco, retorne.
  Se o conteúdo deste caractere inicial deste segmento inicial deste percorredor for o colchete esquerdo,
    Mova o percorredor retornando a string de erro (diretrizes de validação de observações);
    Retorne.
  Se o conteúdo deste caractere inicial deste segmento inicial deste percorredor for as aspas duplas,
    Mova o percorredor retornando a string de erro (diretrizes de validação de conteúdos de texto);
    Retorne.
  Se o conteúdo deste caractere inicial deste segmento inicial deste percorredor for o parênteses esquerdo,
    Mova o percorredor retornando a string de erro (diretrizes de validação de qualificadores);
    Retorne.

Rotina para que se mova um percorredor retornando uma string de erro (diretrizes de validação de observações):
  Se a quantidade de caracteres deste segmento inicial deste percorredor for menor do que 2,
    Atribua "Erro #005. Observações devem terminar com um colchete ']'." para a string de erro;
    Retorne.
  Se o conteúdo deste caractere final deste segmento inicial deste percorredor não for o colchete direito,
    Atribua "Erro #006. Observações precisam terminar com um colchete ']'." para a string de erro;
    Retorne.

Rotina para que se mova um percorredor retornando uma string de erro (diretrizes de validação de conteúdos de texto):
  Se a quantidade de caracteres deste segmento inicial deste percorredor for menor do que 2,
    Atribua "Erro #007. Strings devem terminar com aspas duplas." para a string de erro;
    Retorne.
  Se o conteúdo deste caractere final deste segmento inicial deste percorredor não for as aspas duplas,
    Atribua "Erro #008. Strings precisam terminar com aspas duplas." para a string de erro;
    Retorne.

Rotina para que se mova um percorredor retornando uma string de erro (diretrizes de validação de qualificadores):
  Se a quantidade de caracteres deste segmento inicial deste percorredor for menor do que 2,
    Atribua "Erro #009. Qualificadores devem terminar com parêntese ')'." para a string de erro;
    Retorne.
  Se o conteúdo deste caractere final deste segmento inicial deste percorredor não for o parênteses direito,
    Atribua "Erro #010. Qualificadores precisam terminar com um parêntese ')'." para a string de erro;
    Retorne.

Função para que se determine se uma string é o início de algum tipo:
  Se a string for algum artigo indefinido, diga sim.
  Diga não.

Função para que se determine se uma string é algum artigo indefinido:
  Se a string for algum artigo indefinido português, diga sim.
  Se a string for algum pronome demonstrativo abrangente, diga sim.
  Diga não.

Função para que se determine se uma string é algum artigo indefinido português: 
  \PAL
  Se a string for "um", diga sim.
  Se a string for "uma", diga sim.
  Se a string for "uns", diga sim.
  Se a string for "umas", diga sim.
  \Se a string for "outro", diga sim.
  \Se a string for "outra", diga sim.
  \Se a string for "algum", diga sim.
  \Se a string for "alguma", diga sim.
  \Se a string for "alguns", diga sim.
  \Se a string for "algumas", diga sim.
  Se a string for algum pronome demonstrativo abrangente, diga sim. \ para funcionamento dos possessivos - local correto
  Diga não.

Função para que se determine se uma string é algum pronome demonstrativo abrangente:
  Se a string for "esse", diga sim.
  Se a string for "essa", diga sim.
  Se a string for "aquele", diga sim.
  Se a string for "aquela", diga sim.
  Se a string for "esses", diga sim.
  Se a string for "essas", diga sim.
  Se a string for "aqueles", diga sim.
  Se a string for "aquelas", diga sim.
  Se a string for "certo", diga sim.
  Se a string for "certa", diga sim.
  Se a string for "certos", diga sim.
  Se a string for "certas", diga sim.
  Se a string for "determinado", diga sim.
  Se a string for "determinada", diga sim.
  Se a string for "determinados", diga sim.
  Se a string for "determinadas", diga sim.
  Diga não.

Rotina para que se examine um tipo usando um percorredor:
  Se existir algum problema de compilação, retorne.
  \Se o segmento inicial deste percorredor for algum artigo indefinido português, 
    \Ative um sinalizador denominado sinalizador de artigo indefinido.
  Adicione o tipo para os tipos usando o caractere inicial deste segmento inicial deste percorredor.
  Mova o percorredor (usando diretrizes de compilação).
  Examine o nome deste tipo usando o percorredor.
  Atribua o nome deste tipo ao nome plural deste tipo.
  Atribua 0 para uma contagem.
  \Se o sinalizador de artigo indefinido estiver ativo,
    Pluralize o nome plural deste tipo (strings em português).\;
    \Adicione 1 à contagem.
  \Se a contagem for igual ou maior do que 2,
    \Apresente uma mensagem de erro contendo "Erro #010. não foi possível detectar o idioma desta variável" e o endereço local deste tipo;
    \Retorne.
  Se o segmento inicial deste percorredor for algum operador de atribuição de estruturas compostas,
    Examine o tipo usando o percorredor (cláusula 'tem');
    Retorne.
  Se o segmento inicial deste percorredor não for algum operador de atribuição simples,
    Apresente a mensagem de erro contendo "Erro #011. Esperado 'é/está'. Encontrado '" 
    junto com o segmento inicial deste percorredor seguido de "'." e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for algum valor numérico literal,
    Examine o tipo usando o percorredor (unidade de medida);
    Retorne.
  Se o segmento inicial deste percorredor não for algum artigo indefinido,
    Apresente a mensagem de erro contendo "Erro #012. O compilador esperava encontrar um artigo indefinido. Termo encontrado: '" 
    junto com o segmento inicial deste percorredor seguido de "'." e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine o nome do tipo primitivo deste tipo usando o percorredor.
  Examine algum dado complementar para o tipo usando o percorredor.
  Se o segmento inicial deste percorredor não for o ponto final,
    Apresente a mensagem de erro contendo "Erro #013. O compilador esperava encontrar '.' após a declaração do tipo."
    junto com o segmento inicial deste percorredor seguido de "." e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Catalogue o tipo.

Rotina para que se adicione um tipo para uns tipos usando um endereço local:
  Crie o tipo.
  Acrescente o tipo para os tipos.
  Atribua o endereço local ao endereço local deste tipo.

Rotina para que se examine um nome usando um percorredor:
  Limpe o nome.
  Se existir algum problema de compilação, retorne.
  Se o percorredor estiver sobre algum indicador de início de variável,
    Expanda o nome com o segmento inicial deste percorredor;
    Mova o percorredor (usando diretrizes de compilação).
  Itere.
    Se existir algum problema de compilação, retorne.
    Se o percorredor estiver sobre algum indicador de fim de variável, pare.
    Expanda o nome com o segmento inicial deste percorredor.
    Mova o percorredor (usando diretrizes de compilação).
  Reitere.
  Se o nome estiver em branco,
    Apresente uma mensagem de erro contendo "Erro #014. A variável '" 
    junto com o segmento inicial deste percorredor seguido de "' não foi definida ainda." e o percorredor;
    Retorne.

Função para que se determine se um percorredor está sobre algum indicador de início de variável:
  \ compare com indicador de fim de variável
  Se o segmento inicial deste percorredor for algum sinal de pontuação, diga não.
  Se o segmento inicial deste percorredor for algum símbolo, diga não.
  Se o segmento inicial deste percorredor for algum artigo, diga não.
  Se o segmento inicial deste percorredor for alguma conjunção, diga sim.
  Se o segmento inicial deste percorredor for algum possessivo inglês, diga não.
  Se o segmento inicial deste percorredor for algum verbo, diga sim.
  Se o segmento inicial deste percorredor for algum operador aritmético, diga sim.
  Se o percorredor estiver sobre alguma preposição, diga sim.
  Se o segmento inicial deste percorredor for algum qualificador, diga não.
  Se o segmento inicial deste percorredor for algum valor literal, diga não.
  Se o segmento inicial deste percorredor for uma palavra-chave de designação, diga sim.
  Se o segmento inicial deste percorredor for "então", diga sim.
  Se o segmento inicial deste percorredor for algum operador de atribuição composto, diga sim.
  Se o segmento inicial deste percorredor estiver em branco, diga não.
  Diga sim.

Função para que se determine se uma string é algum símbolo:
  Se a quantidade de caracteres desta string não for 1, diga não.
  Se o conteúdo deste caractere inicial desta string for algum símbolo, diga sim.
  Diga não.

Função para que se determine se um byte é algum símbolo: \ deveria estar no cérebro
  Se o byte for o acento circumflexo, diga sim.
  Se o byte for o barra vertical, diga sim.
  Se o byte for o asterisco, diga sim.
  Se o byte for o sinal de adição, diga sim.
  Se o byte for o hífem, diga sim.
  Se o byte for o barra inclinada, diga sim.
  Se o byte for o símbolo menor do que, diga sim.
  Se o byte for o símbolo maior do que, diga sim.
  Se o byte for a chave esquerda, diga sim.
  Se o byte for a chave direita, diga sim.
  Se o byte for o sinal de igualdade, diga sim.
  Se o byte for 128, diga sim.
  Se o byte for 130, diga sim.
  Se o byte estiver entre 132 e 137, diga sim.
  Se o byte for 139, diga sim.
  Se o byte estiver entre 145 e 153, diga sim.
  Se o byte for 155, diga sim.
  Se o byte estiver entre 161 e 180, diga sim.
  Se o byte estiver entre 183 e 191, diga sim.
  Se o byte for 215, diga sim.
  Se o byte for 247, diga sim.
  Diga não.

Função para que se determine se uma string é algum artigo:
  Se a string for algum artigo indefinido, diga sim.
  Se a string for algum artigo definido, diga sim.
  Diga não.

Função para que se determine se uma string é algum artigo definido:
  Se a string for "o", diga sim.
  Se a string for "a", diga sim.
  Se a string for "os", diga sim.
  Se a string for "as", diga sim.
  Se a string for algum pronome demonstrativo adjacente, diga sim.
  Diga não.

Função para que se determine se uma string é algum pronome demonstrativo adjacente:
  Se a string for "este", diga sim.
  Se a string for "esta", diga sim.
  Se a string for "estes", diga sim.
  Se a string for "estas", diga sim.
  Diga não.

Função para que se determine se uma string é alguma conjunção:
  \# verificar depois o uso dos termos: "ambos", "mas" e "nenhum"
  Se a string for "e", diga sim.
  Se a string for "ou", diga sim.
  Se a string for "nem", diga sim.
  \CAL
  Se a string for "neither", diga sim.
  Se a string for "nor", diga sim.
  Diga não.

Função para que se determine se uma string é algum possessivo inglês:
  Se a string for "'s", diga sim.
  Se a string for "'", diga sim.
  Diga não.

Função para que se determine se uma string é algum verbo:
  \PAL
  Se a string for "deve", diga sim.
  Se a string for "deveria", diga sim.
  Se a string for "deveriam", diga sim.
  Se a string for "devem", diga sim.
  Se a string for "estar", diga sim.
  Se a string for "ser", diga sim.
  Se a string for "for", diga sim.
  Se a string for "forem", diga sim.
  Se a string for "estiver", diga sim.
  Se a string for "estiverem", diga sim.
  Se a string for "estamos", diga sim.
  Se a string for "há", diga sim.
  Se a string for "houver", diga sim.
  Se a string for "é", diga sim.
  Se a string for "está", diga sim.
  Se a string for "são", diga sim.
  Se a string for "estão", diga sim.
  Se a string for "foi", diga sim.
  Se a string for "estava", diga sim.
  Se a string for "foram", diga sim.
  Se a string for "estavam", diga sim.
  Se a string for "será", diga sim.
  Se a string for "estará", diga sim.
  Se a string for "serão", diga sim.
  Se a string for "estarão", diga sim.
  Se a string for "existir", diga sim.
  Se a string for "existe", diga sim.
  \Se a string for "seja", diga sim.
  Se a string for "supera", diga sim.
  Se a string for "superam", diga sim.
  Se a string for "excede", diga sim.
  Se a string for "excedem", diga sim.
  Se a string for "pode", diga sim.
  Se a string for "puder", diga sim.
  Se a string for "puderem", diga sim.
  Se a string for "podem", diga sim.
  Se a string for "poderia", diga sim.
  Se a string for "poderia", diga sim.
  Se a string for "podemos", diga sim.
  Se a string for "tem", diga sim.
  Se a string for "têm", diga sim.
  Se a string for "ter", diga sim.
  Se a string for "possui", diga sim.
  Se a string for "possuem", diga sim.
  Se a string for "possuir", diga sim.
  \\ trouble makers
  Se a string for "inicia", diga sim.
  Se a string for "iniciar", diga sim.
  Se a string for "começa", diga sim.
  Se a string for "começar", diga sim.
  Se a string for "termina", diga sim.
  Se a string for "terminar", diga sim.
  Se a string for "finaliza", diga sim.
  Se a string for "finalizar", diga sim.
  Se a string for "parece", diga sim.
  Se a string for "necessita", diga sim.
  Se a string for "necessitar", diga sim.
  Se a string for "requer", diga sim.
  \\ trouble makers
  Diga não.

Função para que se determine se uma string é algum operador aritmético:
  Se a string for "mais", diga sim.
  Se a string for "menos", diga sim.
  Se a string for "vezes", diga sim.
  Se a string for "dividido", diga sim.
  Se a string for "depois", diga sim.
  Se a string for "seguido", diga sim.
  Se a string for "juntamente", diga sim.
  Se a string for "junto", diga sim.
  Se a string for "acompanhado", diga sim.
  Diga não.

Função para que se determine se um percorredor está sobre alguma preposição:
  Atribua o segmento inicial deste percorredor para um subtexto.
  Se o percorredor estiver sobre algum preposição conectiva, diga sim. \ "a" no sentido de "para"
  Se o subtexto for "a_partir_de", diga sim.
  Se o subtexto for "abaixo", diga sim.
  \Se o subtexto for "baixo", diga sim.
  Se o subtexto for "acima", diga sim.
  \Se o subtexto for "cima", diga sim.
  Se o subtexto for "ante", diga sim.
  Se o subtexto for "perante", diga sim.
  Se o subtexto for "antes", diga sim.
  Se o subtexto for "debaixo", diga sim.
  Se o subtexto for "sob", diga sim.
  Se o subtexto for "acerca", diga sim.
  Se o subtexto for "cerca", diga sim.
  Se o subtexto for "cuja", diga sim.
  Se o subtexto for "cujo", diga sim.
  Se o subtexto for "cujas", diga sim.
  Se o subtexto for "cujos", diga sim.
  \Se o subtexto for "próximo", diga sim.
  Se o subtexto for "perto", diga sim.
  Se o subtexto for "com", diga sim.
  \Se o subtexto for "contendo", diga sim.
  Se o subtexto for "como", diga sim.
  Se o subtexto for "contra", diga sim.
  Se o subtexto for "dada", diga sim.
  Se o subtexto for "dado", diga sim.
  Se o subtexto for "dando", diga sim.
  Se o subtexto for "gerando", diga sim.
  Se o subtexto for "resultando", diga sim.
  Se o subtexto for "retornando", diga sim.
  Se o subtexto for "desde", diga sim.
  Se o subtexto for "depois", diga sim.
  Se o subtexto for "após", diga sim.
  Se o subtexto for "durante", diga sim.
  Se o subtexto for "em", diga sim.
  Se o subtexto for "entre", diga sim.
  Se o subtexto for "dentre", diga sim.
  Se o subtexto for "até", diga sim.
  \Se o subtexto for "que", diga sim.
  \Se o subtexto for "esquerda", diga sim.
  Se o subtexto for "mediante", diga sim.
  Se o subtexto for "para", diga sim.
  Se o subtexto for "via", diga sim.
  Se o subtexto for "segundo", diga sim.
  Se o subtexto for "acordo", diga sim.
  Se o subtexto for "sem", diga sim.
  Se o subtexto for "então", diga sim.
  Se o subtexto for "sobre", diga sim.
  Se o subtexto for "usando", diga sim.
  Se o subtexto for "versus", diga sim.
  Se o subtexto for "enquanto", diga sim.
  Se o subtexto for "aproximadamente", diga sim.
  Se o subtexto for "através", diga sim.
  Se o subtexto for "algum", diga sim.
  Se o subtexto for "sob", diga sim.
  Se o subtexto for "debaixo", diga sim.
  Se o subtexto for "entre", diga sim.
  \Se o subtexto for "baixo", diga sim. -> erro
  Se o subtexto for "por", diga sim.
  Se o subtexto for "usando", diga sim.
  Se o subtexto for "referente", diga sim.
  Se o subtexto for "pertencente", diga sim.
  Se o subtexto for "pertinente", diga sim.
  Se o subtexto for "relativo", diga sim.
  Se o subtexto for "relativa", diga sim.
  Se o subtexto for "concernente", diga sim.
  Se o subtexto for "atinente", diga sim.
  Se o subtexto for "pertinente", diga sim.
  Se o subtexto for "retornando", diga sim.
  Se o subtexto for "começando", diga sim.
  Se o subtexto for "começando", diga sim.
  Se o subtexto for "iniciando", diga sim.
  Se o subtexto for "usando", diga sim.
  Se o subtexto for "via", diga sim.
  Se o subtexto for "com", diga sim.
  Se o subtexto for "aproada", diga sim.
  Se o subtexto for "aproado", diga sim.
  Se o subtexto for "aproando", diga sim.
  Se o subtexto for "orientada", diga sim.
  Se o subtexto for "orientado", diga sim.
  Se o subtexto for "orientando", diga sim.
  Se o subtexto for "orientando-se", diga sim.
  Se o subtexto for "voltada", diga sim.
  Se o subtexto for "voltado", diga sim.
  Se o subtexto for "virada", diga sim.
  Se o subtexto for "virado", diga sim.
  Se o subtexto for "virando", diga sim.
  Se o subtexto for "virando-se", diga sim.
  Se o subtexto for "tão", diga sim.
  Se o subtexto for "tanto", diga sim.
  Se o subtexto for "quanto", diga sim.
  Se o subtexto for "quão", diga sim.
  Se o subtexto for "after", diga sim.
  Se o subtexto for "regressivamente", diga sim.
  Se o subtexto for "dentro de", diga sim.
  Se o subtexto for "dentro", diga sim.
  Se o subtexto for "parecida", diga sim.
  Se o subtexto for "parecido", diga sim.
  Se o subtexto for "semelhante", diga sim.
  Se o subtexto for "similar", diga sim.
  Se o subtexto for "em comprimento", diga sim.
  Se o subtexto for "d'", diga sim.
  Se o subtexto for "d'", diga sim.
  Se o subtexto for "só", diga sim.
  Se o subtexto for "somente", diga sim.
  Se o subtexto for "unicamente", diga sim.
  Se o subtexto for "exclusivamente", diga sim.
  Se o subtexto for "apenas", diga sim.
  Se o subtexto for "fora", diga sim.
  Se o subtexto for "menores", diga sim.
  Se o subtexto for "alta", diga sim.
  Se o subtexto for "alto", diga sim.
  Se o subtexto for "comprido", diga sim.
  Se o subtexto for "comprida", diga sim.
  Se o subtexto for "largo", diga sim.
  Se o subtexto for "larga", diga sim.
  Diga não.

Função para que se determine se uma string é algum qualificador:
  Se a string estiver em branco, diga não.
  Se o conteúdo deste caractere inicial desta string for o parênteses esquerdo, diga sim.
  Diga não.

Função para que se determine se uma string é algum valor literal:
  Se a string for algum ponteiro literal, diga sim.
  Se a string for algum valor numérico literal, diga sim.
  Se a string for algum string literal, diga sim.
  \Se a string for algum sinalizador literal, diga sim. ***
  Se a string for algum valor hexadecimal literal, diga sim.
  Diga não.

Função para que se determine se uma string é uma palavra-chave de designação:
  Se a string for "chamado", diga sim.
  Se a string for "chamados", diga sim.
  Se a string for "chamada", diga sim.
  Se a string for "chamadas", diga sim.
  Se a string for "denominado", diga sim.
  Se a string for "denominados", diga sim.
  Se a string for "denominada", diga sim.
  Se a string for "denominadas", diga sim.
  Diga não.

Função para que se determine se uma string é algum operador de atribuição composto:
  Se a string for "igual", diga sim.
  Diga não.

Rotina para que se expanda uma string com uma segunda string:
  Se a segunda string estiver em branco, retorne.
  Se a string não estiver em branco, 
    Acrescente o caractere de espaço para a string.
  Acrescente a segunda string para a string.

Função para que se determine se um percorredor está sobre algum indicador de fim de variável:
  \ compare com indicador de início de variável
  Se o segmento inicial deste percorredor for algum sinal de pontuação, diga sim.
  Se o segmento inicial deste percorredor for algum símbolo, diga sim.
  Se o segmento inicial deste percorredor for algum artigo, diga sim.
  Se o segmento inicial deste percorredor for alguma conjunção, diga sim.
  Se o segmento inicial deste percorredor for algum possessivo inglês, diga sim.
  Se o percorredor estiver sobre algum possessivo reverso, diga sim. \ 
  Se o segmento inicial deste percorredor for algum verbo, diga sim.
  Se o segmento inicial deste percorredor for algum operador aritmético, diga sim.
  Se o percorredor estiver sobre alguma preposição, diga sim.
  Se o segmento inicial deste percorredor for algum qualificador, diga sim.
  Se o segmento inicial deste percorredor for algum valor literal, diga sim.
  Se o segmento inicial deste percorredor for uma palavra-chave de designação, diga sim.
  Se o segmento inicial deste percorredor for "então", diga sim.
  Se o segmento inicial deste percorredor for algum operador de atribuição composto, diga sim.
  Se o segmento inicial deste percorredor estiver em branco, diga sim.
  Se o segmento inicial deste percorredor for algum advérbio de negação, diga sim.
  Diga não.

Função para que se determine se um percorredor está sobre algum possessivo reverso:
  Preserve o percorredor.
  Se o segmento inicial deste percorredor não for "de", diga não.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for algum pronome demonstrativo, diga sim.
  Diga não.

Função para que se determine se uma string é algum pronome demonstrativo:
  Se a string for algum pronome demonstrativo adjacente, diga sim.
  Se a string for algum pronome demonstrativo abrangente, diga sim.
  Diga não.

Rotina para que se pluralize uma string (strings em português):
  Lance um percorredor sobre a string.
  Itere.
    Mova o percorredor (usando diretrizes de compilação).
    Se o segmento inicial deste percorredor estiver em branco, pare.
    Se uma string plural não estiver em branco,
      Acrescente " " para a string plural.
    Acrescente o segmento inicial deste percorredor para a string plural.
    Se o segmento inicial deste percorredor for "de",
      Ative um sinalizador;
      Reitere. \ PLURAL
    Se o sinalizador não estiver ativo, 
      Pluralize a string plural (português - regras comuns) .
  Reitere.
  Atribua a string plural à string.

Rotina para que se pluralize uma string (português - regras comuns) :
  \# https://www.normaculta.com.br/singular-e-plural/
  \# palavras que são exceções às regras
  \Se a string for "caráter",
    \Atribua "carateres" à string;
    \Retorne.
  Se a string for "júnior",
    Atribua "juniores" à string;
    Retorne.
  Se a string for "sênior",
    Atribua "seniores" à string;
    Retorne.
  \# advérbios principais
  Se a string for "muito", retorne.
  Se a string for "pouco", retorne.
  Se a string for "mais", retorne.
  Se a string for "menos", retorne.
  Se a string for "bastante", retorne.
  Se a string for "quase", retorne.
  Se a string for "demais", retorne.
  Se a string for "bem", retorne.
  Se a string for "deveras", retorne.
  Se a string for "mal", retorne.
  Se a string for "melhor", retorne.
  Se a string for "pior", retorne.
  \# palavras terminadas com "ão"
  Se a string termina com "ão",
    Pluralize a string (terminada com "ão");
    Retorne.
  \# palavras terminadas com "d"
  Se a string termina com "d",
    Pluralize a string (terminada com outras letras);
    Retorne.
  \# palavras terminadas com "l"
  Se a string termina com "l",
    Pluralize a string (terminada com "l");
    Retorne.
  \# palavra terminadas com "m"
  Se a string termina com "m",
    Remova o último caractere desde a string;
    Acrescente "ns" para a string;
    Retorne.
  \# palavra terminadas com "n" (essa regra é preferível porque mantém o acento da palavra, se houver)
  Se a string termina com "n",
    Acrescente "es" para a string;
    Retorne.
  \# palavras terminadas com "r"
  Se a string termina com "r",
    Pluralize a string (terminada com "r");
    Retorne.
  \# palavras terminadas com "s"
  Se a string termina com "s",
    Pluralize a string (terminada com "s");
    Retorne.
  \# palavras terminadas com "t"
  Se a string termina com "t",
    Pluralize a string (terminada com outras letras);
    Retorne.
  \# palavra terminadas com "x"
  Se a string termina com "x",
    Pluralize a string (terminada com "x");
    Retorne.
  \# palavras terminadas com "z"
  Se a string termina com "z",
    Pluralize a string (terminada com "z");
    Retorne.
  Se a string termina com "#",
    Acrescente "s" para a string;
    Retorne.
  Se a string não termina com alguma vogal ou com alguma consoante,
    Acrescente "s" para a string;
    Retorne.
  \# regra padrão
  [Caso contrário,]
  Acrescente "s" para a string. \ Só acrescenta o "s" caso nenhuma das condições acima tenha siddo correspondida.
  \Volte.

Rotina para que se pluralize uma string (terminada com "ão"):
  \A formação do plural dos substantivos terminados -ão pode ser feita de três formas distintas: -ões, -ãos, -ães.
  \Alguns substantivos terminados em -ão admitem duas (ou até três) formas no plural:
  \refrão - refrãos ou refrães;
  \corrimão - corrimões ou corrimãos;
  \guardião - guardiões ou guardiães;
  \vilão - vilões, vilãos ou vilães.
    \TODOS os substantivos paroxítonos terminados em -ão formam o plural com -ãos.
  \ALGUNS substantivos oxítonos também têm o seu plural formado segundo essa regra:
  \órfão - órfãos;
  \sótão - sótãos;
  \órgão - órgãos;
  \cidadão - cidadãos;
  \irmão - irmãos;
  \cristão - cristãos.
  Se a string for "cidadão",
    Acrescente "s" para a string;
    Retorne.
  Se a string for "irmão",
    Acrescente "s" para a string;
    Retorne.
  Se a string for "cristão",
    Acrescente "s" para a string;
    Retorne.
  Se a string for "refrão",
    Acrescente "s" para a string;
    Retorne.
  Se a string for "mão",
    Acrescente "s" para a string;
    Retorne.
  Se a string for "são",
    Acrescente "s" para a string;
    Retorne.
  \-ão no singular para -ães no plural:
  \Alguns substantivos terminados em -ão formam o plural com -ães.
  Se a string for "pão",
    Remova o último caractere desde a string;
    Acrescente "es" para a string;
    Retorne.
  Se a string for "capitão",
    Remova o último caractere desde a string;
    Acrescente "es" para a string;
    Retorne.
  Se a string for "alemão",
    Remova o último caractere desde a string;
    Acrescente "es" para a string;
    Retorne.
  Se a string for "charlatão",
    Remova o último caractere desde a string;
    Acrescente "es" para a string;
    Retorne.
  Lance um subtexto sobre a string.
  Subtraia 2 desde o caractere final deste subtexto.   \ remova o "ão". Acho que não precisa
  \caso encontre acentos em sílabas prévias, faça o seguinte
  Se o subtexto possui alguma vogal acentuada,
    Acrescente "s" para a string;
    Retorne. \-> exemplo: órgão
  \# regra padrão
  \A maioria dos substantivos terminados em -ão forma o plural com -ões:
  \opinião - opiniões;
  \coração - corações;
  \eleição - eleições.
  Remova os dois últimos caracteres desde a string. Acrescente "ões" para a string.\ Retorne.

Rotina para que se pluralize uma string (terminada com outras letras):
  Acrescente "s" para a string. \ Retorne.

Rotina para que se pluralize uma string (terminada com "l"):
  \# palavras terminadas com "al"
  Se a string termina com "al",
    Pluralize a string (terminada com "al");
    Retorne. \ MAL -> MALES
  \# palavras terminadas com "el"
  Se a string termina com "el",
    Pluralize a string (terminada com "el");
    Retorne. \PASTEL - PASTÉIS
  \# palavras terminadas com "il"
  Se a string termina com "il",
    Pluralize a string (terminada com "il");
    Retorne. \-> FUZIL -> FUZIS
  \# palavras terminadas com "ol"
  Se a string termina com "ol",
    Pluralize a string (terminada com "ol");
    Retorne. \- LENÇOL -> LENÇÓIS
  \# palavras terminadas com "ul"
  Se a string termina com "ul",
    Pluralize a string (terminada com "ul");
    Retorne. \ AZUL -> AZUIS \ Cônsul - cônsules
  [Caso a string seja uma sigla, tipo URL]
  Acrescente "s" para a string. \ Retorne.

Rotina para que se pluralize uma string (terminada com "al"):
  Se a string for "mal",
    Atribua "males" para a string;
    Retorne.
  Remova o último caractere desde a string. \remova a letra L
  Acrescente "is" para a string. \ Retorne.

Rotina para que se pluralize uma string (terminada com "el"):
  \Se a string for "pixel", atribua "pixels" para a string; Retorne.
  \# acentos em sílabas prévias
  Lance um subtexto sobre a string.
  Subtraia 2 desde o caractere final deste subtexto. \ remova o el
  Se o subtexto possui alguma vogal acentuada,
    Remova o último caractere desde a string;
    Acrescente "is" para a string;
    Retorne.
  Remova os dois últimos caracteres desde a string.
  Acrescente "éis" para a string. \ Retorne.

Rotina para que se pluralize uma string (terminada com "il"):
  \Se a string for "canil", atribua "canis" para a string; Retorne.
  \Se a string for "covil", atribua "covis" para a string; Retorne.
  \Se a string for "funil", atribua "funis" para a string; Retorne.
  \Se a string for "barril", atribua "barris" para a string; Retorne.
  \Se a string for "fuzil", atribua "fuzis" para a string; Retorne.
  \Se a string for "redil", atribua "redis" para a string; Retorne.
  \# acentos em sílabas prévias
  Lance um subtexto sobre a string.
  Subtraia 2 desde o caractere final deste subtexto.
  Se o subtexto possui alguma vogal acentuada,
    Remova os dois últimos caracteres desde a string;
    Acrescente "eis" para a string;
    Retorne.
  Remova o último caractere desde a string. \ remova a letra L
  Acrescente "s" para a string. \ Retorne.

Rotina para que se pluralize uma string (terminada com "ol"):
  \# acentos em sílabas prévias
  Lance um subtexto sobre a string.
  Subtraia 2 desde o caractere final deste subtexto.
  Se o subtexto possui alguma vogal acentuada,
    Remova o último caractere desde a string;
    Acrescente "is" para a string;
    Retorne.
  Remova os dois últimos caracteres desde a string.
  Acrescente "óis" para a string. \ Retorne.

Rotina para que se pluralize uma string (terminada com "ul"):
  Se a string for "cônsul",
    Atribua "cônsules" à string;
    Retorne.
  Remova o último caractere desde a string. \ remova o L
  Acrescente "is" para a string. \ Retorne.

Rotina para que se pluralize uma string (terminada com "r"):
  \# acentos em sílabas prévias
  Lance um subtexto sobre a string.
  Subtraia 2 desde o caractere final deste subtexto.
  Se o subtexto possui alguma vogal acentuada,
    Acrescente "es" para a string;
    Retorne.
  \# hiatos
  Se a string termina com "air",
    Remova os dois últimos caracteres desde a string;
    Acrescente "íres" para a string;
    Retorne.
  Se a string termina com "aur",
    Remova os dois últimos caracteres desde a string;
    Acrescente "úres" para a string;
    Retorne.
  \# regra padrão
  Acrescente "es" para a string. \ Retorne.

Rotina para que se pluralize uma string (terminada com "s"):
\Quando os substantivos terminados em -s são paroxítonos, a formação do plural fica invariável:.
  \# proparoxítonas/paroxítonas terminadas com "as", "es", "os"
  Se a string termina com "as",
    Acrescente "es" para a string;
    Retorne. \atlas
  Se a string termina com "es",
      Acrescente "es" para a string;
    Retorne. \atlas
  Se a string termina com "os",
      Acrescente "es" para a string;
    Retorne. \atlas
  \# hiatos acentuados
  Se a string termina com "aís",
    Acrescente "es" para a string;
    Retorne.
  Se a string termina com "aús",
    Acrescente "es" para a string;
    Retorne.
  \# oxítonas terminadas com "ás", "âs", "és", "ês", "ís", "ós", "ôs", "ús"
  Se a string termina com "ás",
    Remova os dois últimos caracteres desde a string;
    Acrescente "ases" para a string;
    Retorne.
  Se a string termina com "âs",
    Remova os dois últimos caracteres desde a string;
    Acrescente "ases" para a string;
    Retorne.
  Se a string termina com "és",
    Remova os dois últimos caracteres desde a string;
    Acrescente "eses" para a string;
    Retorne.
  Se a string termina com "ês",
    Remova os dois últimos caracteres desde a string;
    Acrescente "eses" para a string;
    Retorne.
  Se a string termina com "ís",
    Remova os dois últimos caracteres desde a string;
    Acrescente "ises" para a string;
    Retorne.
  Se a string termina com "ós",
    Remova os dois últimos caracteres desde a string;
    Acrescente "oses" para a string;
    Retorne.
  Se a string termina com "ôs",
    Remova os dois últimos caracteres desde a string;
    Acrescente "oses" para a string;
    Retorne.
  Se a string termina com "ús",
    Remova os dois últimos caracteres desde a string;
    Acrescente "uses" para a string;
    Retorne.
  \# palavras terminadas com "is", "us"
  Se a string termina com "is",
    Pluralize a string (terminada com "is" ou com "us");
    Retorne.
  Se a string termina com "us",
    Pluralize a string (terminada com "is" ou com "us");
    Retorne. \ônibus / vírus
  \Se a string termina com "ts", exit.
  \# regra padrão
  Acrescente "es" para a string. \ Retorne.

Rotina para que se pluralize uma string (terminada com "is" ou com "us"):
  \# acentos em sílabas prévias
  Lance um subtexto sobre a string.
  Subtraia 2 desde o caractere final deste subtexto.
  Se o subtexto possui alguma vogal acentuada, retorne.
  \# hiatos
  Se a string termina com "ais",
    Remova os dois últimos caracteres desde a string;
    Acrescente "íses" para a string;
    Retorne. \cais não varia....
  Se a string termina com "aus",
    Remova os dois últimos caracteres desde a string;
    Acrescente "úses" para a string;
    Retorne.
  \# regra padrão
  Acrescente "es" para a string. \ Retorne.

Rotina para que se pluralize uma string  (terminada com "x"):
  \Se a string for "px",
    \acrescente "pxs" para a string;
    \Retorne.
  Se a string for "fax",
    Acrescente "es" para a string;
    Retorne.
  Acrescente "s" para a string. \ tratamento de exceções
   \ Retorne.

Rotina para que se pluralize uma string (terminada com "z"):
  \# hiatos acentuados
  Se a string termina com "aíz",
    Acrescente "es" para a string;
    Retorne.
  Se a string termina com "aúz",
    Acrescente "es" para a string;
    Retorne.
  \# palavras terminas em "áz", "âz", "éz", "êz", "íz", "óz", "ôz", "úz"
  Se a string termina com "áz",
    Remova os dois últimos caracteres desde a string;
    Acrescente "azes" para a string;
    Retorne.
  Se a string termina com "âz",
    Remova os dois últimos caracteres desde a string;
    Acrescente "azes" para a string;
    Retorne.
  Se a string termina com "éz",
    Remova os dois últimos caracteres desde a string;
    Acrescente "ezes" para a string;
    Retorne.
  Se a string termina com "êz",
    Remova os dois últimos caracteres desde a string;
    Acrescente "ezes" para a string;
    Retorne.
  Se a string termina com "íz",
    Remova os dois últimos caracteres desde a string;
    Acrescente "izes" para a string;
    Retorne.
  Se a string termina com "óz",
    Remova os dois últimos caracteres desde a string;
    Acrescente "ozes" para a string;
    Retorne.
  Se a string termina com "ôz",
    Remova os dois últimos caracteres desde a string;
    Acrescente "ozes" para a string;
    Retorne.
  Se a string termina com "úz",
    Remova os dois últimos caracteres desde a string;
    Acrescente "uzes" para a string;
    Retorne.
  \# acentos em sílabas prévias
  Lance um subtexto sobre a string.
  Subtraia 2 desde o caractere final deste subtexto.
  Se o subtexto possui alguma vogal acentuada,
    Acrescente "es" para a string;
    Retorne.
  \# hiatos
  Se a string termina com "aiz",
    Remova os dois últimos caracteres desde a string;
    Acrescente "ízes" para a string;
    Retorne.
  Se a string termina com "auz",
    Remova os dois últimos caracteres desde a string;
    Acrescente "úzes" para a string;
    Retorne.
  \# regra padrão
  Acrescente "es" para a string. \ Retorne.

Rotina para que se pluralize uma string:
  Lance um percorredor sobre a string.
  Itere.
    Mova o percorredor (usando diretrizes de compilação).
    Se o segmento inicial deste percorredor estiver em branco, pare.
    Se uma string plural não estiver em branco, acrescente " " para a string plural.
    Acrescente o segmento inicial deste percorredor para a string plural.
    Se o segmento inicial deste percorredor for "de",
      Ative um sinalizador;
      Reitere. \ PLURAL
    Se o sinalizador não estiver ativo, 
      Pluralize a string plural (português - regras comuns).
  Reitere.
  Atribua a string plural à string.

Rotina para que se examine um tipo usando um percorredor (cláusula 'tem'):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Atribua "estrutura" ao nome do tipo primitivo deste tipo.
  Examine os campos deste tipo usando o percorredor.
  Se o segmento inicial deste percorredor não for o ponto final,
    Apresente uma mensagem de erro contendo "Erro #015. Esperado '.' no final da estrutura. Encontrado '" 
    junto com o segmento inicial deste percorredor seguido de "'." e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Catalogue o tipo.

Rotina para que se examine uns campos usando um percorredor:
  [Itere.]
    Se existir algum problema de compilação, retorne.
    Adicione um campo para os campos usando "campo" e o caractere inicial deste segmento inicial deste percorredor.
    Examine o campo usando o percorredor.
    Se o segmento inicial deste percorredor não for alguma pausa, retorne.
    Examine algum pauses usando o percorredor.
  Reitere.

Rotina para que se adicione uma variável para umas variáveis usando um categoria e um endereço local:
  Crie a variável usando a categoria.
  Acrescente a variável para as variáveis.
  Atribua o endereço local ao endereço local desta variável.

Rotina para que se crie uma variável usando um categoria:
  Aloque memória para a variável.
  Atribua a categoria à categoria desta variável.
  Atribua 1 à contagem desta variável.

Rotina para que se examine um campo usando um percorredor:
  Se existir algum problema de compilação, retorne.
  Examine o campo usando o percorredor (tipo geral).
  Itere.
    Se existir algum problema de compilação, retorne.
    Se o segmento inicial deste percorredor for uma palavra-chave de designação,
      Examine o campo usando o percorredor (cláusula designadora);
      Reitere.
    Se o segmento inicial deste percorredor for "sob",
      Examine o campo usando o percorredor (cláusula de redefinição);
      Reitere.
    \Se o segmento inicial deste percorredor for "equivalente a", 
      \ Examine o campo usando o percorredor (cláusula de redefinição); 
      \ Reitere.
    \Se o segmento inicial deste percorredor for "análogo a", 
      \ Examine o campo usando o percorredor (cláusula de redefinição); 
      \ Reitere.
    \Se o segmento inicial deste percorredor for "análoga a",
      \Examine o campo usando o percorredor (cláusula de redefinição); 
      \ Reitere.
    Se o segmento inicial deste percorredor for "em",
      Examine o campo usando o percorredor (cláusula de redefinição);
      Reitere.
    \Se o segmento inicial deste percorredor for "sob",
      \Examine o campo usando o percorredor (cláusula de redefinição);
      \Reitere.
    Se o segmento inicial deste percorredor for "sobre",
      Examine o campo usando o percorredor (cláusula de redefinição);
      Reitere.
    Se o segmento inicial deste percorredor for uma palavra-chave de referenciamento,
      Examine o campo usando o percorredor (cláusula de referência);
      Reitere.
  [Caso nenhuma condição acima seja satisfeita, pare (sai do loop)]

Rotina para que se examine um campo usando um percorredor (tipo geral):
  Se existir algum problema de compilação, retorne.
  Se o segmento inicial deste percorredor for algum valor numérico literal,
    Examine o campo usando o percorredor (tipo: array de bytes);
    Retorne.
  Examine o campo usando o percorredor (tipo normal).

Rotina para que se examine um campo usando um percorredor (tipo: array de bytes):
  Se existir algum problema de compilação, retorne.
  Converta o segmento inicial deste percorredor para uma proporção.
  Reduza a proporção.
  Se o denominador desta proporção não for 1,
    Apresente uma mensagem de erro contendo "Erro #016. Erro de sintaxe. Arrays devem possuir tamanhos não fracionários." e o percorredor;
    Retorne.
  Atribua o numerador desta proporção à contagem deste campo.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for "byte" ou "bytes",
    Apresente a mensagem de erro contendo "Erro #017. Erro de sintaxe. É necessário escrever a palavra 'bytes' após informar a quantidade correspondente." e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Atribua "byte" ao nome do tipo deste campo.

Rotina para que se examine um campo usando um percorredor (tipo normal):
  Se existir algum problema de compilação, retorne.
  Se o segmento inicial deste percorredor não for algum artigo indefinido,
    Apresente uma mensagem de erro contendo "Erro #018. Erro de sintaxe. Esperado 'um/uma'. Encontrado: '" 
    junto com o segmento inicial deste percorredor seguido de "'." e o percorredor;
    Retorne.
  \Se o segmento inicial deste percorredor for "outra", 
    \Atribua "outra" ao nome deste campo.
  \Se o segmento inicial deste percorredor for "outras", 
    \Atribua "outras" ao nome deste campo.
  \Se o segmento inicial deste percorredor for "outro", 
    \Atribua "outro" ao nome deste campo.
  \Se o segmento inicial deste percorredor for "outros", 
    \Atribua "outros" ao nome deste campo.
  Se o segmento inicial deste percorredor for "segundo", 
    Atribua "segundo" ao nome deste campo.
  Se o segmento inicial deste percorredor for "segundos", 
    Atribua "segundos" ao nome deste campo.
  Se o segmento inicial deste percorredor for "segunda", 
    Atribua "segunda" ao nome deste campo.
  Se o segmento inicial deste percorredor for "segundas", 
    Atribua "segundas" ao nome deste campo.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Expanda o nome deste campo com o nome.

Rotina para que se examine um campo usando um percorredor (cláusula designadora):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o nome do tipo deste campo estiver em branco, 
    Atribua o nome deste campo ao nome do tipo deste campo. \ byte array type name already filled in
  Examine o nome deste campo usando o percorredor.

Rotina para que se examine um campo usando um percorredor (cláusula de redefinição):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum artigo definido,
    Apresente uma mensagem de erro contendo "Erro #019. Sintaxe incorreta. Esperado 'o/a'. Encontrado: '" 
    junto com o segmento inicial deste percorredor seguido de "'." e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine o novo nome deste campo usando o percorredor.

Função para que se determine se uma string é uma palavra-chave de referenciamento:
  Se a string for "(referência)", diga sim.
  Diga não.

Rotina para que se examine um campo usando um percorredor (cláusula de referência):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Ative o sinalizador de referência deste campo.

Função para que se determine se uma string é alguma pausa:
  Se a string for "e", diga sim.
  Se a string for "ou", diga sim.
  \default
  Se a string for ",", diga sim.
  Se a string for ";", diga sim.
  Diga não.

Rotina para que se examine algum pauses usando um percorredor:
  [Itere.]
    Se existir algum problema de compilação, retorne.
    Se o segmento inicial deste percorredor não for alguma pausa, retorne.
    Mova o percorredor (usando diretrizes de compilação).
  Reitere.

Rotina para que se examine um tipo usando um percorredor (unidade de medida):
  Se existir algum problema de compilação, retorne.
  Converta o segmento inicial deste percorredor para a razão de escala deste tipo.
  Se a razão de escala deste tipo for 0,
    Apresente uma mensagem de erro contendo "Erro #020. O valor 0 não é permitido como razão de escala." e o endereço local deste tipo;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine o nome do tipo primitivo deste tipo usando o percorredor.
  Se o segmento inicial deste percorredor não for o ponto final,
    Apresente a mensagem de erro contendo "Erro #021. Necessário um '.' no fim desta fração. Encontrado: '" 
    junto com o segmento inicial deste percorredor seguido de "'." e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Catalogue o tipo.

Função para que se determine se uma string é o início de alguma variável global:
  Se a string for algum artigo definido, diga sim.
  Diga não.

Rotina para que se examine uma variável global usando um percorredor:
  Se existir algum problema de compilação, retorne.
  Adicione a variável global para as variáveis globais usando "global" e o caractere inicial deste segmento inicial deste percorredor.
  Mova o percorredor (usando diretrizes de compilação).
  Examine o nome desta variável global usando o percorredor.
  Se o segmento inicial deste percorredor for algum operador de atribuição de estruturas compostas,
    Examine a variável global usando o percorredor (cláusula 'tem');
    Retorne.
  Se o segmento inicial deste percorredor não for algum operador de atribuição simples,
    Apresente uma mensagem de erro contendo "Erro #022. Erro de sintaxe. Esperado: 'é/está'. Encontrado: '" 
    junto com o segmento inicial deste percorredor seguido de "'." e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum artigo indefinido,
    Examine a variável global usando o percorredor (literal termo);
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine o nome do tipo desta variável global usando o percorredor.
  Se o segmento inicial deste percorredor for o início de algum dado complementar,
    Examine a variável global usando o percorredor (dados complementares);
    Retorne.
  Se o segmento inicial deste percorredor for algum operador de atribuição composto,
    Examine a variável global usando o percorredor (data part);
    Retorne.
  Se o segmento inicial deste percorredor não for o ponto final,
    Apresente a mensagem de erro contendo "023. Erro de sintaxe. Declaração de variáveis globais devem terminar com um '.'" e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Catalogue a variável global.

Função para que se determine se uma string é algum operador de atribuição de estruturas compostas:
  Se a string for "tem", diga sim.
  Se a string for "têm", diga sim.
  Se a string for "contém", diga sim.
  Se a string for "contêm", diga sim.
  \Se a string for "possui", diga sim.
  Diga não.

Rotina para que se examine uma variável global usando um percorredor (cláusula 'tem'):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Atribua "~inline " junto com o nome desta variável global seguido de " tipo" para um nome. \ 
  Atribua o nome seguido de "s" para um nome plural. \ PLURAL - mudar aqui
  Adicione um tipo para os tipos usando o nome e o nome plural e "estrutura" e o endereço local desta variável global. \ mudar aqui
  Catalogue o tipo.
  Atribua o nome deste tipo ao nome do tipo desta variável global.
  Examine os campos deste tipo usando o percorredor.
  Se o segmento inicial deste percorredor não for o ponto final,
    Apresente uma mensagem de erro contendo "Erro #023. Erro de sintaxe. Necessário inserir um '.' ao final de declarações de estruturas" e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Catalogue a variável global.

Rotina para que se catalogue uma variável global:
  Se existir algum problema de compilação, retorne.
  Se a variável global for inexistente, retorne.
  Se o nome desta variável global estiver no catálogo de variáveis globais,
    Apresente uma mensagem de erro contendo "Erro #024. O identificador '" 
    junto com o nome desta variável global seguido de "' já foi definido anteriormente como variável global." e o endereço local desta variável global;
    Retorne.
  Catalogue a variável global usando o nome desta variável global e o catálogo de variáveis globais.

Função para que se determine se uma string é algum operador de atribuição simples:
  Se a string for "é", diga sim.
  Se a string for "está", diga sim.
  Se a string for "são", diga sim.
  Se a string for "estão", diga sim.
  Se a string for "estamos", diga sim.
  Se a string for "for", diga sim.
  Se a string for "forem", diga sim.
  Se a string for "estiverem", diga sim.
  Se a string for "estarem", diga sim.
  Se a string for "possui", diga sim.
  \Se a string for "ocupa", diga sim.
  \Se a string for "tem", diga sim.
  Diga não.

Rotina para que se examine uma variável global usando um percorredor (literal termo):
  Se existir algum problema de compilação, retorne.
  Examine o corpo de variável global desta variável global usando o percorredor.
  Se o segmento inicial deste percorredor não for o ponto final,
    Apresente uma mensagem de erro contendo "Erro #025. Erro de sintaxe. Necessário inserir um '.' após a atribuição de um valor numérico ou textual." e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Catalogue a variável global.

Rotina para que se examine um corpo de variável global usando um percorredor:
  Se existir algum problema de compilação, retorne.
  Se o segmento inicial deste percorredor estiver em branco, retorne.
  Atribua o caractere inicial deste segmento inicial deste percorredor ao caractere inicial deste corpo de variável global.
  Atribua -1 ao caractere final deste corpo de variável global.
  Itere.
    Se existir algum problema de compilação, retorne.
    Se o segmento inicial deste percorredor estiver em branco, retorne.
    Se o segmento inicial deste percorredor for o sinal de dois pontos, retorne.
    Se o segmento inicial deste percorredor for o ponto final, retorne.
    Atribua o caractere final deste segmento inicial deste percorredor ao caractere final deste corpo de variável global.
    Mova o percorredor (usando diretrizes de compilação).
  Reitere.

Rotina para que se examine uma variável global usando um percorredor (dados complementares):
  Se existir algum problema de compilação, retorne.
  Atribua "~inline " junto com o nome desta variável global seguido de " tipo" para um nome.
  Atribua o nome seguido de "s" para um nome plural. \ aqui pode estar o erro na formação do plural
  Adicione um tipo para os tipos usando o nome e o nome plural e o nome do tipo desta variável global e o endereço local desta variável global.
  Catalogue o tipo.
  Atribua o nome deste tipo ao nome do tipo desta variável global.
  Examine algum dado complementar para o tipo usando o percorredor.
  Se o segmento inicial deste percorredor não for o ponto final,
    Apresente uma mensagem de erro contendo "Erro #026. Erro de sintaxe. Necessário incluir um '.' após a declaração de informações complementares." e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Catalogue a variável global.

\Rotina para que se examine algum dado complementar de um tipo usando um percorredor:
Rotina para que se examine algum dado complementar para um tipo usando um percorredor:
  Se existir algum problema de compilação, retorne.
  \Se o segmento inicial deste percorredor for "to",
    \Examine algum dado complementar para o tipo usando o percorredor (ponteiros);
    \Retorne.
  Se o segmento inicial deste percorredor for "para",
    Examine algum dado complementar para o tipo usando o percorredor (ponteiros);
    Retorne.
  Se o segmento inicial deste percorredor for alguma palavra-chave de complementação,
    Examine algum dado complementar para o tipo usando o percorredor (estrutura);
    Retorne.

Rotina para que se examine algum dado complementar para um tipo usando um percorredor (ponteiros):
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum artigo indefinido,
    Apresente uma mensagem de erro contendo "Erro #027. Sintaxe incorreta no comando 'Aponte para um(a)'. Expressão encontrada: '" 
    junto com o segmento inicial deste percorredor seguido de "'." e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine o nome do conteúdo deste tipo usando o percorredor.

Função para que se determine se uma string é alguma palavra-chave de complementação:
  Se a string for "com", diga sim.
  Se a string for "contendo", diga sim.
  Diga não.

Rotina para que se examine algum dado complementar para um tipo usando um percorredor (estrutura):
  Mova o percorredor (usando diretrizes de compilação).
  Examine os campos deste tipo usando o percorredor.

Rotina para que se examine uma variável global usando um percorredor (data part):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum to,
    Apresente uma mensagem de erro contendo "Erro #028. Erro de sintaxe na declaração da variável global." 
    junto com " O compilador esperava encontrar a expressão: 'igual a'. Expressão encontrada: '" 
    junto com o segmento inicial deste percorredor seguido de "'." e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine o corpo de variável global desta variável global usando o percorredor.
  Se o segmento inicial deste percorredor não for o ponto final,
    Apresente a mensagem de erro contendo "Erro #029. Erro de sintaxe. Esperado '.' ao final de uma declaração variável variável global." e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Catalogue a variável global.

Função para que se determine se uma string é algum to: \ igual a 
  Se a string for "a", diga sim. 
  \Se a string for "para", diga sim.
  Diga não.

Função para que se determine se uma string é o início de alguma rotina:
  \PAL
  Se a string for "Rotina", diga sim.
  Se a string for "Função", diga sim.
  Se a string for "Para", diga sim.
  Se a string for "Passos", diga sim.
  Se a string for "Etapas", diga sim.
  Se a string for "Procedimento", diga sim.
  Diga não.

Rotina para que se examine uma rotina usando um percorredor:
    \ Define o cabeçalho de rotina.
  Se existir algum problema de compilação, retorne.
  Adicione a rotina para as rotinas usando o caractere inicial deste segmento inicial deste percorredor.
  Se o segmento inicial deste percorredor for syntatic sugar, 
    Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for "para",
    Apresente uma mensagem de erro contendo "Erro #030. Erro de sintaxe. É necessário incluir a palavra-chave 'para' '" 
    junto com o segmento inicial deste percorredor seguido de "' neste cabeçalho de rotina." e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação). \ ignora o "para" e obtém o próximo segmento inicial
  Se o segmento inicial deste percorredor for "que", 
    Mova o percorredor (usando diretrizes de compilação).
  \Se o segmento inicial deste percorredor não for "que",
    \apresente uma mensagem de erro contendo "Você precisa colocar um 'que' antes da palavra: " 
    \junto com o segmento inicial deste percorredor seguido de "." e o percorredor;
    \Retorne.
  \Mova o percorredor (usando diretrizes de compilação). \ ignora o "que" e obtém o próximo segmento inicial
  Se o segmento inicial deste percorredor for "se", 
    Mova o percorredor (usando diretrizes de compilação).
  \Se o segmento inicial deste percorredor não for "se",
    \apresente uma mensagem de erro contendo "Você precisa colocar um 'se' antes da palavra: " 
    \junto com o segmento inicial deste percorredor seguido de "." e o percorredor;
    \Retorne.
  \Mova o percorredor (usando diretrizes de compilação). \ ignora o "se" e obtém o próximo segmento inicial
  Examine a cabeçalho de rotina desta rotina usando o percorredor.
  Se o segmento inicial deste percorredor for o ponto&vírgula,
    Examine a rotina usando o percorredor (sobrecarga de métodos);
    Retorne. \ *** usado para nomes alternativos de rotinas
  Se o segmento inicial deste percorredor não for o sinal de dois pontos,
    Apresente a mensagem de erro contendo "Erro #031. Erro de sintaxe. ':' ausente ou mal posicionado" e o endereço local desta rotina;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine as instruções desta rotina usando o percorredor.

Rotina para que se adicione uma rotina para umas rotinas usando um endereço local:
  Crie a rotina.
  Acrescente a rotina para as rotinas.
  Atribua o endereço local ao endereço local desta rotina.

Função para que se determine se uma string é syntatic sugar:
  \PAL
  Se a string for "Passos", diga sim.
  Se a string for "Etapas", diga sim.
  Se a string for "Procedimento", diga sim.
  Se a string for "Rotina", diga sim.
  Se a string for "Função", diga sim.
  Diga não.

Rotina para que se examine uma rotina usando um percorredor (sobrecarga de métodos):
  \ *** para nomes alternativos de rotinas
  Preserve o percorredor.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for o início de alguma rotina,
    Apresente uma mensagem de erro contendo "Erro #032. Erro de sintaxe. ';' ausente ou mal posicionado" e o percorredor original;
    Retorne.
  Atribua o caractere inicial deste segmento inicial deste percorredor original ao caractere inicial destas instruções desta rotina.
  Atribua o caractere final deste segmento inicial deste percorredor original ao caractere final destas instruções desta rotina.
  Mova o percorredor original (usando diretrizes de compilação).

Rotina para que se examine umas instruções usando um percorredor:
  Se existir algum problema de compilação, retorne.
  Se o segmento inicial deste percorredor estiver em branco, retorne.
  Se o segmento inicial deste percorredor for o enunciado de alguma rotina ou variável, retorne.
  Atribua o caractere inicial deste segmento inicial deste percorredor ao caractere inicial destas instruções.
  Itere.
    Se existir algum problema de compilação, retorne.
    Se o segmento inicial deste percorredor estiver em branco, retorne.
    Atribua o caractere final deste segmento inicial deste percorredor ao caractere final destas instruções.
    Se o segmento inicial deste percorredor for o sinal de dois pontos,
      Apresente uma mensagem de erro contendo "033. Insira ':' ao final do cabeçalho desta rotina." e o percorredor;
      Retorne.
    Se o segmento inicial deste percorredor não for o ponto final,
      Mova o percorredor (usando diretrizes de compilação);
      Reitere.
    Mova o percorredor (usando diretrizes de compilação).
    Se o segmento inicial deste percorredor for o enunciado de alguma rotina ou variável, retorne.
  Reitere.

Função para que se determine se uma string é o enunciado de alguma rotina ou variável:
  Se a string for syntatic sugar, diga sim.
  \default
  Se a string for algum artigo indefinido, diga sim.
  Se a string for algum artigo definido, diga sim.
  Diga não.

Rotina para que se compile um endereço da pasta (identificação dos tipos das variáveis): \ Etapa #004
  Se existir algum problema de compilação, retorne.
  Escreva "Identificando os tipos das variáveis..." junto com o texto CRLF para StdOut.
  Comece o temporizador de resolução de tipos.
  Destrinche os tipos (expansão de listas).
  Destrinche os tipos (registro de plurais).
  Destrinche os tipos (tipos de dados primitivos).
  Destrinche os tipos (dados complementares).
  Suspenda o temporizador de resolução de tipos.

Rotina para que se destrinche uns tipos (expansão de listas):
  [Itere.]
    Se existir algum problema de compilação, retorne.
    Obtenha um tipo desde o tipos.
    Se o tipo for inexistente, retorne. \ Após o último tipo da lista, não haverão mais tipos a serem analisados.
    Destrinche o tipo (expand lista).
  Reitere.

Rotina para que se destrinche um tipo (expand lista): 
  \ Usado quando o tipo base do tipo ainda não pode ser determinado
  Se existir algum problema de compilação, retorne.
  Se o tipo for inexistente, retorne. \ se o tipo não existir é porque chegamos ao fim dos tipos da lista
  Se o tipo base deste tipo NÃO for inexistente, retorne. \ se o tipo BASE existir é porque o compilador já o determinou anteriormente
  Se o nome deste tipo for "lista", retorne. \ 
  \Se o nome deste tipo for "elemento", retorne.
  Se o tipo não puder ser reduzido para "lista" usando o nome do tipo primitivo, retorne. \ 
  Encontre um tipo base usando o nome do tipo primitivo deste tipo e o catálogo de tipos.
  \ O trecho abaixo cria uma estrutura denominada lista estruturada 
  \ O número campos "secretos" está codificado rigidamente em 2 lugares. Pesquise por "do que 4" (era "do que 6")
  Atribua o nome deste tipo seguido de " estruturada" para um nome.
  Atribua o nome deste tipo seguido de " estruturadas" para um nome plural.
  Atribua o nome deste tipo base seguido de " estruturada" para um nome do tipo primitivo.
  Adicione um tipo estruturado para os tipos usando o nome e o nome plural e o nome do tipo primitivo.
  Adicione um campo para os campos deste tipo estruturado usando 
    "próximo " junto com 
    O nome deste tipo e 
    "próximo" e 
    O nome deste tipo e
    O sinalizador de ignição.
  Adicione um campo português para os campos deste tipo estruturado usando 
    "próxima " junto com 
    O nome deste tipo e 
    "próxima" e 
    O nome deste tipo e 
    O sinalizador de ignição.
  Atribua "próximo " junto com o nome deste tipo ao novo nome deste campo português.
  Adicione um segundo campo para os campos deste tipo estruturado usando 
    "precedente " junto com 
    O nome deste tipo e 
    "precedente" e 
    O nome deste tipo e 
    O sinalizador de ignição.
  Adicione um segundo campo português para os campos deste tipo estruturado usando 
    O nome deste tipo seguido de 
    " anterior" e 
    "anterior" e \ vem antes do nome do tipo
    O nome deste tipo e 
    O sinalizador de ignição.
  Atribua "precedente " junto com o nome deste tipo ao novo nome deste segundo campo português.
  Se os campos deste tipo não estiverem vazios, 
    Acrescente os campos deste tipo para os campos deste tipo estruturado.
  Catalogue o tipo estruturado.
  \ fix up original tipo para look like um ponteiro
  Atribua o nome deste tipo estruturado ao nome do conteúdo deste tipo.
  \ LISTAS
  Adicione um tipo encadeado para os tipos usando o nome plural deste tipo e "" e o nome plural deste tipo base.
  Adicione um terceiro campo para os campos deste tipo encadeado usando "primeiro " 
    junto com o nome deste tipo e "primeiro" e o nome deste tipo e o sinalizador de ignição.
  Adicione um terceiro campo português para os campos deste tipo encadeado usando "primeira " 
    junto com o nome deste tipo e "primeira" e o nome deste tipo e o sinalizador de ignição.

Função para que se determine se um tipo pode ser reduzido para uma string usando o nome do tipo primitivo:
  Se o tipo for inexistente, diga não.
  Se o nome deste tipo for[igual] a string, diga sim.
  Se o sinalizador de recursividade deste tipo estiver ativo, diga não.
  Ative o sinalizador de recursividade deste tipo.
  Encontre um tipo base usando o nome do tipo primitivo deste tipo e o catálogo de tipos.
  Se o tipo base for inexistente,
    Desative o sinalizador de recursividade deste tipo;
    Diga não.
  Se o tipo base puder ser reduzido para a string usando o nome do tipo primitivo,
    Desative o sinalizador de recursividade deste tipo;
    Diga sim.
  Desative o sinalizador de recursividade deste tipo.
  Diga não.

Função para que se determine se um tipo pode ser reduzido para um nome do tipo:
  Se o tipo for inexistente, diga não.
  Preserve o tipo.
  Itere.
    Se o tipo for inexistente, diga não.
    Se o nome deste tipo for o nome do tipo, diga sim.
    Se o tipo base deste tipo for o tipo, diga não.
    Atribua o tipo base deste tipo ao tipo.
  Reitere.

Rotina para que se adicione um campo para uns campos usando um nome e um apelido e um nome do tipo e um sinalizador de referência:
  Adicione o campo para os campos usando "campo" e nil.
  Atribua o nome ao nome deste campo.
  Atribua o apelido ao apelido deste campo.
  Atribua o nome do tipo ao nome do tipo deste campo.
  Atribua o sinalizador de referência ao sinalizador de referência deste campo.

Rotina para que se destrinche uns tipos (registro de plurais):
  [Itere.]
    Se existir algum problema de compilação, retorne.
    Obtenha um tipo desde o tipos.
    Se o tipo for inexistente, retorne.
    Destrinche o tipo (registro de plurais).
  Reitere.

Rotina para que se destrinche um tipo (registro de plurais):
  Se existir algum problema de compilação, retorne.
  Se o tipo for inexistente, retorne.
  Se o nome plural deste tipo estiver em branco, retorne.
  Se o tipo puder ser reduzido para "lista" usando o nome do tipo primitivo, retorne.
  Catalogue o tipo usando o nome plural deste tipo.

Rotina para que se destrinche uns tipos (tipos de dados primitivos): 
  \ Rotina recursiva.
  [Itere.]
    Se existir algum problema de compilação, retorne.
    Obtenha um tipo desde o tipos.
    Se o tipo for inexistente, retorne.
    Destrinche o tipo (tipos de dados primitivos).
  Reitere.

Rotina para que se destrinche um tipo (tipos de dados primitivos):
  Se existir algum problema de compilação, retorne.
  Se o tipo for inexistente, retorne.
  Se o tipo base deste tipo não for inexistente, retorne.
  Encontre o tipo base deste tipo usando o nome do tipo primitivo deste tipo e o catálogo de tipos.
  Se o tipo base deste tipo for inexistente,
    Apresente uma mensagem de erro contendo "Erro #034. O identificador '" 
    junto com o nome do tipo primitivo deste tipo seguido de "' não possui um tipo base pré-definido." e o endereço local deste tipo;
    Retorne.
  Ative o sinalizador de recursividade deste tipo.
  Se o sinalizador de recursividade deste tipo base deste tipo estiver ativo,
    Apresente a mensagem de erro contendo "Erro #035. Detectado uma efinição recursiva no tipo '" 
    junto com o nome do tipo primitivo deste tipo seguido de "'." e o endereço local deste tipo;
    Retorne.
  Destrinche o tipo base deste tipo (tipos de dados primitivos). \ RECURSÃO
  Desative o sinalizador de recursividade deste tipo.

Rotina para que se destrinche uns tipos (dados complementares):
  [Itere.]
    Se existir algum problema de compilação, retorne.
    Obtenha um tipo desde o tipos.
    Se o tipo for inexistente, retorne.
    Destrinche o tipo (dados complementares).
  Reitere.

Rotina para que se destrinche um tipo (dados complementares):
  Se existir algum problema de compilação, retorne.
  Se o tipo for inexistente, retorne.
  Se o sinalizador de informações complementares deste tipo estiver ativo, retorne.
  Se o tipo base deste tipo for o [próprio] tipo, retorne. \ para os tipos pré-definidos. Ver nota explicativa abaixo.
  Verifique por informações opcionais inválidas no tipo.
  Ative o sinalizador de recursividade deste tipo.
  Destrinche o tipo base deste tipo (dados complementares).
  \ A seção abaixo somente é executada após encontrar o tipo base pré-definido, onde a rotina retorna para a versão anterior de si mesma devido a recursividade
  Se o tipo puder ser reduzido para "ponteiro", 
    Destrinche o tipo (dados opcionais - ponteiro).
  Se o tipo puder ser reduzido para "estrutura", 
    Destrinche o tipo (dados opcionais - conjunto). \ mudar aqui
  Se o tipo puder ser reduzido para "número", 
    Destrinche o tipo (dados opcionais - scale).
  Desative o sinalizador de recursividade deste tipo.
  Ative o sinalizador de informações complementares deste tipo.

Rotina para que se verifique por informações opcionais inválidas em um tipo:
  Se existir algum problema de compilação, retorne.
  Se o tipo for inexistente, retorne.
  Se o nome do conteúdo deste tipo não estiver em branco, 
    Verifique por informações opcionais inválidas no tipo (conteúdo).
  Se o campos deste tipo não estiverem vazios, 
    Verifique por informações opcionais inválidas no tipo (campos).
  Se a razão de escala deste tipo não for 0, 
    Verifique por informações opcionais inválidas no tipo (tipos fracionários).

Rotina para que se verifique por informações opcionais inválidas em um tipo (conteúdo):
  Se existir algum problema de compilação, retorne.
  Se o tipo não puder ser reduzido para "ponteiro",
    Apresente uma mensagem de erro contendo "Erro #036. Só é possível apontar para variáveis do tipo ponteiro." e o endereço local deste tipo;
    Retorne.

Rotina para que se verifique por informações opcionais inválidas em um tipo (campos):
  Se existir algum problema de compilação, retorne.
  Se o tipo não puder ser reduzido para "estrutura",
    Apresente uma mensagem de erro contendo "Erro #037. Campos só podem ser adicionados nos tipos derivados de 'estrutura' ou 'lista'." e o endereço local deste tipo; \ ABCDE
    Retorne. 

Rotina para que se verifique por informações opcionais inválidas em um tipo (tipos fracionários):
  Se existir algum problema de compilação, retorne.
  Se o tipo não puder ser reduzido para "número",
    Apresente uma mensagem de erro contendo "Erro #038. Proporções e escalas de medida só podem ser utilizadas em tipos numéricos." e o endereço local deste tipo;
    Retorne.

Rotina para que se destrinche um tipo (dados opcionais - ponteiro):
  Se existir algum problema de compilação, retorne.
  Se o tipo do conteúdo deste tipo não for inexistente, retorne.
  Se o nome do conteúdo deste tipo estiver em branco,
    Atribua o tipo do conteúdo deste tipo base deste tipo ao tipo do conteúdo deste tipo;
    Retorne.
  Encontre o tipo do conteúdo deste tipo usando o nome do conteúdo deste tipo e o catálogo de tipos.
  Se o tipo do conteúdo deste tipo for nulo,
    Apresente uma mensagem de erro contendo "Erro #039. Ponteiro com referência nula no tipo '" 
    junto com o nome deste tipo seguido de "'." e o endereço local deste tipo;
    Retorne.

Rotina para que se destrinche um tipo (dados opcionais - conjunto):
  Se existir algum problema de compilação, retorne.
  Se os campos deste tipo estiverem vazios,
    Copie os campos deste tipo base deste tipo aos campos deste tipo;
    Retorne.
  Itere.
    Se existir algum problema de compilação, retorne.
    Obtenha um campo desde os campos deste tipo (regressivamente).
    Se o campo for inexistente, pare.
    Se o campo estiver duplicado nos campos deste tipo,
      Apresente uma mensagem de erro contendo "Erro #040. O campo '" 
      junto com o nome deste campo seguido de "' está definido mais de uma vez nesta estrutura." e o endereço local deste campo;
      Retorne.
    Destrinche o campo.
    Se existir algum problema de compilação, retorne.
    Se o sinalizador de recursividade deste tipo deste campo estiver ativo,
      Apresente a mensagem de erro contendo "Erro #041. Definição recursiva encontrada no campo '" 
      \junto com o nome deste campo seguido de "'. Tipo detectado: '" 
      junto com o nome deste tipo deste campo seguido de "'." e o endereço local deste campo;
      Retorne.
    Destrinche o tipo deste campo (dados complementares). \ de novo
    Se o sinalizador de referência deste campo não estiver ativo, 
      Reitere.
    Se o tipo deste campo não puder ser reduzido para "ponteiro",
      Apresente a mensagem de erro contendo "Erro #042. Não é possível colocar '(referência)' no campo '"
      junto com o nome deste campo seguido de "' pois referências somente são aplicáveis a ponteiros." e o endereço local deste campo;
      Retorne.
  Reitere.
  Elimine apelidos duplicados desde os campos deste tipo.
  Se o tipo não puder ser reduzido para "lista estruturada", retorne.
  Se a contagem destes campos deste tipo for maior do que 4, retorne. \ already copied? was 2 por próximo e prev, now 6 para included Spanish redefiniions
  Copie os campos deste tipo base deste tipo aos campos deste tipo (apenas campos de dados).

Rotina para que se copie uns campos para uns segundo campos:
  [Itere]
    Obtenha um campo desde o campos.
    Se o campo for inexistente, retorne.
    Copie o campo para um segundo campo.
    Acrescente o segundo campo para o segundo campos.
  Reitere.

Rotina para que se copie um campo para um segundo campo:
  Se o campo for inexistente,
    Esvazie o segundo campo;
    Retorne.
  Aloque memória para o segundo campo.
  Atribua o endereço local deste campo ao endereço local deste segundo campo.
  Atribua o nome deste campo ao nome deste segundo campo.
  Atribua o apelido deste campo ao apelido deste segundo campo.
  Atribua o nome do tipo deste campo ao nome do tipo deste segundo campo.
  Atribua o tipo deste campo ao tipo deste segundo campo.
  Atribua a contagem deste campo à contagem deste segundo campo.
  Atribua o novo nome deste campo ao novo nome deste segundo campo.
  Atribua o sinalizador de referência deste campo ao sinalizador de referência deste segundo campo.
  Atribua o deslocamento deste campo ao deslocamento deste segundo campo.

Função para que se determine se uma variável está duplicado em umas variáveis;
Função para que se determine se uma variável está duplicada em umas variáveis:
  [Itere.]
    Obtenha uma segunda variável desde as variáveis.
    Se a segunda variável for inexistente, diga não.
    Se o nome desta segunda variável estiver em branco, reitere.
    Se a segunda variável for a variável, reitere.
    Se o nome desta segunda variável for o nome desta variável, diga sim.
  Reitere.

Rotina para que se destrinche um campo:
  Se existir algum problema de compilação, retorne.
  Se o campo for inexistente, retorne.
  Destrinche o campo como uma variável.
  Se o apelido deste campo não for algum nome de campo válido, 
    Limpe o apelido deste campo. \it
  Se o nome deste campo não for algum nome de campo válido,
    Apresente uma mensagem de erro contendo "Erro #043. O identificador '" 
    junto com o nome deste campo seguido de "' não corresponde a um nome de campo válido." e o endereço local deste campo;
    Retorne.

Rotina para que se destrinche uma variável:
  Se existir algum problema de compilação, retorne.
  Se a variável for inexistente, retorne.
  Se o tipo desta variável não for inexistente, retorne. \ tipo já foi definido
  Se o nome do tipo desta variável não estiver em branco,
    Destrinche a variável (usando o nome do tipo declarado);
    Retorne.
  Encontre o tipo desta variável e o apelido desta variável usando o nome desta variável.
  Se o tipo desta variável não for inexistente,
    Atribua o nome deste tipo desta variável ao nome do tipo desta variável;
    Retorne.
  [Se o tipo desta variável for inexistente,]
  Apresente uma mensagem de erro contendo "Erro #044. Não foi possível determinar o tipo da variável '" 
  junto com o nome desta variável seguido de "'." e o endereço local desta variável.

Rotina para que se destrinche uma variável (usando o nome do tipo declarado):
  Encontre o tipo desta variável usando o nome do tipo desta variável e o catálogo de tipos.
  Se o tipo desta variável for inexistente,
    Apresente uma mensagem de erro contendo "Erro #045. Não foi possível encontrar o tipo da variável '" 
    junto com o nome do tipo desta variável seguido de "' no catálogo de tipos." e o endereço local desta variável;
    Retorne.

Rotina para que se encontre um tipo e um apelido usando um nome:
  Esvazie o tipo.
  Limpe o apelido.
  Encontre o tipo e o apelido usando o nome (progressivamente).
  Se o tipo não for inexistente, retorne.
  Encontre o tipo e o apelido usando o nome (regressivamente).
  \ TRECHO DA VERSÃO ANTIGA
  \ Lance um subtexto sobre o nome.
  \ Itere.
    \ Se o subtexto estiver em branco, retorne.
    \ Encontre o tipo usando o subtexto e o catálogo de tipos.
    \ Se o tipo não for inexistente, pare.
    \ Passe para a próxima palavra  no subtexto.
  \ Reitere.
  \ Atribua o caractere inicial deste nome para caractere inicial deste segundo subtexto. \ está errado
  \ Atribua o caractere inicial deste subtexto menos 2 ao caractere final deste segundo subtexto.
  \ Se o segundo subtexto não estiver em branco, atribua o segundo subtexto ao apelido.
  \ Se o segundo subtexto estiver em branco, atribua o subtexto ao apelido.

Rotina para que se encontre um tipo e um apelido usando um nome (progressivamente):
  \ original - sem alterações
  Esvazie o tipo.
  Limpe o apelido.
  Lance um subtexto sobre o nome.
  Itere.
    Se o subtexto estiver em branco, retorne.
    Encontre o tipo usando o subtexto e o catálogo de tipos.
    Se o tipo não for inexistente, pare. \ Se encontrar o tipo, pare.
    Passe para a próxima palavra  no subtexto. \próximo tipo
  Reitere.
  Atribua o caractere inicial deste nome para o caractere inicial dum segundo subtexto.
  Atribua o caractere inicial deste subtexto menos 2 ao caractere final deste segundo subtexto.
  Se o segundo subtexto não estiver em branco, 
    Atribua o segundo subtexto ao apelido.
  Se o segundo subtexto estiver em branco, 
    Atribua o subtexto ao apelido.

Rotina para que se passe para a próxima palavra  em um subtexto:
  [Itere.]
    Se o subtexto estiver em branco, retorne.
    Se o conteúdo deste caractere inicial deste subtexto for irrelevante, pare.
    Adicione 1 para o caractere inicial deste subtexto.
  Reitere.
  Ignore os caracteres ignoráveis no início no subtexto.

Rotina para que se encontre um tipo e um apelido usando um nome (regressivamente):
  Esvazie o tipo.
  Limpe o apelido.
  Lance um subtexto sobre o nome.
  Itere.
    Se o subtexto estiver em branco, retorne.
    Encontre o tipo usando o subtexto e o catálogo de tipos.
    Se o tipo não for inexistente, pare.
    Passe para a palavra anterior no subtexto.
  Reitere.
  Atribua o caractere final deste nome para o caractere final dum segundo subtexto.
  Atribua o caractere final deste subtexto mais 2 ao caractere inicial deste segundo subtexto.
  Se o segundo subtexto não estiver em branco, 
    Atribua o segundo subtexto ao apelido.
  Se o segundo subtexto estiver em branco, 
    Atribua o subtexto ao apelido.

Rotina para que se passe para a palavra anterior em um subtexto:
  [Itere.]
    Se o subtexto estiver em branco, retorne.
    Se o conteúdo deste caractere final deste subtexto for irrelevante, pare.
    Subtraia 1 desde o caractere final deste subtexto.
  Reitere.
  Ignore algum caractere ignorável final no subtexto.

Rotina para que se ignore algum caractere ignorável final em um subtexto:
  Itere.
    Se o subtexto estiver em branco, retorne.
    Se o conteúdo deste caractere final deste subtexto não for irrelevante, retorne.
    Subtraia 1 desde o caractere final deste subtexto.
  Reitere.

Função para que se determine se um nome é algum nome de campo válido:
  Se o nome for alguma palavra-chave de obtenção de tamanho de variável, diga não.
  Se o nome for algum conteúdo, diga não.
  Se o nome for algum endereçamento, diga não.
  Diga sim.

Função para que se determine se um nome é alguma palavra-chave de obtenção de tamanho de variável:
  Se o nome for "magnitude", diga sim.  \ A "magnitude" retorna o tamanho em bytes de algo
  \Se o nome for "grandeza", diga sim.
  \Se o nome for " grandiosidade", diga sim.
  \Se o nome for " envergadura", diga sim.
  \ Exemplo: a magnitude duma string
  Diga não.

Função para que se determine se um nome é algum conteúdo:
  Se o nome for "conteúdo", diga sim.
  \Este comando é usado apenas com ponteiros (endereços de memória).
  \ Serve pra saber para quais valores o ponteiro está apontando, ou seja, o conteúdo do ponteiro .
  \"Um endereço de byte" ou "O ponteiro do byte", por exemplo, refere-se ao endereço de um byte.
  \"O conteúdo deste endereço de byte" refere-se, portanto aos dados no contidos no byte
  Diga não.

Função para que se determine se um nome é algum endereçamento:
  Se o nome for "endereçamento", diga sim.  \ retorna o endereço do dado
  Diga não.

Rotina para que se destrinche um tipo (dados opcionais - scale):
  Se existir algum problema de compilação, retorne.
  Atribua o tipo base deste tipo para um tipo base.
  Se a razão de escala deste tipo for 0,
    Atribua a razão de escala deste tipo base deste tipo à razão de escala deste tipo;
    Retorne.
  Se a razão de escala deste tipo base for 0, retorne.
  Multiplique a razão de escala deste tipo pela razão de escala deste tipo base.
  Atribua o tipo base deste tipo base ao tipo base deste tipo.

Rotina para que se compile um endereço da pasta (identificação de variáveis globais): \ Etapa #005
  Se existir algum problema de compilação, retorne.
  Escreva "Identificando variáveis globais..." junto com o texto CRLF para StdOut.
  Comece o temporizador de resolução de variáveis globais.
  Destrinche as variáveis globais.
  Suspenda o temporizador de resolução de variáveis globais.

Rotina para que se compile um endereço da pasta (cabeçalhos de rotinas): \ Etapa #006
  Se existir algum problema de compilação, retorne.
  Escreva "Agrupando os nomes das rotinas..." junto com o texto CRLF para StdOut.
  Comece o temporizador de compilação de cabeçalhos de rotina.
  Compile os cabelalhos referente às rotinas.
  Suspenda o temporizador de compilação de cabeçalhos de rotina.

Rotina para que se compile um endereço da pasta (cálculo de tamanhos e deslocamentos): \ Etapa #007
  Se existir algum problema de compilação, retorne.
  Escreva "Calculando tamanhos de variáveis e deslocamentos de memória..." junto com o texto CRLF para StdOut.
  Comece o temporizador de etapas de cálculo.
  Calcule os comprimentos referente aos tipos.
  Calcule os deslocamentos no tipos.
  Calcule os deslocamentos das redefinições no tipos.
  Suspenda o temporizador de etapas de cálculo.

Rotina para que se compile um endereço da pasta (adição de rotinas de memória incorporadas): \ Etapa #008
  Se existir algum problema de compilação, retorne.
  Escreva "Adicionando tarefas predefinidas na memória..." junto com o texto CRLF para StdOut.
  Comece o temporizador de adição de rotinas pré-definidas de mémoria .
  Adicione as rotinas de alocação e desalocação e finalização e destruição.
  Suspenda o temporizador de adição de rotinas pré-definidas de mémoria .

Rotina para que se compile um endereço da pasta (catalogue as rotinas por utilização): \ Etapa #009
  Se existir algum problema de compilação, retorne.
  Escreva "Catalogando tarefas..." junto com o texto CRLF para StdOut.
  Comece o temporizador de ferramentas de catalogação.
  Catalogue as rotinas por utilização.
  Scrub o catálogo de rotinas úteis.
  Organize o catálogo de rotinas úteis.
  Suspenda o temporizador de ferramentas de catalogação.

Rotina para que se compile um endereço da pasta (conteúdo das rotinas): \ Etapa #010
  Se existir algum problema de compilação, retorne.
  Escreva "Agrupando o conteúdo das rotinas..." junto com o texto CRLF para StdOut.
  Comece o temporizador de compilação do conteúdo das rotinas.
  Compile os corpos referentes às rotinas.
  Suspenda o temporizador de compilação do conteúdo das rotinas.

Rotina para que se compile um endereço da pasta (adição e compilação da rotina de inicialização): \ Etapa #011
  Se existir algum problema de compilação, retorne.
  Escreva "Adicionando e agrupando as tarefas padrão de inicialização.." junto com o texto CRLF para StdOut.
  Comece o temporizador de adição de rotinas pré-definidas de inicialização.
  Adicione e compile as rotinas de inicialização pré-execução e finalização pós-execução.
  Suspenda o temporizador de adição de rotinas pré-definidas de inicialização.

Rotina para que se compile um endereço da pasta (deslocamento de parâmetros e variáveis): \ Etapa #012
  Se existir algum problema de compilação, retorne.
  Escreva "Deslocando parâmetros e variáveis..." junto com o texto CRLF para StdOut.
  Comece o temporizador de deslocamentos.
  Alinhe o parâmetros na rotinas.
  Alinhe as variáveis locais na rotinas.
  Suspenda o temporizador de deslocamentos.

Rotina para que se compile um endereço da pasta (endereço): \ Etapa #013
  Se existir algum problema de compilação, retorne.
  Escreva "Obtendo endereço dos itens..." junto com o texto CRLF para StdOut.
  Comece o temporizador de endereçamento.
  Atribua 4096 para um endereço.
  Atribua o endereço à endereço base desta Seção de DLLs.
  Enderece as DLLs usando o endereço.
  Atribua o endereço menos a endereço base desta Seção de DLLs à quantidade de caracteres desta Seção de DLLs.
  Arredonde o endereço para cima usando o múltiplo imediato de 4096.
  Atribua o endereço à endereço base desta Região de Dados.
  Enderece as variáveis globais usando o endereço.
  Enderece os valores literais usando o endereço.
  Atribua o endereço menos a endereço base desta Região de Dados à quantidade de caracteres desta Região de Dados.
  Arredonde o endereço para cima usando o múltiplo imediato de 4096.
  Atribua o endereço à endereço base desta Região de Código. \ Uma zona é uma estrutura que contém um endereço base, uma quantidade de caracteres e um tamanho.
  Enderece as rotinas usando o endereço.
  Atribua o endereço menos a endereço base desta Região de Código à quantidade de caracteres desta Região de Código.
  Suspenda o temporizador de endereçamento.

Rotina para que se compile um endereço da pasta (transmutação): \ Etapa #014
  Se existir algum problema de compilação, retorne.
  Escreva "Convertendo código em instruções de máquina..." junto com o texto CRLF para StdOut.
  Comece o temporizador de transmutação.
  Transforme as rotinas em código hexadecimal.
  Suspenda o temporizador de transmutação.

Rotina para que se compile um endereço da pasta (vinculação): \ Etapa #015
  Se existir algum problema de compilação, retorne.
  Escreva "Elencando arquivos.." junto com o texto CRLF para StdOut.
  Comece o temporizador de vinculação.
  Vincule.
  Suspenda o temporizador de vinculação.

Rotina para que se compile um endereço da pasta (etapa final): \ Etapa #016
  Se existir algum problema de compilação, retorne.
  Escreva "Gerando arquivo executável..." junto com o texto CRLF para StdOut.
  Comece o temporizador de escrita.
  Escreva o trecho EXE deste compilador para o endereço EXE completo deste compilador.
  \Se o erro do fluxo de entrada/saída não estiver em branco, apresente uma mensagem de erro contendo o erro do fluxo de entrada/saída.
  Se o erro do fluxo de entrada/saída não estiver em branco,
    Escreva o erro do fluxo de entrada/saída para StdOut.
  Suspenda o temporizador de escrita.

Rotina para que se compile um endereço da pasta (interrupção): \ Etapa #017
  Suspenda o temporizador deste compilador.
  Escreva "---------------------------------------" junto com o texto CRLF para StdOut.