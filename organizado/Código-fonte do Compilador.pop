
Rotina para que se exiba o erro de compilação:
  Se o endereço do arquivo atual deste compilador estiver em branco, 
    Escreva a mensagem de erro deste compilador para StdOut; 
    Retorne.
  Escreva 
    A mensagem de erro deste compilador seguido de " - " 
      junto com o endereço do arquivo atual deste compilador 
      seguido de " linha: " 
      junto com o número da linha de erro deste compilador
    para StdOut.
  Escreva o texto CRLF para StdOut.

Rotina para que se execute os eventos:
  [Itere.]
    Desenfileire um evento.
    Se o evento for inexistente, retorne.
    Execute o evento.
  Reitere.

Rotina para que se mostre no painel de informações uma string:
  Escreva a string para StdOut.

Rotina para que se execute um evento:
  Se a categoria deste evento for "pressionamento de tecla", 
    Renuncie ao controle; 
    Retorne.

\ firstparam=esp+4/ebp+8,
\secondparam=esp+8/ebp+12, etc...

\ Strings são implementadas como uma struct que contém 2 membros, a saber:
\ O endereço do byte inicial e o endereço do byte final.
\ Desta forma é possível trocar o primeiro e o último bytes de uma string, com um comandos como este:
\ Permute o conteúdo deste caractere inicial desta string com o conteúdo do caractere final desta string.

\ Parâmetros são passados por referência

\ Os registradores EBP (ponteiro base) e ESP (ponteiro de pilha) são usados para manipular a PILHA
\ que é uma área da memória que você pode imaginar como uma pilha de pratos,
\ sendo que cada prato representando um valor salvo em um registrador,
\ ou um endereço em algum lugar no código do programa,
\ ou o endereço de uma variável (que reside em algum outro lugar na memória),
\ ou o conteúdo de uma variável. 

\ Como é típico do Windows, a pilha cresce inversamente.
\ ou seja, o endereço do “topo” da pilha é sempre menor que o endereço da base.

\ O registrador ESP sempre contém o endereço do “topo” da pilha. 
\O registrador EBP contém o endereço da “base” da pilha da rotina atual.
\ Por convenção, é assim que a pilha é usada em Português Puro 
\ (C usa o STACK de maneira semelhante, mas envia os parâmetros na ordem inversa):

\ Você pode ver que dessa forma,  o primeiro parâmetro de uma rotina estará no endereço do registrador EBP + 8,
\ o segundo parâmetro estará no endereço em EBP + 12, etc.
\ E que nossas variáveis locais serão estarão no endereço no registrador EBP menos 4, menos 8, etc,
\ dependendo, é claro, do tamanho de cada uma dessas variáveis.

\ O prólogo de cada rotina em português puro começa salvando o ebp do chamador na pilha, logo acima do endereço de retorno.
\ O epílogo de cada rotina remove quaisquer variáveis locais, restaura o ebp e retorna ao chamador, estabelecendo quaisquer parâmetros enquanto ele assim o faz.
\ Os programas em C operam de maneira semelhante.

\ A CPU Intel sabe como colocar valores e endereços de 4 bytes na pilha e como recuperá-los.
\ Para colocar e retirar coisas maiores da pilha, precisamos lidar diretamente com o registro ESP.
\ Subtrair 16 do endereço no ESP, por exemplo, abre espaço para 16 bytes de dados locais no “topo” da pilha; adicionar 16 tira esses bytes da pilha.



Rotina para que se apresente uma mensagem de erro contendo uma string:
  Se existir algum problema de compilação,
    Retorne.
  Ative o sinalizador de erros deste compilador.
  Atribua esta string à mensagem de erro deste compilador.



Rotina para que se apresente uma mensagem de erro contendo uma string e um percorredor:
  Se o segmento inicial deste percorredor não estiver em branco,
    Apresente a mensagem de erro contendo a string e o caractere inicial deste segmento inicial deste percorredor;
    Retorne.
  Apresente a mensagem de erro contendo a string e o caractere final deste segmento final deste percorredor.

Rotina para que se adicione as rotinas de alocação e desalocação e finalização e destruição:
  Se existir algum problema de compilação, retorne.
  Obtenha um tipo desde os tipos.
  Se o tipo for inexistente, retorne.
  Adicione a rotina de finalização para o tipo.
  Adicione a rotina de alocação para o tipo.
  Adicione a rotina de desalocação para o tipo.
  Adicione a rotina de destruição para o tipo.
 Reitere.

Rotina para que se adicione a rotina de alocação para um tipo:
  Se o tipo for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Se o tipo não puder ser reduzido para "ponteiro", retorne.
  Se o tipo do conteúdo deste tipo for inexistente, retorne.
  Adicione uma rotina para as rotinas usando nil.
  Acrescente "Aloque memória para um " junto com o nome deste tipo para a string do cabeçalho desta rotina. \ traduzir aqui
  Acrescente "Associe o " junto com o nome deste tipo seguido de " usando " para a string do corpo desta rotina. \Nomeie
  Acrescente a quantidade de caracteres deste tipo do conteúdo deste tipo seguido de "." para a string do corpo desta rotina.
  Lance a cabeçalho de rotina desta rotina sobre a string do cabeçalho desta rotina.
  Lance as instruções desta rotina sobre a string do corpo desta rotina.
  Compile o cabeçalho referente à rotina.

Rotina para que se adicione e compile as rotinas de inicialização pré-execução e finalização pós-execução:
  Se existir algum problema de compilação, retorne.
  Adicione uma rotina para as rotinas usando nil.
  Acrescente "~Inicialize antes da execução e Execute o programa e Finalize após execução" para a string do cabeçalho desta rotina.
  Acrescente "Inicialize antes da execução. " para a string do corpo desta rotina.
  Acrescente os inicializadores de variáveis globais para a string do corpo desta rotina.
  Acrescente "Execute o programa. " para a string do corpo desta rotina.
  Acrescente os finalizadores de variáveis globais para a string do corpo desta rotina.
  Acrescente "Finalize após execução. " para a string do corpo desta rotina.
  Acrescente "Processe ""kernel32.dll"" ""ExitProcess"" com 0. " para a string do corpo desta rotina.
  Lance a cabeçalho de rotina desta rotina sobre a string do cabeçalho desta rotina.
  Lance as instruções desta rotina sobre a string do corpo desta rotina.
  Compile o cabeçalho referente à rotina.
  Compile o corpo referente à rotina.



Rotina para que se adicione a rotina de desalocação para um tipo:
  Se o tipo for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Se o tipo não puder ser reduzido para "ponteiro", retorne.
  Se o tipo do conteúdo deste tipo for inexistente, retorne.
  Adicione uma rotina para as rotinas usando nil.
  Acrescente "Desaloque um " junto com o nome deste tipo para a string do cabeçalho desta rotina.
  Acrescente "Se o " junto com o nome deste tipo seguido de " for inexistente, retorne. " para a string do corpo desta rotina.
  Se o tipo do conteúdo deste tipo deveria ser finalizado [automaticamente por uma rotina],
    Acrescente "~Finalize o conteúdo de este " junto com o nome deste tipo seguido de ". " para a string do corpo desta rotina.
  \ Chamado quando o tipo precisa ter uma rotina de destruição gerada automaticamente para ele
  Acrescente "Desassocie o " junto com o nome deste tipo seguido de "." para a string do corpo desta rotina. \ Desaloque memória para o
  Lance a cabeçalho de rotina desta rotina sobre a string do cabeçalho desta rotina.
  Lance as instruções desta rotina sobre a string do corpo desta rotina.
  Compile o cabeçalho referente à rotina.

Rotina para que se adicione a rotina de destruição para um tipo:
  Se o tipo for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Se o tipo não deveria ser ignorado, retorne.
  Se o tipo puder ser reduzido para "listas",
    Adicione a rotina de destruição para o tipo (listas);
    Retorne.
  Se o tipo puder ser reduzido para "ponteiro",
    Adicione a rotina de destruição para o tipo (ponteiros);
    Retorne.

Rotina para que se adicione a rotina de destruição para um tipo (ponteiros):
  Se o tipo for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Atribua "Destrua [" junto com o nome deste tipo seguido de "]" para uma representação interna da rotina.
  Se a representação interna da rotina estiver no catálogo geral de rotinas, retorne.
  Adicione uma rotina para as rotinas usando nil.
  Acrescente "Destrua um " junto com o nome deste tipo para a string do cabeçalho desta rotina.
  Acrescente "Se o " junto com o nome deste tipo seguido de " for inexistente, retorne. " para a string do corpo desta rotina.
  Se o tipo do conteúdo deste tipo puder ser reduzido para "ponteiro", acrescente "Destrua o conteúdo de este " junto com o nome deste tipo seguido de "'. " para a string do corpo desta rotina.
  Se o tipo do conteúdo deste tipo puder ser reduzido para "listas", acrescente "Destrua o conteúdo de este " junto com o nome deste tipo seguido de "'. " para a string do corpo desta rotina.
  Itere.
    Obtenha um campo desde os campos deste tipo do conteúdo deste tipo.
    Se o campo for inexistente, pare.
    Se o sinalizador de referência deste campo estiver ativo, reitere.
    Se o tipo deste campo não deveria ser ignorado, reitere.
    Acrescente "Destrua o " junto com o nome deste campo seguido de " de este " junto com o nome deste tipo seguido de ". " para a string do corpo desta rotina.
  Reitere.
  Acrescente "Desaloque o " junto com o nome deste tipo seguido de ". " para a string do corpo desta rotina. \ traduzir aqui
  Lance a cabeçalho de rotina desta rotina sobre a string do cabeçalho desta rotina.
  Lance as instruções desta rotina sobre a string do corpo desta rotina.
  Compile o cabeçalho referente à rotina.

Rotina para que se adicione a rotina de destruição para um tipo (listas):
  Se o tipo for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Se o primeiro campo destes campos deste tipo for inexistente,
    Apresente uma mensagem de erro contendo "Erro #1. O campo '" junto com o nome deste primeiro campo destes campos deste tipo seguido de "' é inválido.'";
    Retorne. \
  Se o tipo deste primeiro campo destes campos deste tipo for inexistente,
    Apresente a mensagem de erro contendo "Erro #2'. O tipo '" junto com o nome deste tipo deste primeiro campo destes campos deste tipo seguido de "' é inválido.'";
    Retorne.
  Atribua "Destrua [" junto com o nome deste tipo seguido de "]" para uma representação interna da rotina.
  Se a representação interna da rotina estiver no catálogo geral de rotinas, retorne.
  Adicione uma rotina para as rotinas usando nil.
  Acrescente "Destrua um " junto com o nome deste tipo para a string do cabeçalho desta rotina.
  Acrescente "Se o primeiro " junto com o nome deste tipo deste primeiro campo destes campos deste tipo
    Junto com " de este " junto com o nome deste tipo seguido de " for inexistente, retorne. " para a string do corpo desta rotina. \ listas duplamente encadeadas
  Atribua o nome deste tipo deste primeiro campo destes campos deste tipo para um nome.
  Acrescente "Atribua o primeiro " junto com o nome junto com " de este "junto com o nome deste tipo seguido de " para um " junto com o nome seguido de ". " para a string do corpo desta rotina.\ traduzir
  Acrescente "Remova o " junto com o nome seguido de " desde o " junto com o nome deste tipo seguido de ". " para a string do corpo desta rotina.
  Acrescente "Destrua o " junto com o nome seguido de ". " para a string do corpo desta rotina.
  Acrescente "Reitere. " para a string do corpo desta rotina.
  Lance a cabeçalho de rotina desta rotina sobre a string do cabeçalho desta rotina.
  Lance as instruções desta rotina sobre a string do corpo desta rotina.
  Compile o cabeçalho referente à rotina.

Rotina para que se adicione uma função para umas DLLs usando um nome da DLL e um nome da função:
  Encontre uma DLL usando o nome da DLL.
  Se a DLL for inexistente, adicione a DLL para as DLLs usando o nome da DLL.
  Encontre a função usando o nome da função e as funções desta DLL.
  Se a função não for inexistente, retorne.
  Crie a função.
  Acrescente a função para as funções desta DLL.
  Atribua o nome da função ao nome desta função.



Rotina para que se adicione a rotina de finalização para um tipo:
  Se o tipo for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Se o tipo não deveria ser finalizado, retorne.
  Se o nome deste tipo for "string",
    Adicione a rotina de finalização para o tipo (cadeia de caracteres);
    Retorne.
  Se o nome deste tipo for "texto",
    Adicione a rotina de finalização para o tipo (cadeia de caracteres);
    Retorne.
  Se o nome deste tipo for "cadeia de caracteres",
    Adicione a rotina de finalização para o tipo (cadeia de caracteres);
    Retorne.
  Se o tipo puder ser reduzido para "string", retorne. \ impede a geração de finalizaores para tipos derivados de string
  Se o tipo puder ser reduzido para "texto", retorne.
  Se o tipo puder ser reduzido para "cadeia de caracteres", retorne.
  Adicione a rotina de finalização para o tipo (estrutura).

Rotina para que se adicione a rotina de finalização para um tipo (estrutura):
  Se o tipo for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Adicione uma rotina para as rotinas usando nil.
  Acrescente "~Finalize um " junto com o nome deste tipo para a string do cabeçalho desta rotina.
  Acrescente "Decodifique $50. " para a string do corpo desta rotina. \ push eax -> coloca o valor de 32 bits presentes em EAX na pilha
  \ A instrução push coloca seu operando no topo da pilha de hardware na memória.
  \ Especificamente, a instrução push primeiro decrementa ESP em 4 e depois coloca seu operando no conteúdo do local de 32 bits no endereço [ESP].
   \ESP (o ponteiro da pilha) é decrementado por push, pois a pilha x86 cresce para baixo - ou seja, a pilha cresce dos endereços maiores para os endereços menores.
  Itere.
    Obtenha um campo desde os campos deste tipo.
    Se o campo for inexistente, pare.
    Se o tipo deste campo não deveria ser finalizado, reitere.
    Acrescente "~Finalize o " junto com o nome deste tipo seguido de "'s " junto com o nome deste campo seguido de ". " para a string do corpo desta rotina.
  Reitere.
  Acrescente "Decodifique $58." para a string do corpo desta rotina. \ pop eax -> pop the top element of the stack into memory ar the four bytes starting at location EAX.
  \  \pop 4 bytes off the stack and put them into eax
  \ The pop instruction removes the 4-byte data element desde the top of the hardware-supported stack into the specified operand (i.e. register or memory location).
  \It primeiro moves the 4 bytes located sob memory location [SP] into the specified register or memory location, and then increments memory location [SP] by 4.
  Lance a cabeçalho de rotina desta rotina sobre a string do cabeçalho desta rotina.
  Lance as instruções desta rotina sobre a string do corpo desta rotina.
  Compile o cabeçalho referente à rotina.

Rotina para que se adicione a rotina de finalização para um tipo (cadeia de caracteres):
  Se o tipo for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Adicione uma rotina para as rotinas usando nil.
  Acrescente "~Finalize um " junto com o nome deste tipo para a string do cabeçalho desta rotina.
  Acrescente "Decodifique $50. " para a string do corpo desta rotina. \ push eax -> push the 4 bytes value in EAX onto the stack
  \ Specifically, push primeiro decrements ESP by 4, then places its operand into the contents of the 32-bit location sob endereço [ESP].
  \ESP (the stack pointer) is decremented by push since the x86 stack grows para baixo - i.e. the stack grows desde from addresses to lower addresses.
  Acrescente "Desassocie o caractere inicial de esta string . " para a string do corpo desta rotina. \\ traduzir string aqui
  Acrescente "Decodifique $58." para a string do corpo desta rotina. \ pop eax -> pop the top element of the stack into memory at the four bytes starting at location EAX.
  \pop 4 bytes off the stack and put them into eax
  \ The pop instruction removes the 4-byte data element desde the top of the hardware-supported stack into the specified operand (i.e. register or memory location).
  \ It primeiro moves the 4 bytes located sob memory location [SP] into the specified register or memory location, and then increments memory location [SP] by 4.
  Lance a cabeçalho de rotina desta rotina sobre a string do cabeçalho desta rotina.
  Lance as instruções desta rotina sobre a string do corpo desta rotina.
  Compile o cabeçalho referente à rotina.

Rotina para que se adicione um fragmento usando uma etiqueta:
  Se a rotina utilizada atualmente for inexistente,
    Esvazie o fragmento;
    Retorne.
  Crie o fragmento usando a etiqueta.
  Acrescente o fragmento para os fragmentos desta rotina utilizada atualmente.

Rotina para que se adicione um fragmento usando uma etiqueta e uma função:
  Se a rotina utilizada atualmente for inexistente,
    Esvazie o fragmento;
    Retorne.
  Crie o fragmento usando a etiqueta.
  Acrescente o fragmento para os fragmentos desta rotina utilizada atualmente.
  Atribua a função à função deste fragmento.

Rotina para que se adicione um fragmento usando uma etiqueta e um sinalizador:
  Se a rotina utilizada atualmente for inexistente,
    Esvazie o fragmento;
    Retorne.
  Crie o fragmento usando a etiqueta.
  Acrescente o fragmento para os fragmentos desta rotina utilizada atualmente.
  Atribua o sinalizador ao sinalizador deste fragmento.

Rotina para que se adicione um fragmento usando uma etiqueta e uma rotina:
  Se a rotina utilizada atualmente for inexistente,
    Esvazie o fragmento;
    Retorne.
  Crie o fragmento usando a etiqueta.
  Acrescente o fragmento para os fragmentos desta rotina utilizada atualmente.
  Atribua a rotina à rotina deste fragmento.
  Compile o corpo referente à rotina.

Rotina para que se adicione um fragmento usando uma etiqueta e uma variável:
  Se a rotina utilizada atualmente for inexistente,
    Esvazie o fragmento;
    Retorne.
  Crie o fragmento usando a etiqueta.
  Acrescente o fragmento para os fragmentos desta rotina utilizada atualmente.
  Atribua a variável à variável deste fragmento.
  Ative o sinalizador de compilação na variável.

Rotina para que se adicione um fragmento usando uma etiqueta e uma variável e uma segunda variável:
  Se a rotina utilizada atualmente for inexistente,
    Esvazie o fragmento;
    Retorne.
  Crie o fragmento usando a etiqueta.
  Acrescente o fragmento para os fragmentos desta rotina utilizada atualmente.
  Atribua a variável à variável deste fragmento.
  Atribua a segunda variável à segunda variável deste fragmento.
  Ative o sinalizador de compilação na variável.
  Ative o sinalizador de compilação na segunda variável.

Rotina para que se adicione um fragmento usando uma etiqueta e uma variável e um número:
  Se a rotina utilizada atualmente for inexistente,
    Esvazie o fragmento;
    Retorne.
  Crie o fragmento usando a etiqueta.
  Acrescente o fragmento para os fragmentos desta rotina utilizada atualmente.
  Atribua a variável à variável deste fragmento.
  Atribua o número ao número deste fragmento.
  Ative o sinalizador de compilação na variável.

Rotina para que se adicione uma DLL para umas DLLs usando um nome da DLL:
  Crie a DLL.
  Acrescente a DLL para as DLLs.
  Atribua o nome da DLL ao nome desta DLL.

Rotina para que se adicione uma variável intermediária usando um nome do tipo e um endereço local:
  Se a rotina utilizada atualmente for inexistente,
    Esvazie a variável intermediária;
    Retorne.
  Adicione a variável intermediária para as variáveis locais desta rotina utilizada atualmente usando "local" e o endereço local.
  Gere o nome desta variável intermediária usando "~I".
  Atribua o nome do tipo ao nome do tipo desta variável intermediária.
  Destrinche a variável intermediária.

Rotina para que se adicione um valor literal para umas variáveis usando um endereço local:
  Adicione o valor literal como uma variável para as variáveis usando "literal" e o endereço local.
  Gere o nome deste valor literal usando "~L".

Rotina para que se adicione uma unidade semântica para umas unidades semânticas usando uma expressão matematica:
  Crie a unidade semântica.
  Acrescente a unidade semântica para as unidades semânticas.
  Atribua a frase desta expressão matematica à string desta unidade semântica.
  Atribua a variável desta expressão matematica à variável desta unidade semântica.
  Se a variável desta expressão matematica não for inexistente, atribua o tipo desta expressão matematica ao tipo desta unidade semântica.

  \ Unifica o sentido de diferentes termos usados em proposições, verbos e conjunções.
Rotina para que se adicione uma unidade semântica para umas unidades semânticas usando uma string: \ creio que isso aqui ajude nas funções
  Crie a unidade semântica.
  Acrescente a unidade semântica para as unidades semânticas.
  \\ conjunções
  Se a string for "e",
    Atribua "e" à string desta unidade semântica;
    Retorne. \ and
  Se a string for "ou",
    Atribua "ou" à string desta unidade semântica;
    Retorne. \ or
  \ usando
  Se a string for "desde",
    Atribua "usando" à string desta unidade semântica;
    Retorne.
  \Se a string for "de", atribua "usando" à string desta unidade semântica; Retorne.
  Se a string for "dada",
    Atribua "usando" à string desta unidade semântica;
    Retorne.
  Se a string for "dado",
    Atribua "usando" à string desta unidade semântica;
    Retorne.
  Se a string for "dadas",
    Atribua "usando" à string desta unidade semântica;
    Retorne.
  Se a string for "dados",
    Atribua "usando" à string desta unidade semântica;
    Retorne.
  Se a string for "com",
    Atribua "usando" à string desta unidade semântica;
    Retorne.
  Se a string for "usando",
    Atribua "usando" à string desta unidade semântica;
    Retorne.
  Se a string for "contendo",
    Atribua "usando" à string desta unidade semântica;
    Retorne.
  Se a string for "dizendo",
    Atribua "usando" à string desta unidade semântica;
    Retorne.
  \\ para
  Se a string for "em", atribua "para" à string desta unidade semântica; Retorne.
  Se a string for "a",
    Atribua "para" à string desta unidade semântica;
    Retorne. \  ver isso aqui com calma
  Se a string for "para",
    Atribua "para" à string desta unidade semântica;
    Retorne.
  \\ VERBO SER/ESTAR
  Se a string for "é",
    Atribua "é" à string desta unidade semântica;
    Retorne.
  Se a string for "está",
    Atribua "é" à string desta unidade semântica;
    Retorne.
  Se a string for "for",
    Atribua "é" à string desta unidade semântica;
    Retorne.
  Se a string for "foi",
    Atribua "é" à string desta unidade semântica;
    Retorne.
  Se a string for "foram",
    Atribua "é" à string desta unidade semântica;
    Retorne.
  Se a string for "forem",
    Atribua "é" à string desta unidade semântica;
    Retorne.
  Se a string for "estiver",
    Atribua "é" à string desta unidade semântica;
    Retorne.
  Se a string for "estiverem",
    Atribua "é" à string desta unidade semântica;
    Retorne.
  Se a string for "estamos",
    Atribua "é" à string desta unidade semântica;
    Retorne.
  Se a string for "há",
    Atribua "há" à string desta unidade semântica;
    Retorne.
  Se a string for "houver",
    Atribua "há" à string desta unidade semântica;
    Retorne.
  Se a string for "seja",
    Atribua "é" à string desta unidade semântica;
    Retorne.
  Se a string for "sejam",
    Atribua "é" à string desta unidade semântica;
    Retorne.
  \Se a string for "tem", atribua "tem" à string desta unidade semântica; Retorne.
  \Se a string for "tiver", atribua "tem" à string desta unidade semântica; Retorne.
  Se a string for "são",
    Atribua "é" à string desta unidade semântica;
    Retorne.
  Se a string for "estão",
    Atribua "é" à string desta unidade semântica;
    Retorne.
  Se a string for "forem",
    Atribua "é" à string desta unidade semântica;
    Retorne.
  Se a string for "estiverem",
    Atribua "é" à string desta unidade semântica;
    Retorne.
  Se a string for "puder",
    Atribua "pode" à string desta unidade semântica;
    Retorne.
  Se a string for "puderem",
    Atribua "pode" à string desta unidade semântica;
    Retorne.
  Se a string for "existe",
    Atribua "existe" à string desta unidade semântica;
    Retorne.
  Se a string for "existir",
    Atribua "existe" à string desta unidade semântica;
    Retorne.
  Se a string for "há",
    Atribua "há" à string desta unidade semântica;
    Retorne.
  Se a string for "houver",
    Atribua "há" à string desta unidade semântica;
    Retorne.
  Se a string for "possuir",
    Atribua "possui" à string desta unidade semântica;
    Retorne.
  \\ allocates e destroys
  \Se a string for "aloque", atribua "allocate" à string desta unidade semântica; Retorne.
  Se a string for "pelo",
    Atribua "por o" à string desta unidade semântica;
    Retorne.
  Se a string for "pela",
    Atribua "por o" à string desta unidade semântica;
    Retorne.
  \Se a string for "desaloque", atribua "desaloque" à string desta unidade semântica; Retorne.
  \Se a string for "esvazie", atribua "deallocate" à string desta unidade semântica; Retorne.
  \Se a string for "destrua", atribua "destrua" à string desta unidade semântica; Retorne.
  \ é
  Se a string for "is",
    Atribua "é" à string desta unidade semântica;
    Retorne.
  \ sobre
  Se a string for "sob",
    Atribua "sobre" à string desta unidade semântica;
    Retorne.
  Se a string for "sobre",
    Atribua "sobre" à string desta unidade semântica;
    Retorne.
  Se a string for "começa",
    Atribua "começa" à string desta unidade semântica;
    Retorne.
  Se a string for "começar",
    Atribua "começa" à string desta unidade semântica;
    Retorne.
  Se a string for "termina",
    Atribua "termina" à string desta unidade semântica;
    Retorne.
  Se a string for "terminar",
    Atribua "termina" à string desta unidade semântica;
    Retorne.
  Se a string for "cabe",
    Atribua "cabe" à string desta unidade semântica;
    Retorne.
  Se a string for "couber",
    Atribua "cabe" à string desta unidade semântica;
    Retorne.
  Se a string for "sobre",
    Atribua "sobre" à string desta unidade semântica;
    Retorne.
  \ other
  Atribua a string à string desta unidade semântica.

Rotina para que se adicione uma unidade semântica para umas unidades semânticas usando um tipo:
  Crie a unidade semântica.
  Acrescente a unidade semântica para as unidades semânticas.
  Atribua o tipo ao tipo desta unidade semântica.

Rotina para que se adicione push fragmentos usando umas unidades semânticas:
  Se a rotina utilizada atualmente for inexistente, retorne.
  Itere.
    Obtenha uma unidade semântica desde as unidades semânticas (regressivamente).
    Se a unidade semântica for inexistente, retorne.
    Se a variável desta unidade semântica for inexistente, reitere.
    Se o subtexto atual desta unidade semântica não estiver em branco, reitere.
    Se o tipo atual desta unidade semântica for inexistente, reitere.
    Adicione um fragmento usando o etiqueta de inserção de endereço [na stack] e a variável desta unidade semântica.
  Reitere.

Rotina para que se adicione o atribua ou converta fragmentos usando uma variável e uma segunda variável e um endereço local:
  Adicione um fragmento usando o etiqueta de inserção de endereço [na stack] e a segunda variável.
  Adicione um segundo fragmento usando o etiqueta de inserção de endereço [na stack] e a variável.
  Encontre uma rotina usando "Atribua" e o tipo desta variável e "para" e o tipo desta segunda variável.
  Se a rotina for inexistente, encontre a rotina usando "Converta" e o tipo desta variável e "para" e o tipo desta segunda variável.
  Se a rotina não for inexistente,
    Adicione um terceiro fragmento usando a etiqueta de demanda interna e a rotina;
    Retorne.
  \ Mensagem de Erro
  Adicione uma unidade semântica para umas unidades semânticas usando "Atribua/Converta".
  Adicione uma segunda unidade semântica para as unidades semânticas usando o tipo desta variável.
  Adicione uma terceira unidade semântica para as unidades semânticas usando "para/a".
  Adicione uma quarta unidade semântica para as unidades semânticas usando o tipo desta segunda variável.
  Converta as unidades semânticas para uma representação interna da rotina.
  Destrua as unidades semânticas.
  Apresente uma mensagem de erro contendo "Erro. A rotina para que se " junto com a representação interna da rotina seguido de " ainda não foi definida." e o endereço local.



Rotina para que se adicione um scratch usando um nome do tipo e um endereço local:
  Se a rotina utilizada atualmente for inexistente,
    Esvazie o scratch;
    Retorne.
  Adicione o scratch para as variáveis locais desta rotina utilizada atualmente usando "scratch" e o endereço local.
  Gere o nome deste scratch usando "~S".
  Atribua o nome do tipo ao nome do tipo deste scratch.
  Destrinche o scratch.

Rotina para que se adicione fragmentos diversos usando uma string e uma variável e uma segunda string e uma segunda variável e um endereço local:
  Adicione um fragmento usando o etiqueta de inserção de endereço [na stack] e a segunda variável.
  Adicione um segundo fragmento usando o etiqueta de inserção de endereço [na stack] e a variável.
  Adicione uma unidade semântica para umas unidades semânticas usando a string.
  Adicione uma segunda unidade semântica para as unidades semânticas usando o tipo desta variável.
  Adicione uma terceira unidade semântica para as unidades semânticas usando a segunda string.
  Adicione uma quarta unidade semântica para as unidades semânticas usando o tipo desta segunda variável.
  Encontre uma rotina usando as unidades semânticas.
  Se a rotina for inexistente, converta as unidades semânticas para uma representação interna da rotina.
  Destrua as unidades semânticas.
  Se a rotina for inexistente,
    Apresente uma mensagem de erro contendo "Erro #3. A rotina para que se '" junto com a representação interna da rotina seguido de "' não foi encontrada." e o endereço local;
    Retorne.
  Adicione um terceiro fragmento usando a etiqueta de demanda interna e a rotina.

Rotina para que se adicione fragmentos diversos usando uma string e uma variável e uma segunda string e uma segunda variável e uma terceira string e um terceira variável e um endereço de byte :
  Adicione um fragmento usando o etiqueta de inserção de endereço [na stack] e o terceira variável.
  Adicione um segundo fragmento usando o etiqueta de inserção de endereço [na stack] e a segunda variável.
  Adicione um terceiro fragmento usando o etiqueta de inserção de endereço [na stack] e a variável.
  Adicione uma unidade semântica para umas unidades semânticas usando a string.
  Adicione uma segunda unidade semântica para as unidades semânticas usando o tipo desta variável.
  Adicione uma terceira unidade semântica para as unidades semânticas usando a segunda string.
  Adicione uma quarta unidade semântica para as unidades semânticas usando o tipo desta segunda variável.
  Adicione uma quinta unidade semântica para as unidades semânticas usando a terceira string.
  Adicione uma sexta unidade semântica para as unidades semânticas usando o tipo desta terceira variável.
  Encontre uma rotina usando as unidades semânticas.
  Se a rotina for inexistente, converta as unidades semânticas para uma representação interna da rotina.
  Destrua as unidades semânticas.
  Se a rotina for inexistente,
    Apresente uma mensagem de erro contendo "Erro #4. A rotina para que se '" junto com a representação interna da rotina seguido de "' não pôde ser localizada." e o endereço de byte;
    Retorne.
  Adicione um quarto fragmento usando a etiqueta de demanda interna e a rotina.



Rotina para que se adicione two fragmentos usando uma string e uma variável e um endereço local:
  Adicione um fragmento usando o etiqueta de inserção de endereço [na stack] e a variável.
  Adicione uma unidade semântica para umas unidades semânticas usando a string.
  Adicione uma segunda unidade semântica para as unidades semânticas usando o tipo desta variável.
  Encontre uma rotina usando as unidades semânticas.
  Se a rotina for inexistente, converta as unidades semânticas para uma representação interna da rotina.
  Destrua as unidades semânticas.
  Se a rotina for inexistente,
    Apresente uma mensagem de erro contendo "Erro. A rotina para que se '" junto com a representação interna da rotina seguido de "' ainda não foi definida." e o endereço local;
    Retorne.
  Adicione um segundo fragmento usando a etiqueta de demanda interna e a rotina.







Rotina para que se enderece umas funções:
  Obtenha uma função desde as funções.
  Se a função for inexistente, retorne.
  Enderece a função.
  Reitere.

Rotina para que se enderece uma função:
  Atribua o endereço do nome usado atualmente ao endereço do nome desta função.
  Atribua a quantidade de caracteres deste nome deste função mais 3 para um número.
  Arredonde o número para cima usando o múltiplo imediato de 2.
  Adicione o número para o endereço do nome usado atualmente.
  Atribua o endereço pré-calculado atual ao endereço thunk desta função.
  Atribua o image base mais o endereço pré-calculado atual ao endereço desta função.
  Adicione 4 para o endereço pré-calculado atual.

Rotina para que se enderece um fragmento usando um endereço:
  Se existir algum problema de compilação, retorne.
  Se o fragmento for inexistente, retorne.
  Atribua o image base mais o endereço ao endereço deste fragmento.
  Se a etiqueta deste fragmento for a etiqueta de inserção de endereço [na stack],
    Adicione 7 para o endereço;
    Retorne.
  Se a etiqueta deste fragmento for a etiqueta de demanda interna,
    Adicione 5 para o endereço;
    Retorne.
  Se a etiqueta deste fragmento for a etiqueta de carregamento de endereço,
    Adicione 12 para o endereço;
    Retorne.
  Se a etiqueta deste fragmento for a etiqueta de acréscimo,
    Adicione 10 para o endereço;
    Retorne.
  Se a etiqueta deste fragmento for a etiqueta de redirecionamento,
    Adicione 14 para o endereço;
    Retorne.
  Se a etiqueta deste fragmento for a etiqueta de desvio falso,
    Adicione 9 para o endereço;
    Retorne.
  Se a etiqueta deste fragmento for a etiqueta de negação lógica,
    Adicione 3 para o endereço;
    Retorne.
  Se a etiqueta deste fragmento for a etiqueta de retorno,
    Adicione 5 para o endereço;
    Retorne.
  Se a etiqueta deste fragmento for a etiqueta de repetição,
    Adicione 5 para o endereço;
    Retorne.
  Se a etiqueta deste fragmento for a etiqueta de interrupção,
    Adicione 5 para o endereço;
    Retorne.
  Se a etiqueta deste fragmento for a etiqueta preliminar,
    Enderece o fragmento usando o endereço (etapa preliminar);
    Retorne.
  Se a etiqueta deste fragmento for a etiqueta conclusiva,
    Enderece o fragmento usando o endereço (etapa conclusiva);
    Retorne.
  Se a etiqueta deste fragmento for a etiqueta de decodificação,
    Adicione a quantidade de caracteres deste código deste fragmento para o endereço;
    Retorne.
  Se a etiqueta deste fragmento for a etiqueta de inserção de valor [na stack],
    Enderece o fragmento usando o endereço (empilhamento de valor);
    Retorne.
  Se a etiqueta deste fragmento for a etiqueta de demanda externa,
    Adicione 6 para o endereço;
    Retorne.
  Se a etiqueta deste fragmento for a etiqueta de carregamento de registrador EAX,
    Adicione 5 para o endereço;
    Retorne. \ Era 8 quando "load eax" aceitava variáveis; agora "load eax" só aceita números
  Se a etiqueta deste fragmento for a etiqueta de obtenção do registrador EAX,
    Enderece o fragmento usando o endereço (registrador EAX);
    Retorne.
  Se a etiqueta deste fragmento for a etiqueta de demanda indireta,
    Adicione 8 para o endereço;
    Retorne.
  Se a etiqueta deste fragmento for a etiqueta de endereço de rotina,
    Adicione 12 para o endereço;
    Retorne.

Rotina para que se enderece um fragmento usando um endereço (etapa conclusiva):
  Se o sinalizador de compatibilidade desta rotina utilizada atualmente estiver ativo, adicione 3 para o endereço.
  Adicione 6 para o endereço.

Rotina para que se enderece um fragmento usando um endereço (etapa preliminar):
  Adicione 3 para o endereço.
  Se o tamanho local desta rotina utilizada atualmente não for 0, adicione 10 para o endereço.
  Se o sinalizador de compatibilidade desta rotina utilizada atualmente estiver ativo, adicione 3 para o endereço.

Rotina para que se enderece um fragmento usando um endereço (empilhamento de valor):
  Adicione 6 para o endereço.
  Se a variável deste fragmento for inexistente,
    Apresente uma mensagem de erro contendo "Erro #5. A variável '" junto com o nome desta variável deste fragmento seguido de "' é inválida.";
    Retorne.
  Se o tipo desta variável deste fragmento for inexistente,
    Apresente a mensagem de erro contendo "Erro #6. O tipo '" junto com o nome deste tipo desta variável deste fragmento seguido de "' é inválido.";
    Retorne.
  Atribua a quantidade de caracteres deste tipo desta variável deste fragmento para uma quantidade de caracteres.
  Se a quantidade de caracteres for 4,
    Adicione 2 para o endereço;
    Retorne.
  Se a quantidade de caracteres for 2,
    Adicione 3 para o endereço;
    Retorne.
  Se a quantidade de caracteres for 1,
    Adicione 4 para o endereço;
    Retorne.
  Apresente a mensagem de erro contendo "Erro #7.  A quantidade de bytes do tipo '" junto com o nome deste tipo desta variável deste fragmento seguido de "' é incompatível com a Stack.".

Rotina para que se enderece um fragmento usando um endereço (registrador EAX):
  Adicione 6 para o endereço.
  Se a variável deste fragmento for inexistente,
    Apresente uma mensagem de erro contendo "Erro #8. A variável '" junto com o nome desta variável deste fragmento seguido de "' é inválida";
    Retorne.
  Se o tipo desta variável deste fragmento for inexistente,
    Apresente a mensagem de erro contendo "Erro #9. O tipo '" junto com o nome deste tipo desta variável deste fragmento
      seguido de "da variável '" junto com o nome desta variável deste fragmento seguido de "' é inválido";
    Retorne.
  Atribua a quantidade de caracteres deste tipo desta variável deste fragmento para uma quantidade de caracteres.
  Se a quantidade de caracteres for 4,
    Adicione 2 para o endereço;
    Retorne.
  Se a quantidade de caracteres for 2,
    Adicione 3 para o endereço;
    Retorne.
  Se a quantidade de caracteres for 1,
    Adicione 2 para o endereço;
    Retorne.
  Apresente a mensagem de erro contendo "Erro #10. A quantidade de bytes do tipo '" 
    junto com o nome deste tipo desta variável deste fragmento seguido de "' é incompatível com o registrador EAX.".

Rotina para que se enderece uns fragmentos usando um endereço:
  Se existir algum problema de compilação, retorne.
  Obtenha um fragmento desde o fragmentos.
  Se o fragmento for inexistente, retorne.
  Enderece o fragmento usando o endereço.
  Reitere.

Rotina para que se enderece uma DLL:
  Atribua o endereço do nome usado atualmente ao endereço do nome desta DLL.
  Atribua o endereço do cabeçalho usado atualmente ao endereço do cabeçalho desta DLL.
  Atribua o endereço do nome usado atualmente ao endereço do nome deste cabeçalho da DLL desta DLL.
  Atribua a quantidade de caracteres deste nome desta DLL mais 1 para um número.
  Arredonde o número para cima usando o múltiplo imediato de 2.
  Adicione o número para o endereço do nome usado atualmente.
  Adicione a magnitude dum cabeçalho da DLL para o endereço do cabeçalho usado atualmente.
  Atribua o endereço pré-calculado atual ao primeiro endereço thunk de memória deste cabeçalho da DLL desta DLL.
  Enderece as funções desta DLL.
  Adicione 4 para o endereço pré-calculado atual.

Rotina para que se enderece umas DLLs usando um endereço:
  Atribua o endereço ao endereço do cabeçalho usado atualmente.
  Atribua as contagem destas DLLs para uma contagem.
  Adicione 1 para a contagem.
  Multiplique a contagem pela magnitude dum cabeçalho da DLL.
  Atribua o endereço mais a contagem ao endereço pré-calculado atual.
  Obtenha uma segunda contagem usando as DLLs (todas as funções mais os marcadores).
  Multiplique a segunda contagem por 4.
  Atribua o endereço pré-calculado atual mais a segunda contagem ao endereço do nome usado atualmente.
  Itere.
    Obtenha uma DLL desde as DLLs.
    Se a DLL for inexistente, pare.
    Enderece a DLL.
  Reitere.
  Atribua o endereço do nome usado atualmente menos o endereço para um número.
  Adicione o número para o endereço.

Rotina para que se enderece uma rotina usando um endereço:
  Se existir algum problema de compilação, retorne.
  Se a rotina for inexistente, retorne.
  Se o representação de emprego desta rotina não estiver em branco, retorne. \ employs são addressed later
  Se o sinalizador de compilação desta rotina não estiver ativo, retorne.
  Atribua a rotina à rotina utilizada atualmente.
  Atribua o image base mais o endereço ao endereço desta rotina.
  Enderece os fragmentos desta rotina usando o endereço.
  Arredonde o endereço para cima usando o múltiplo imediato de 4.

Rotina para que se enderece umas rotinas usando um endereço:
  Se existir algum problema de compilação, retorne.
  Obtenha uma rotina desde as rotinas.
  Se a rotina for inexistente, pare.
  Enderece a rotina usando o endereço.
  Reitere.

Rotina para que se enderece uma variável usando um endereço:
  Se existir algum problema de compilação, retorne.
  Se a variável for inexistente, retorne.
  Se o sinalizador de compilação desta variável não estiver ativo, retorne.
  Atribua o image base mais o endereço ao endereço desta variável.
  Adicione a quantidade de caracteres deste tipo desta variável para o endereço.
  Se o tipo desta variável puder ser reduzido para "string", adicione a quantidade de caracteres deste data desta variável mais 1 para o endereço.
  Se o tipo desta variável puder ser reduzido para "cadeia de caracteres", adicione a quantidade de caracteres deste data desta variável mais 1 para o endereço.
  Se o tipo desta variável puder ser reduzido para "texto", adicione a quantidade de caracteres deste data desta variável mais 1 para o endereço.
  Arredonde para cima o endereço usando o múltiplo imediato de 4.

Rotina para que se enderece umas variáveis usando um endereço:
  Se existir algum problema de compilação, retorne.
  Obtenha uma variável desde as variáveis.
  Se a variável for inexistente, retorne.
  Enderece a variável usando o endereço.
  Reitere.

Rotina para que se acrescente uma função para um trecho (com separador):
  Se a função for inexistente,
    Acrescente "(entrada não inicializada)" para o trecho (com separador);
    Retorne.
  Acrescente o nome desta função para o trecho (com separador).

Rotina para que se acrescente um sinalizador para um trecho (com separador):
  Converta o sinalizador para uma string.
  Acrescente a string para o trecho (com separador).

Rotina para que se acrescente os finalizadores de variáveis globais para uma string:
  Obtenha uma variável global desde as variáveis globais.
  Se a variável global for inexistente, retorne.
  Se o sinalizador de compilação desta variável global não estiver ativo, reitere.
  Se o tipo desta variável global não deveria ser finalizado, reitere.
  Acrescente "~Finalize o " junto com o nome desta variável global seguido de ". " para a string.
  Reitere.

Rotina para que se acrescente os inicializadores de variáveis globais para uma string:
  Obtenha uma variável global desde as variáveis globais.
  Se a variável global for inexistente, retorne.
  Se o valor literal desta variável global for inexistente, reitere.
  Se o sinalizador de compilação desta variável global não estiver ativo, reitere.
  Desative um sinalizador.
  Acrescente o texto inicializador desta variável global para a string.
  Reitere.

Rotina para que se acrescente uma unidade semântica para uma representação interna da rotina :
  Se a unidade semântica for inexistente, retorne.
  Se a representação interna da rotina não estiver em branco, acrescente o caractere de espaço para a representação interna da rotina.
  Se o tipo desta unidade semântica não for inexistente,
    Acrescente "[" e o nome deste tipo desta unidade semântica e "]" para a representação interna da rotina (rapidamente);
    Retorne. \ moniker
  Se a string desta unidade semântica não estiver em branco,
    Acrescente a string desta unidade semântica para a representação interna da rotina ;
    Retorne.

Rotina para que se acrescente uma unidade semântica para uma representação interna da rotina (inserção de colchetes):
  Se a unidade semântica for inexistente, retorne.
  Se a representação interna da rotina não estiver em branco, acrescente o caractere de espaço para a representação interna da rotina.
  Se o subtexto atual desta unidade semântica não estiver em branco,
    Acrescente o subtexto atual desta unidade semântica para a representação interna da rotina ;
    Retorne.
  Se o tipo atual desta unidade semântica não for inexistente,
    Acrescente "[" e o nome deste tipo atual desta unidade semântica e "]" para a representação interna da rotina (rapidamente);
    Retorne.

Rotina para que se acrescente um número para um trecho (cifra hexadecimal com separador):
  Converta o número para uma cifra hexadecimal.
  Acrescente a cifra hexadecimal para o trecho (com separador).

Rotina para que se acrescente um número para um trecho (com separador):
  Converta o número para uma string.
  Acrescente a string para o trecho (com separador).

Rotina para que se acrescente uma proporção para um trecho (com separador):
  Converta a proporção para uma string.
  \ Se a string for "0", acrescente "---" para o trecho; Retorne.
  Acrescente a string para o trecho (com separador).

Rotina para que se acrescente uma rotina para um trecho (com separador):
  Se a rotina for inexistente,
    Acrescente "(rotina inexistente)" para o trecho (com separador);
    Retorne.
  Acrescente a representação interna da rotina deste rotina para o trecho (com separador).

\ Rotina para que se acrescente 3 strings distintas para uma string.
Rotina para que se acrescente uma string e uma segunda string e uma terceira string para uma quarta string (rapidamente):
  Atribua a quantidade de caracteres desta quarta string para uma quantidade de caracteres. \ Atribua a quantidade de caracteres da 4ª string para uma quantidade de caracteres.
  Adicione a quantidade de caracteres desta string para a quantidade de caracteres. \ Atribua a quantidade de caracteres da 1ª string para a quantidade de caracteres.
  Adicione a quantidade de caracteres desta segunda string para a quantidade de caracteres. \ Atribua a quantidade de caracteres da 2ª string para a quantidade de caracteres.
  Adicione a quantidade de caracteres desta terceira string para a quantidade de caracteres. \ Atribua a quantidade de caracteres da 3ª string para a quantidade de caracteres.
  Reaponte um ponteiro usando a quantidade de caracteres.
  Atribua o ponteiro para um endereço de byte .
  Copie bytes desde o caractere inicial desta quarta string para o endereço de byte pelo quantidade de caracteres desta quarta string.
  Adicione a quantidade de caracteres desta quarta string para o endereço de byte .
  Copie bytes desde o caractere inicial desta string para o endereço de byte pelo quantidade de caracteres desta string.
  Adicione a quantidade de caracteres desta string para o endereço de byte .
  Copie bytes desde o caractere inicial desta segunda string para o endereço de byte pelo quantidade de caracteres desta segunda string.
  Adicione a quantidade de caracteres desta segunda string para o endereço de byte .
  Copie bytes desde o caractere inicial desta terceira string para o endereço de byte pelo quantidade de caracteres desta terceira string.
  Desassocie o caractere inicial desta quarta string.
  Atribua o ponteiro ao caractere inicial desta quarta string.
  Atribua o ponteiro mais a quantidade de caracteres menos 1 ao caractere final desta quarta string.

Rotina para que se acrescente uma string para um trecho (com separador):
  Acrescente a string para o trecho.
  Acrescente " | " para o trecho.

Rotina para que se acrescente uma etiqueta para um trecho (geral):
  Se a etiqueta for a etiqueta de interrupção,
    Acrescente "Interrupção do Laço" para o trecho (com separador);
    Retorne.
  Se a etiqueta for a etiqueta de demanda externa,
    Acrescente "Demanda Externa" para o trecho (com separador);
    Retorne.
  Se a etiqueta for a etiqueta de demanda indireta,
    Acrescente "Demanda Indireta" para o trecho (com separador);
    Retorne.
  Se a etiqueta for a etiqueta de demanda interna,
    Acrescente "Demanda Interna" para o trecho (com separador);
    Retorne.
  Se a etiqueta for a etiqueta de redirecionamento,
    Acrescente "Redirecionamento" para o trecho (com separador);
    Retorne.
  Se a etiqueta for a etiqueta delimitadora de bloco condicional,
    Acrescente "Fim de bloco condicional" para o trecho (com separador);
    Retorne.
  Se a etiqueta for a etiqueta conclusiva,
    Acrescente "Epílogo" para o trecho (com separador);
    Retorne.
  Se a etiqueta for a etiqueta de retorno,
    Acrescente "Retorno de Rotina" para o trecho (com separador);
    Retorne.
  Se a etiqueta for a etiqueta de finalização,
    Acrescente "Finalização" para o trecho (com separador);
    Retorne.
  Se a etiqueta for a etiqueta de acréscimo,
    Acrescente "Incremento" para o trecho (com separador);
    Retorne.
  Se a etiqueta for a etiqueta de decodificação,
    Acrescente "Decodificação" para o trecho (com separador);
    Retorne.
  Se a etiqueta for a etiqueta de desvio falso,
    Acrescente "Desvio de condição insatisfeita" para o trecho (com separador);
    Retorne.
  Se a etiqueta for a etiqueta de carregamento de endereço,
    Acrescente "Carregamento de endereço" para o trecho (com separador);
    Retorne.
  Se a etiqueta for a etiqueta de carregamento de registrador EAX,
    Acrescente "Atribuição EAX" para o trecho (com separador);
    Retorne.
  Se a etiqueta for a etiqueta de laço,
    Acrescente "Loop" para o trecho (com separador);
    Retorne.
  Se a etiqueta for a etiqueta de negação lógica,
    Acrescente "Negação Lógica" para o trecho (com separador);
    Retorne.
  Se a etiqueta for a etiqueta preliminar,
    Acrescente "Prólogo" para o trecho (com separador);
    Retorne.
  Se a etiqueta for a etiqueta de inserção de endereço [na stack],
    Acrescente "Empilhamento de endereço" para o trecho (com separador);
    Retorne.
  Se a etiqueta for a etiqueta de inserção de valor [na stack],
    Acrescente "Empilhamento de valor" para o trecho (com separador);
    Retorne.
  Se a etiqueta for a etiqueta de obtenção do registrador EAX,
    Acrescente "Requisição EAX" para o trecho (com separador);
    Retorne.
  Se a etiqueta for a etiqueta de repetição,
    Acrescente "Repetição" para o trecho (com separador);
    Retorne.
  Se a etiqueta for a etiqueta de endereço de rotina,
    Acrescente "Endereço de Rotina" para o trecho (com separador);
    Retorne.
  \ Se a etiquete for outra etiqueta,
  Acrescente "?" para o trecho (com separador).

Rotina para que se acrescente um tipo para um trecho (com separador):
  Se o tipo for inexistente,
    Acrescente "(tipo não inicializado)" para o trecho (com separador);
    Retorne.
  Acrescente o nome deste tipo para o trecho (com separador).

Rotina para que se acrescente uma variável para um trecho (com separador):
  Se a variável for inexistente,
    Acrescente "(variável não inicializada)" para o trecho (com separador);
    Retorne.
  Acrescente o nome desta variável para o trecho (com separador).

Função para que se determine se uma string é alguma contração de preposição com artigo definido:
  Se a string for "do", diga sim.
  Se a string for "da", diga sim.
  Se a string for "dos", diga sim.
  Se a string for "das", diga sim.
  Diga não.

Função para que se determine se uma string é algum operador de concatenação contraído usando um percorredor:
  Se o segmento inicial deste percorredor de contrações for "seguido", mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor de contrações for "seguida", mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor de contrações for "junto", mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor de contrações for "acompanhado", mova o percorredor (usando diretrizes de compilação).
  \Se o segmento inicial deste percorredor for uma variável, recue o percorredor.
  Se o segmento inicial deste percorredor de contrações for alguma contração de preposição com artigo definido, diga sim.
  Diga não.

Função para que se determine se uma string está precisando ser decomposta:
  Lance um percorredor sobre a string.
  Se a string for algum operador de concatenação contraído usando o percorredor, diga sim.
  Diga não.



Rotina para que se acrescente a instrução de carregamento de endereço para um texto hexadecimal usando uma variável:
  \ carrega o valor em edx
  Se a variável for inexistente,
    Acrescente $C7C200000000 para o texto hexadecimal; \ mov edx,0
    Retorne. 
  Se a categoria desta variável for "global",
    Acrescente $C7C2 e o endereço desta variável para o texto hexadecimal; \ mov edx, o endereço da variável
    Retorne. 
  Se a categoria desta variável for "literal",
    Acrescente $C7C2 e o endereço desta variável para o texto hexadecimal; \ mov edx, o endereço da variável
    Retorne. 
  Se a categoria desta variável for "local",
    Acrescente $8D95 e o deslocamento desta variável para o texto hexadecimal; \ lea edx,[ebp+ o deslocamento da variável]
    Retorne. 
  Se a categoria desta variável for "scratch",
    Acrescente $8B95 e o deslocamento desta variável para o texto hexadecimal; \ mov edx, [ebp+ o deslocamento da variável]
    Retorne. 
  Se a categoria desta variável não for "parâmetro",
    Apresente uma mensagem de erro contendo "Erro #11. A variável '" junto com o nome desta variável seguido de "' não é do tipo 'parâmetro.'";
    Retorne.
  Se o sinalizador de passagem por-valor desta variável estiver ativo,
    Acrescente $8D95 e o deslocamento desta variável para o texto hexadecimal; \ lea edx,[ebp+ o deslocamento da variável]
    Retorne. 
  Acrescente $8B95 e o deslocamento desta variável para o texto hexadecimal. \ mov edx,[ebp+ o deslocamento da variável]

Rotina para que se acrescente um texto hexadecimal e um endereço para um fragmento:
  \ Processe ou Salto
  Atribua o endereço para um número.
  Subtraia o endereço deste fragmento desde o número.
  Subtraia a quantidade de caracteres deste código deste fragmento desde o número.
  Subtraia a quantidade de caracteres deste texto hexadecimal desde o número.
  Subtraia 4 desde o número.
  Acrescente o texto hexadecimal e o número para o código deste fragmento.

Rotina para que se acrescente um texto hexadecimal e um número e um segundo texto hexadecimal para um terceiro texto hexadecimal:
  Acrescente o texto hexadecimal para o terceiro texto hexadecimal.
  Converta o número para um quarto texto hexadecimal.
  Acrescente o quarto texto hexadecimal para o terceiro texto hexadecimal.
  Acrescente o segundo texto hexadecimal para o terceiro texto hexadecimal.

Rotina para que se acrescente um texto hexadecimal e um número e um segundo número para um segundo texto hexadecimal:
  Acrescente o texto hexadecimal para o segundo texto hexadecimal.
  Converta o número para um terceiro texto hexadecimal.
  Acrescente o terceiro texto hexadecimal para o segundo texto hexadecimal.
  Converta o segundo número para um quarto texto hexadecimal.
  Acrescente o quarto texto hexadecimal para o segundo texto hexadecimal.

Rotina para que se acrescente um texto hexadecimal e um sinalizador para um segundo texto hexadecimal;
Rotina para que se acrescente um texto hexadecimal e um número para um segundo texto hexadecimal:
  Acrescente o texto hexadecimal para o segundo texto hexadecimal.
  Converta o número para um terceiro texto hexadecimal.
  Acrescente o terceiro texto hexadecimal para o segundo texto hexadecimal.

Rotina para que se disponibilize bytes usando um ponteiro e uma quantidade de caracteres e um trecho e um deslocamento:
  Atribua o caractere inicial deste trecho mais o deslocamento para um segundo ponteiro.
  Copie bytes desde o ponteiro para o segundo ponteiro pelo quantidade de caracteres.

Rotina para que se disponibilize um cabeçalho DOS para um trecho:
  Disponibilize bytes usando o endereçamento deste cabeçalho DOS e o magnitude deste cabeçalho DOS e o trecho e 0.

Rotina para que se disponibilize umas funções para um trecho:
  Obtenha uma função desde as funções.
  Se a função for inexistente, retorne.
  Disponibilize a função ao trecho.
  Reitere.

Rotina para que se disponibilize uma função para um trecho:
  Disponibilize bytes usando o endereçamento deste endereço do nome desta função e 4 e o trecho e o endereço thunk desta função.
  Atribua o endereço do nome desta função mais 2 para um endereço.
  Disponibilize o nome desta função ao trecho sob o endereço.

Rotina para que se disponibilize um fragmento para um trecho:
  Se o código deste fragmento estiver em branco, retorne.
  Atribua o endereço deste fragmento menos o image base para um endereço.
  Disponibilize o código deste fragmento ao trecho sob o endereço.

Rotina para que se disponibilize uns fragmentos para um trecho:
  Obtenha um fragmento desde o fragmentos.
  Se o fragmento for inexistente, retorne.
  Disponibilize o fragmento ao trecho.
  Reitere.

Rotina para que se disponibilize uma DLL para um trecho:
  Disponibilize bytes usando o endereçamento deste cabeçalho da DLL desta DLL e o magnitude deste cabeçalho da DLL desta DLL e o trecho e o endereço do cabeçalho desta DLL.
  Disponibilize o nome desta DLL ao trecho sob o endereço do nome desta DLL.
  Disponibilize as funções desta DLL ao trecho.

Rotina para que se disponibilize umas DLLs para um trecho:
  Obtenha uma DLL desde as DLLs.
  Se a DLL for inexistente, retorne.
  Disponibilize a DLL ao trecho.
  Reitere.

Rotina para que se disponibilize um Cabeçalho PE para um trecho:
  Disponibilize bytes usando o endereçamento deste Cabeçalho PE e o magnitude deste Cabeçalho PE e o trecho e 256.

Rotina para que se disponibilize uma rotina para um trecho:
  Se o sinalizador de compilação desta rotina não estiver ativo, retorne.
  Disponibilize os fragmentos desta rotina ao trecho.

Rotina para que se disponibilize umas rotinas para um trecho:
  Obtenha uma rotina desde as rotinas.
  Se a rotina for inexistente, retorne.
  Disponibilize a rotina ao trecho.
  Reitere.

Rotina para que se disponibilize uma string para um trecho sob um endereço:
  Disponibilize bytes usando o caractere inicial desta string e a quantidade de caracteres desta string e o trecho e o endereço.

Rotina para que se disponibilize uma variável para um trecho:
  Se o sinalizador de compilação desta variável não estiver ativo, retorne.
  Se o tipo desta variável puder ser reduzido para "string",
    Disponibilize a variável ao trecho (como um texto);
    Retorne.
  Se o tipo desta variável puder ser reduzido para "cadeia de caracteres",
    Disponibilize a variável ao trecho (como um texto);
    Retorne.
  Se o tipo desta variável puder ser reduzido para "texto",
    Disponibilize a variável ao trecho (como um texto);
    Retorne.
  Atribua o endereço desta variável menos o image base para um endereço. \ Atribua a diferença entre o endereço da variável e a base da imagem para um endereço.
  Disponibilize o data desta variável ao trecho sob o endereço.

Rotina para que se disponibilize uma variável para um trecho (como um texto):
  Atribua o endereço desta variável menos o image base para um endereço.
  Atribua a quantidade de caracteres deste data desta variável para uma quantidade de caracteres.
  Atribua o endereço para um segundo endereço.
  Adicione a magnitude dum protótipo de string para o segundo endereço.
  Adicione o image base para o segundo endereço.
  Atribua 0 ao caractere inicial deste protótipo de string.
  Atribua -1 ao caractere final deste protótipo de string.
  Se a quantidade de caracteres não for 0, atribua o segundo endereço ao caractere inicial deste protótipo de string.
  Se a quantidade de caracteres não for 0, atribua o caractere inicial deste protótipo de string mais a quantidade de caracteres menos 1 ao caractere final deste protótipo de string.
  Disponibilize bytes usando o endereçamento deste protótipo de string e a magnitude deste protótipo de string e o trecho e o endereço.
  Adicione a magnitude [tamanho em bytes] deste protótipo de string para o endereço.
  Disponibilize os data desta variável ao trecho sob o endereço.

Rotina para que se disponibilize umas variáveis para um trecho:
  Obtenha uma variável desde as variáveis.
  Se a variável for inexistente, retorne.
  Disponibilize a variável ao trecho.
  Reitere.

Rotina para que se defina o tipo de uma unidade semântica:
  Se a unidade semântica for inexistente, retorne.
  Se o subtexto atual desta unidade semântica não estiver em branco,
    Limpe o subtexto atual desta unidade semântica;
    Retorne.
  Se o tipo atual desta unidade semântica for inexistente, retorne.
  Se o tipo atual desta unidade semântica for algum tipo pré-definido,
    Atribua nil ao tipo atual desta unidade semântica;
    Retorne.
  Atribua o tipo base deste tipo atual desta unidade semântica ao tipo atual desta unidade semântica.

Rotina para que se calcule a quantidade de caracteres referentes para um tipo;
Rotina para que se calcule a quantidade de caracteres referente para um tipo:
  Se o tipo for inexistente, retorne.
  Se a quantidade de caracteres deste tipo não for -1, retorne.
  Calcule a quantidade de caracteres referente ao tipo base deste tipo.
  Se os campos deste tipo estiverem vazios,
    Atribua a quantidade de caracteres deste tipo base deste tipo à quantidade de caracteres deste tipo;
    Retorne.
  Atribua 0 à quantidade de caracteres deste tipo.
  Itere.
    Se existir algum problema de compilação, retorne.
    Obtenha um campo desde o campos deste tipo.
    Se o campo for inexistente, retorne.
    Se o novo nome deste campo não estiver em branco, reitere.
    Calcule a quantidade de caracteres referente ao tipo deste campo.
    Adicione a quantidade de caracteres deste tipo deste campo vezes a contagem deste campo para a quantidade de caracteres deste tipo.
  Reitere.

Rotina para que se calcule os comprimentos referentes para uns tipos;
Rotina para que se calcule os comprimentos referente para uns tipos:
  Se existir algum problema de compilação, retorne.
  Obtenha um tipo desde o tipos.
  Se o tipo for inexistente, retorne.
  Calcule a quantidade de caracteres referente ao tipo.
  Reitere.

Rotina para que se calcule os deslocamentos em um tipo:
  Se o tipo for inexistente, retorne.
  Atribua 0 para um deslocamento.
  Itere.
    Se existir algum problema de compilação, retorne.
    Obtenha um campo desde os campos deste tipo.
    Se o campo for inexistente, retorne.
    Se o novo nome deste campo não estiver em branco, reitere.
    Atribua o deslocamento ao deslocamento deste campo.
    Adicione a quantidade de caracteres deste tipo deste campo vezes a contagem deste campo para o deslocamento.
  Reitere.

Rotina para que se calcule os deslocamentos em uns tipos:
  Se existir algum problema de compilação, retorne.
  Obtenha um tipo desde o tipos.
  Se o tipo for inexistente, retorne.
  Calcule os deslocamentos no tipo.
  Reitere.

Rotina para que se calcule os deslocamentos das redefinições em um tipo:
  Se o tipo for inexistente, retorne.
  Itere.
    Se existir algum problema de compilação, retorne.
    Obtenha um campo desde os campos deste tipo.
    Se o campo for inexistente, retorne.
    Se o novo nome deste campo estiver em branco, reitere.
    Encontre um segundo campo usando o novo nome deste campo e os campos deste tipo.
    Se o segundo campo for inexistente,
      Apresente uma mensagem de erro contendo "Erro #12. Palavra-chave 'sob' utilizada incorretamente. O campo '" 
        junto com o novo nome deste campo seguido de "' da estrutura '"
        junto com o nome deste tipo seguido de "' não pode ser encontrado." e o endereço local deste campo;
      Retorne.
    Atribua o deslocamento deste segundo campo ao deslocamento deste campo.
  Reitere.

Rotina para que se calcule os deslocamentos das redefinições em uns tipos:
  Se existir algum problema de compilação, retorne.
  Obtenha um tipo desde o tipos.
  Se o tipo for inexistente, retorne.
  Calcule os deslocamentos das redefinições no tipo.
  Reitere.





Rotina para que se limpe um campo de estrutura:
  Preencha bytes com o caractere null começando sob o endereçamento deste campo de estrutura pelo magnitude deste campo de estrutura.

Rotina para que se limpe um termo:
  Esvazie a variável deste termo.
  Limpe o frase deste termo.

Rotina para que se compile os corpos referentes para as rotinas:
  Compile o corpo referente à rotina denominada "Inicialize antes da execução".
  Compile o corpo referente à rotina denominada "Execute o programa".
  Compile o corpo referente à rotina denominada "Finalize após execução".

Rotina para que se compile o corpo referente para uma rotina:
  Se a rotina for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Se o sinalizador de compilação desta rotina estiver ativo, retorne.
  Ative o sinalizador de compilação desta rotina.
  Lance um percorredor sobre as instruções desta rotina.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for o ponto&vírgula,
    Compile o corpo referente à rotina usando o percorredor (sobrecarga de métodos);
    Retorne. \ *** alternate wording
  \Se o segmento inicial deste percorredor for uma palavra-chave de reutilização de rotina, compile o corpo referente à rotina usando o percorredor (cláusula de reutilização); Retorne.
  Atribua a rotina utilizada atualmente para um saved rotina.
  Atribua a rotina à rotina utilizada atualmente.
  Crie o catálogo de apelidos desta rotina usando 101.
  Elimine apelidos duplicados desde os parâmetros desta rotina usando o catálogo de apelidos desta rotina.
  Compile o corpo referente à rotina (etapa preliminar).
  Itere.
    Se existir algum problema de compilação, retorne.
    Se o segmento inicial deste percorredor estiver em branco, pare.
    Compile a próxima instrução usando o percorredor.
  Reitere.
  Compile o corpo referente à rotina (etapa conclusiva).
  Atribua o saved rotina à rotina utilizada atualmente.
  \Destrua o catálogo de apelidos desta rotina.

Rotina para que se compile o corpo referente para uma rotina (etapa conclusiva):
  Se a rotina for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Adicione um fragmento usando a etiqueta de finalização.
  Itere.
    Obtenha uma variável desde as variáveis locais desta rotina.
    Se a variável for inexistente, pare.
    Se a categoria desta variável for "scratch", reitere.
    Se o tipo desta variável não deveria ser finalizado, reitere.
    Adicione um segundo fragmento usando o etiqueta de inserção de endereço [na stack] e a variável.
    Encontre uma segunda rotina usando "~Finalize" e o tipo desta variável.
    Se a segunda rotina for inexistente,
      Apresente uma mensagem de erro contendo "Erro #16. A rotina para que se finalize um '" junto com o tipo desta variável seguido de "' não foi encontrada'";
      Retorne.
    Adicione um terceiro fragmento usando a etiqueta de demanda interna e a segunda rotina.
  Reitere.
  Adicione um quarto fragmento usando o etiqueta conclusiva.

Rotina para que se compile o corpo referente para uma rotina usando um percorredor (sobrecarga de métodos):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação). \ *** do we need this?
  Atribua a próxima rotina desta rotina para um rotina alvo.
  Se a rotina alvo for inexistente,
    Apresente uma mensagem de erro contendo "Erro #17. Não foi possível encontrar o cabeçalho alternativo desta rotina." e o percorredor;
    Retorne.
  Atribua a representação interna da rotina deste rotina alvo ao representação de emprego desta rotina.
  Compile o corpo referente ao rotina alvo.

Rotina para que se compile o corpo referente para uma rotina (etapa preliminar):
  Se a rotina for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Adicione um fragmento usando o etiqueta preliminar.
  Adicione um segundo fragmento usando o etiqueta de laço.

Rotina para que se compile o corpo referente para a rotina denominada uma string;
Rotina para que se compile o corpo referente para a rotina denominado uma string:
  Se existir algum problema de compilação, retorne.
  Encontre uma rotina usando a string e o catálogo geral de rotinas.
  Se a rotina for inexistente,
    Apresente uma mensagem de erro contendo "Erro #18. A rotina 'para que se " junto com a string seguido de "' não pode ser encontrada.";
    Retorne.
  Compile o corpo referente à rotina.

Rotina para que se compile o corpo referente para uma rotina usando um percorredor (cláusula de reutilização):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile uma referência da rotina usando o percorredor.
  Converta a referência da rotina para o representação de emprego desta rotina.
  Destrua a referência da rotina.
  Se o segmento inicial deste percorredor não for ".",
    Apresente uma mensagem de erro contendo "Erro #19. O comando 'Empregue' deve terminar com um '.' ao invés de '" junto com o segmento inicial deste percorredor seguido de "'." e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não estiver em branco,
    Apresente a mensagem de erro contendo "Erro #20. Permitido apenas uma cláusula de reutilização dentro de cada rotina" e o percorredor;
    Retorne.
  Encontre uma segunda rotina usando o representação de emprego desta rotina e o catálogo geral de rotinas.
  Se a segunda rotina for inexistente,
    Apresente a mensagem de erro contendo "Erro #21. A rotina para que se '" junto com o representação de emprego desta rotina seguido de "' não foi encontrada." e o endereço local desta rotina;
    Retorne.
  Compile o corpo referente à segunda rotina.

Rotina para que se compile a parte designadora usando um percorredor e uma variável:
  Se existir algum problema de compilação, retorne.
  Se a variável for inexistente, retorne.
  Atribua o nome desta variável ao nome do tipo desta variável.
  Mova o percorredor (usando diretrizes de compilação).
  Examine o nome desta variável usando o percorredor.



\ to define a global variable given a string:
  \ if the compiler's abort flag is set, exit.
  \ privatize the string.
  \ if the string starts with "the ",
    \ remove leading bytes from the string given 4.
  \ trim the string.
  \ slap a rider on the string.
  \ scan a global given the rider.
  \ put nil in the global's locus.
  \ twin the global returning another global.
  \ append the other global to the predefined globals.

Rotina para que se defina uma variável global usando uma string:
  Se existir algum problema de compilação, retorne.
  Preserve a string.
  Se a string começa com "O ", remova os caracteres iniciais desde a string usando 2.
  Se a string começa com "A ", remova os caracteres iniciais desde a string usando 2.
  Se a string começa com "Os ", remova os caracteres iniciais desde a string usando 3.
  Se a string começa com "As ", remova os caracteres iniciais desde a string usando 3.
  Remova os caracteres ignoráveis no final de a string.
  Lance um percorredor sobre a string.
  Examine uma variável global usando o percorredor.
  Atribua inexistente no endereço local desta variável global.
  Duplique a variável global retornando uma segunda variável global.
  Acrescente a segunda variável global para as variáveis globais prededinidas.

Rotina para que se duplique uma variável global retornando uma segunda variável global:
  Se a variável global for inexistente, retorne.
  Se a segunda variável global for inexistente, 
    Aloque memória para a segunda variável global.
  Atribua a categoria desta variável global para a categoria desta segunda variável global.
  Atribua o nome desta variável global para o nome desta segunda variável global.
  Atribua o nome do tipo desta variável global para o nome do tipo desta segunda variável global.
  Atribua o corpo de variável global desta variável global para o corpo de variável global desta segunda variável global.

Rotina para que se compile um endereço da pasta usando um nível de profundidade:
  Atribua 1 ao nível de profundidade.
  Compile o endereço da pasta (inicialização). \ Etapa #001
  Compile o endereço da pasta (arquivos de código fonte). \ Etapa #002
  \Compile o endereço da pasta usando o nível de profundidade (arquivos de código fonte). \ Etapa #002
  Defina uma variável global usando "O código de retorno é um número.".
  Compile o endereço da pasta (análise dos arquivos fornecidos). \ Etapa #003
  Compile o endereço da pasta (identificação dos tipos das variáveis). \ Etapa #004
  Compile o endereço da pasta (identificação de variáveis globais). \ Etapa #005
  Compile o endereço da pasta (cabeçalhos de rotinas). \ Etapa #006
  Compile o endereço da pasta (cálculo de tamanhos e deslocamentos). \ Etapa #007
  Compile o endereço da pasta (adição de rotinas de memória incorporadas). \ Etapa #008
  Compile o endereço da pasta (catalogue as rotinas por utilização). \ Etapa #009
  Compile o endereço da pasta (conteúdo das rotinas). \ Etapa #010
  Compile o endereço da pasta (adição e compilação da rotina de inicialização). \ Etapa #011
  Compile o endereço da pasta (deslocamento de parâmetros e variáveis). \ Etapa #012
  Compile o endereço da pasta (endereço). \ Etapa #013
  Compile o endereço da pasta (transmutação). \ Etapa #014
  Compile o endereço da pasta (vinculação). \ Etapa #015
  Compile o endereço da pasta (etapa final). \ Etapa #016
  Compile o endereço da pasta (interrupção). \ Etapa #017

Rotina para que se compile um endereço da pasta usando um nível de profundidade (arquivos de código fonte): \#002
  Se existir algum problema de compilação, retorne.
  Escreva "Carregando arquivos..." junto com o texto CRLF para StdOut.
  Comece o temporizador de operacionalização.
  Carregue os arquivos fontes usando o nível de profundidade.
  Suspenda o temporizador de operacionalização.

Rotina para que se compile uma expressão matematica usando um percorredor:
  Se existir algum problema de compilação, retorne.
  Compile um termo usando o percorredor.
  Atribua o termo ao expressão matematica.
  Itere.
    Se existir algum problema de compilação, retorne.
    Se o segmento inicial deste percorredor não for algum operador aritmético, retorne.
    Se o segmento inicial deste percorredor for algum operador de divisão,
    Compile o expressão matematica usando o percorredor (operador de divisão);
    Reitere.
    Se o segmento inicial deste percorredor for algum operador de subtração,
    Compile o expressão matematica usando o percorredor (operador de subtração);
    Reitere.
    Se o segmento inicial deste percorredor for algum operador de adição,
    Compile o expressão matematica usando o percorredor (operador de adição);
    Reitere.
    Se o segmento inicial deste percorredor for algum operador de concatenação,
    Compile o expressão matematica usando o percorredor (operador de concatenação);
    Reitere.
    Se o segmento inicial deste percorredor for algum operador de multiplicação,
    Compile o expressão matematica usando o percorredor (operador de multiplicação);
    Reitere.
    Se o segmento inicial deste percorredor for "junto",
    Compile o expressão matematica usando o percorredor (operador de concatenação);
    Reitere.
    Se o segmento inicial deste percorredor for "juntamente",
    Compile o expressão matematica usando o percorredor (operador de concatenação);
    Reitere.
    Se o segmento inicial deste percorredor for "seguido",
    Compile o expressão matematica usando o percorredor (operador de concatenação);
    Reitere.
    Se o segmento inicial deste percorredor for "acompanhado",
    Compile o expressão matematica usando o percorredor (operador de concatenação);
    Reitere.

Rotina para que se compile uma expressão matematica usando um percorredor (operador de divisão):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum objeto indireto,
    Apresente uma mensagem de erro contendo "Erro #22. Você deve usar o termo 'dividido POR'." e o percorredor;
    Retorne.
  Se a variável desta expressão matematica for inexistente,
    Apresente a mensagem de erro contendo "Erro #23. Comando 'dividido por' inválido. Erro na variável  '" junto com a frase desta expressão matematica seguido de "'." e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile um termo usando o percorredor.
  Se existir algum problema de compilação, retorne.
  Se a variável deste termo for inexistente,
    Apresente a mensagem de erro contendo "Erro #24. O comando 'dividido por', está errado. Não é possível dividir por '" junto com a frase deste termo seguido de "'." e o percorredor;
    Retorne.
  Adicione uma variável intermediária usando o nome do tipo desta expressão matematica e o caractere inicial deste segmento inicial deste percorredor.
  Adicione fragmentos diversos usando "Atribua" e a variável desta expressão matematica e "para" e a variável intermediária e o caractere inicial deste segmento inicial deste percorredor.
  Adicione fragmentos diversos usando "Divida" e a variável intermediária e "por" e a variável deste termo e o caractere inicial deste segmento inicial deste percorredor.
  Atribua a variável intermediária à variável desta expressão matematica.
  Limpe a frase desta expressão matematica.

Rotina para que se compile uma expressão matematica usando um percorredor (operador de subtração):
  Se existir algum problema de compilação, retorne.
  Se a variável desta expressão matematica for inexistente,
    Apresente uma mensagem de erro contendo "Erro #25. O comando 'menos', está incorreto. Não é possível subtrair de '" junto com a frase desta expressão matematica seguido de "'." e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile um termo usando o percorredor.
  Se existir algum problema de compilação, retorne.
  Se a variável deste termo for inexistente,
    Apresente a mensagem de erro contendo "Erro #26. O comando 'menos', está incorreto. Não consigo diminuir de '" junto com a frase deste termo seguido de "'." e o percorredor;
    Retorne.
  Adicione uma variável intermediária usando o nome do tipo desta expressão matematica e o caractere inicial deste segmento inicial deste percorredor.
  Adicione fragmentos diversos usando "Atribua" e a variável desta expressão matematica e "para" e a variável intermediária e o caractere inicial deste segmento inicial deste percorredor.
  Adicione fragmentos diversos usando "Subtraia" e a variável deste termo e "desde" e a variável intermediária e o caractere inicial deste segmento inicial deste percorredor.
  Atribua a variável intermediária à variável desta expressão matematica.
  Limpe a frase desta expressão matematica.

Rotina para que se compile uma expressão matematica usando um percorredor (operador de adição):
  Se existir algum problema de compilação, retorne.
  Se a variável desta expressão matematica for inexistente,
    Apresente uma mensagem de erro contendo "Erro #27. Comando 'mais' incorreto. Não é possível somar o '" junto com a frase desta expressão matematica seguido de "'." e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação). \talvez fosse o caso de repetir aqui
  Compile um termo usando o percorredor.
  Se existir algum problema de compilação, retorne.
  Se a variável deste termo for inexistente,
    Apresente a mensagem de erro contendo "Erro #28. Comando 'mais' incorreto. Não é possível adicionar o" junto com a frase deste termo seguido de "." e o percorredor;
    Retorne.
  Adicione uma variável intermediária usando o nome do tipo desta expressão matematica e o caractere inicial deste segmento inicial deste percorredor.
  Adicione fragmentos diversos usando "Atribua" e a variável desta expressão matematica e "para" e a variável intermediária e o caractere inicial deste segmento inicial deste percorredor.\aqui muda o atribua
  Adicione fragmentos diversos usando "Adicione" e a variável deste termo e "para" e a variável intermediária e o caractere inicial deste segmento inicial deste percorredor. \ aqui muda o add
  Atribua a variável intermediária à variável desta expressão matematica.
  Limpe a frase desta expressão matematica.

Rotina para que se compile uma expressão matematica usando um percorredor (operador de concatenação):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for alguma palavra de concatenação,
    Apresente uma mensagem de erro contendo "Erro #29. Necessário escrever 'junto DE/junto COM/etc'." e o percorredor;
    Retorne.
  Se a variável desta expressão matematica for inexistente,
    Apresente a mensagem de erro contendo "Erro #30. A variável da expressão matematica: " junto com a frase desta expressão matematica seguido de " é inválida." e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile um termo usando o percorredor.
  Se existir algum problema de compilação, retorne.
  Se a variável deste termo for inexistente,
    Apresente a mensagem de erro contendo "Erro #31. A variável do termo '" junto com a frase deste termo seguido de "' é inválida." e o percorredor;
    Retorne.
  Adicione uma variável intermediária usando "string" e o caractere inicial deste segmento inicial deste percorredor.
  \Adicione uma variável intermediária usando "texto" e o caractere inicial deste segmento inicial deste percorredor.
  \Adicione uma variável intermediária usando "cadeia de caracteres" e o caractere inicial deste segmento inicial deste percorredor.
  Adicione o atribua ou converta fragmentos usando a variável desta expressão matematica e a variável intermediária e o caractere inicial deste segmento inicial deste percorredor.
  Converta o termo por concatenação usando o percorredor. \\ aqui faz a concatenação
  Adicione fragmentos diversos usando "Acrescente" e a variável deste termo e "para" e a variável intermediária e o caractere inicial deste segmento inicial deste percorredor.
  Atribua a variável intermediária à variável desta expressão matematica.
  Limpe a frase desta expressão matematica.

Rotina para que se compile uma expressão matematica usando um percorredor (operador de multiplicação):
  Se existir algum problema de compilação, retorne.
  Se a variável desta expressão matematica for inexistente,
    Apresente uma mensagem de erro contendo "Erro #32. Erro de sintaxe. Comando 'vezes' incorreto. Não é póssível multiplicar por '"
    junto com a frase desta expressão matematica seguido de "'." e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile um termo usando o percorredor.
  Se existir algum problema de compilação, retorne.
  Se a variável deste termo for inexistente,
    Apresente a mensagem de erro contendo "Erro #33. Erro de sintaxe. Comando 'multiplicado por' incorreto. Não é póssível multiplicar por '" 
    junto com a frase deste termo seguido de "'." e o percorredor;
    Retorne.
  Adicione uma variável intermediária usando o nome do tipo desta expressão matematica e o caractere inicial deste segmento inicial deste percorredor.
  Adicione fragmentos diversos usando "Atribua" e a variável desta expressão matematica e "para" e a variável intermediária e o caractere inicial deste segmento inicial deste percorredor.
  Adicione fragmentos diversos usando "Multiplique" e a variável intermediária e "por" e a variável deste termo e o caractere inicial deste segmento inicial deste percorredor.
  Atribua a variável intermediária à variável desta expressão matematica.
  Limpe a frase desta expressão matematica.

Rotina para que se compile o cabeçalho referente para uma rotina:
  Se a rotina for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Lance um percorredor sobre a cabeçalho de rotina desta rotina.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for algum comando de deliberação,
    Compile o cabeçalho referente à rotina usando o percorredor (rotina deliberativa);
    Retorne.
  Se o percorredor for o início de alguma função possessiva reversa,
    Compile o cabeçalho referente à rotina usando o percorredor (função do possessivo reverso);
    Retorne.
  Se o percorredor for o início de alguma função,
    Compile o cabeçalho referente à rotina usando o percorredor (função);
    Retorne.
  Se o segmento inicial deste percorredor for "compativelmente",
    Compile o cabeçalho referente à rotina usando o percorredor (modo de compatibilidade);
    Retorne.
  Compile o cabeçalho referente à rotina usando o percorredor (procedimento).

Rotina para que se compile o cabeçalho referente para uma rotina usando um percorredor (modo de compatibilidade): \ callback
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Ative o sinalizador de compatibilidade desta rotina.
  Compile as unidades semânticas desta rotina e os parâmetros desta rotina usando o percorredor.
  Converta as unidades semânticas desta rotina para a representação interna da rotina desta rotina.
  Se a representação interna da rotina desta rotina estiver no catálogo geral de rotinas,
    Apresente uma mensagem de erro contendo "Erro #34. A rotina para que se '" 
    junto com a representação interna da rotina desta rotina seguido de "' já foi definida anteriormente." 
    e o endereço local desta rotina;
    Retorne.
  Catalogue a rotina usando as unidades semânticas desta rotina e o catálogo geral de rotinas.

Rotina para que se compile o cabeçalho referente para uma rotina usando um percorredor (rotina deliberativa):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum comando condicional,
    Apresente uma mensagem de erro contendo "Erro #35. Rotina 'Para que se determine se' com sintaxe inválida" e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Ative o sinalizador de deliberação desta rotina.
  Compile as unidades semânticas desta rotina e os parâmetros desta rotina usando o percorredor.
  Se algumas dentre as unidades semânticas desta rotina forem advérbios de negação,
    Apresente a mensagem de erro contendo "Erro #36. A palavra-chave 'não' não é permitida em cabeçalhos de funções booleanas." e o percorredor;
    Retorne.
  Converta as unidades semânticas desta rotina para a representação interna da rotina desta rotina.
  Se a representação interna da rotina desta rotina estiver no catálogo geral de rotinas,
    Apresente a mensagem de erro contendo "Erro #37. A rotina para que se ''" 
    junto com a representação interna da rotina desta rotina seguido de "' já havia sido definida anteriormente." e o endereço local desta rotina;
    Retorne.
  Catalogue a rotina usando as unidades semânticas desta rotina e o catálogo geral de rotinas.

Rotina para que se compile o cabeçalho referente para uma rotina usando um percorredor (função):
  Se existir algum problema de compilação, retorne.
  Ative o sinalizador de função desta rotina.
  Adicione uma unidade semântica para as unidades semânticas desta rotina usando "atribua".
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for algum artigo indefinido, ative um sinalizador.
  Se o sinalizador estiver ativo, compile as unidades semânticas desta rotina e os parâmetros desta rotina usando o percorredor (artigo indefinido).
  Se o sinalizador não estiver ativo, compile as unidades semânticas desta rotina e os parâmetros desta rotina usando o percorredor (artigo definido).
  Se o segmento inicial deste percorredor não for algum possessivo inglês,
    Apresente uma mensagem de erro contendo "Erro #38. Necessário inserir um 's no código." e o percorredor;
    Retorne. \ not translated - no possessives em Spanish
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Adicione uma segunda unidade semântica para as unidades semânticas desta rotina usando "'s " junto com o nome.
  Se o segmento inicial deste percorredor não for "para",
    Apresente a mensagem de erro contendo "Erro #39. palavra-chave 'para' ausente. Encontrado a palavra: " 
    junto com o segmento inicial deste percorredor seguido de "." e o percorredor;
    Retorne. \ not translated - no possessives em Spanish
  Adicione uma terceira unidade semântica para as unidades semânticas desta rotina usando "para".
  Converta as unidades semânticas desta rotina para uma representação interna da rotina.
  Se a representação interna da rotina estiver no catálogo geral de rotinas,
    Apresente a mensagem de erro contendo "Erro #40. Rotina para que se '" 
    junto com a representação interna da rotina seguido de "' já definida." e o endereço local desta rotina;
    Retorne. \ not translated - no possessives em Spanish
  Catalogue a rotina usando as unidades semânticas desta rotina e o catálogo geral de rotinas.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum artigo indefinido,
    Apresente a mensagem de erro contendo "Erro #41. Necessário artigo indefinido. Encontrado '" 
    junto com o segmento inicial deste percorredor seguido de "'." e o percorredor;
    Retorne. \ not translated - no possessives em Spanish
  Compile as unidades semânticas desta rotina e os parâmetros desta rotina usando o percorredor (artigo indefinido).
  Se o segmento inicial deste percorredor não estiver em branco,
    Apresente a mensagem de erro contendo "Erro #42. Encontrado comandos extras no fim desta rotina." e o percorredor;
    Retorne. \ not translated - no possessives em Spanish
  Converta as unidades semânticas desta rotina para a representação interna da rotina desta rotina.
  Catalogue a rotina usando as unidades semânticas desta rotina e o catálogo geral de rotinas. \ para employs

Rotina para que se compile o cabeçalho referente para uma rotina usando um percorredor (procedimento):
  Se existir algum problema de compilação, retorne.
  Compile as unidades semânticas desta rotina e os parâmetros desta rotina usando o percorredor.
  Converta as unidades semânticas desta rotina para a representação interna da rotina desta rotina.
  Se a representação interna da rotina desta rotina estiver no catálogo geral de rotinas,
    Apresente uma mensagem de erro contendo "Erro #43. Rotina para que se '" 
    junto com a representação interna da rotina desta rotina seguido de "' já codificada." e o endereço local desta rotinas;
    Retorne.
  Catalogue a rotina usando as unidades semânticas desta rotina e o catálogo geral de rotinas.

Rotina para que se compile os cabelalhos referente para umas rotinas:
  Se existir algum problema de compilação, retorne.
  Obtenha uma rotina desde as rotinas.
  Se a rotina for inexistente, retorne.
  Compile o cabeçalho referente à rotina.
  Reitere.

Rotina para que se compile um valor literal usando um percorredor:
  Se existir algum problema de compilação, retorne.
  Adicione o valor literal para os valores literais usando o caractere inicial deste segmento inicial deste percorredor .
  \Se o segmento inicial deste percorredor for algum sinalizador literal, compile o valor literal usando o percorredor (valores booleanos); Retorne.
  \Se o segmento inicial deste percorredor for algum número ordinal,
    \Compile o valor literal usando o percorredor (números ordinais);
    \Retorne.
  Se o segmento inicial deste percorredor for algum valor hexadecimal literal,
    Compile o valor literal usando o percorredor (valores hexadecimais);
    Retorne.
  Se o segmento inicial deste percorredor for algum valor numérico literal,
    Compile o valor literal usando o percorredor (valor numérico - análise preliminar);
    Retorne.
  Se o segmento inicial deste percorredor for algum ponteiro literal,
    Compile o valor literal usando o percorredor (ponteiros);
    Retorne.
  Se o segmento inicial deste percorredor for algum string literal,
    Compile o valor literal usando o percorredor (cadeia de caracteres);
    Retorne.
  Apresente uma mensagem de erro contendo "Erro interno #44. O valor '" 
  junto com o segmento inicial deste percorredor  seguido de "' não pode ser compilado." e o percorredor.



Rotina para que se compile um valor literal usando um percorredor (valores booleanos):
  Se existir algum problema de compilação, retorne.
  Converta o segmento inicial deste percorredor para um sinalizador.
  Converta o sinalizador para os data deste valor literal.
  Mova o percorredor (usando diretrizes de compilação).
  Atribua "sinalizador" ao nome do tipo deste valor literal.
  Destrinche o valor literal. \ 

Rotina para que se compile um valor literal usando um percorredor (valores hexadecimais):
  Se existir algum problema de compilação, retorne.
  Atribua o segmento inicial deste percorredor para um parte da cifra binária.
  Adicione 1 para o caractere inicial desta parte da cifra binária.
  Converta o parte da cifra binária para o data deste valor literal.
  Mova o percorredor (usando diretrizes de compilação).
  Atribua "texto hexadecimal" ao nome do tipo deste valor literal.
  Destrinche o valor literal.

Rotina para que se compile um valor literal usando um percorredor (valor numérico - números inteiros):
  Se existir algum problema de compilação, retorne.
  Converta o segmento inicial deste percorredor para um número.
  Converta o número para os data deste valor literal.
  Mova o percorredor (usando diretrizes de compilação).
  Atribua "número" ao nome do tipo deste valor literal.
  Destrinche o valor literal.

Rotina para que se compile um valor literal usando um percorredor (valor numérico - números fracionários):
  Se existir algum problema de compilação, retorne.
  Converta o segmento inicial deste percorredor para uma proporção.
  Converta a proporção para o data deste valor literal.
  Mova o percorredor (usando diretrizes de compilação).
  Atribua "proporção" ao nome do tipo deste valor literal.
  Destrinche o valor literal.

Rotina para que se compile um valor literal usando um percorredor (valor numérico - unidade de medida):
  Se existir algum problema de compilação, retorne.
  Converta o segmento inicial deste percorredor para uma proporção.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Encontre um tipo usando o nome e o catálogo de tipos.
  Se o tipo for inexistente,
    Apresente uma mensagem de erro contendo "Erro #45. O tipo '" junto com o nome seguido de "' é uma unidade de medida inexistente." e o endereço local deste valor literal;
    Retorne.
  Se o tipo não puder ser reduzido para "número",
    Apresente a mensagem de erro contendo "Erro #46. O tipo '" junto com o nome seguido de "' não é um valor numérico válido." e o endereço local deste valor literal;
    Retorne.
  Atribua a razão de escala deste tipo para uma final proporção. \ TRADUZIR
  Se a razão de escala deste tipo for 0, atribua 1/1 para a final proporção.
  Multiplique a final proporção pelo proporção.
  Reduza a final proporção.
  Se o denominador deste final proporção for 0,
    Apresente a mensagem de erro contendo "Erro #47. Denominador igual a zero. Unidade de medida inválida." e o endereço local deste valor literal.
  Atribua o numerador deste final proporção dividido pelo denominador deste final proporção para um número.
  Atribua o nome deste tipo ao nome do tipo deste valor literal.
  Converta o número para o data deste valor literal.
  Destrinche o valor literal.

Rotina para que se compile um valor literal usando um percorredor (valor numérico - análise preliminar):
  Se existir algum problema de compilação, retorne.
  Se o percorredor estiver acompanhado por algum unidade de medida,
    Compile o valor literal usando o percorredor (valor numérico - unidade de medida);
    Retorne.
  Se o segmento inicial deste percorredor for algum número inteiro,
    Compile o valor literal usando o percorredor (valor numérico - números inteiros);
    Retorne.
  Se o segmento inicial deste percorredor for algum proporção literal,
    Compile o valor literal usando o percorredor (valor numérico - números fracionários);
    Retorne.
  Se o segmento inicial deste percorredor for algum numeral misto literal,
    Compile o valor literal usando o percorredor (valor numérico - números fracionários);
    Retorne.

Rotina para que se compile um valor literal usando um percorredor (ponteiros):
  Se existir algum problema de compilação, retorne.
  Converta 0 para os data deste valor literal. \ era nulo ao invés de 0
  Mova o percorredor (usando diretrizes de compilação).
  Atribua "ponteiro" ao nome do tipo deste valor literal.
  Destrinche o valor literal.

Rotina para que se compile um valor literal usando um percorredor (números ordinais):
  Se existir algum problema de compilação, retorne.
  Atribua o segmento inicial deste percorredor aos data deste valor literal.
  Remova o último caractere de os data deste valor literal.
  \Converta o segmento inicial deste percorredor para um número.
  \Converta o número para os data deste valor literal.
  \Converta 0 para os data deste valor literal. \ era nulo ao invés de 0
  Mova o percorredor (usando diretrizes de compilação).
  \Atribua "número" ao nome do tipo deste valor literal.
  Destrinche o valor literal. \ 

Rotina para que se compile um valor literal usando um percorredor (cadeia de caracteres):
  Se existir algum problema de compilação, retorne.
  Atribua o segmento inicial deste percorredor aos data deste valor literal.
  Remova as aspas de os data deste valor literal.
  Mova o percorredor (usando diretrizes de compilação).
  Atribua "string" ao nome do tipo deste valor literal.
  \Atribua "texto" ao nome do tipo deste valor literal.
  Destrinche o valor literal.

Rotina para que se compile umas unidades semânticas e uns parâmetros usando um percorredor:
  Se existir algum problema de compilação, retorne.
  Se o segmento inicial deste percorredor estiver em branco, retorne.
  Se o segmento inicial deste percorredor for algum artigo definido,
    Compile as unidades semânticas e o parâmetros usando o percorredor (artigo definido);
    Reitere.
  Se o percorredor estiver sobre algum artigo indefinido,
    Compile as unidades semânticas e o parâmetros usando o percorredor (artigo indefinido);
    Reitere.
  Se o percorredor estiver sobre algum unidade semântica string,
    Compile as unidades semânticas e o parâmetros usando o percorredor (string de unidade semântica);
    Reitere.
  Apresente uma mensagem de erro contendo "Erro #48. Rotina para que se '" 
  junto com o segmento inicial deste percorredor seguido de "' não localizada." e o percorredor.

Rotina para que se compile umas unidades semânticas e uns parâmetros usando um percorredor (artigo definido):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Se existir algum problema de compilação, retorne.
  Anteponha "o " para o nome.
  Adicione uma unidade semântica para as unidades semânticas usando o nome.

Rotina para que se compile umas unidades semânticas e uns parâmetros usando um percorredor (artigo indefinido):
  Se existir algum problema de compilação, retorne.
  Adicione um parâmetro para o parâmetros usando "parâmetro" e o caractere inicial deste segmento inicial deste percorredor.
  \PAL
  Se o segmento inicial deste percorredor for "outra", atribua "outra" ao nome deste parâmetro.
  Se o segmento inicial deste percorredor for "outras", atribua "outras" ao nome deste parâmetro.
  Se o segmento inicial deste percorredor for "outro", atribua "outro" ao nome deste parâmetro.
  Se o segmento inicial deste percorredor for "outros", atribua "outros" ao nome deste parâmetro.
  Se o segmento inicial deste percorredor for "segundo", atribua "segundo" ao nome deste parâmetro.
  Se o segmento inicial deste percorredor for "segunda", atribua "segunda" ao nome deste parâmetro.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Expanda o nome deste parâmetro com o nome.
  Se o segmento inicial deste percorredor for uma palavra-chave de designação, compile a parte designadora usando o percorredor e o parâmetro.
  Destrinche o parâmetro.
  Se o parâmetro estiver duplicada no parâmetros,
    Apresente uma mensagem de erro contendo "Erro #49. O parâmetro '" 
    junto com o nome deste parâmetro seguido de "' já foi declarado anteriormente." e o endereço local deste parâmetro;
    Retorne.
  Adicione uma unidade semântica para as unidades semânticas usando o tipo deste parâmetro.

Rotina para que se compile umas unidades semânticas e uns parâmetros usando um percorredor (string de unidade semântica):
  Se existir algum problema de compilação, retorne.
  Adicione uma unidade semântica para as unidades semânticas usando o segmento inicial deste percorredor.
  Mova o percorredor (usando diretrizes de compilação).

Rotina para que se compile umas unidades semânticas usando um percorredor:
  Se existir algum problema de compilação, retorne.
  Se o percorredor estiver sobre algum unidade semântica string,
    Adicione uma unidade semântica para as unidades semânticas usando o segmento inicial deste percorredor;
    Mova o percorredor (usando diretrizes de compilação); Reitere.
  Se o segmento inicial deste percorredor não for o início de alguma expressão matematica, retorne.
  Compile uma expressão matematica usando o percorredor.
  Se existir algum problema de compilação, retorne.
  Adicione uma segunda unidade semântica para as unidades semânticas usando o expressão matematica.
  Reitere.

\Rotina para que se compile umas unidades semânticas usando um percorredor:
\Se existir algum problema de compilação, retorne.
\Se o segmento inicial deste percorredor for algum unidade semântica string, adicione uma unidade semântica para as unidades semânticas usando o segmento inicial deste percorredor; mova o percorredor (usando diretrizes de compilação); Reitere.
\Se o segmento inicial deste percorredor não for o início de alguma expressão matematica, retorne.
\Compile uma expressão matematica usando o percorredor.
\Se existir algum problema de compilação, retorne.
\Adicione uma segunda unidade semântica para as unidades semânticas usando o expressão matematica.
\Reitere.

Rotina para que se compile a próxima instrução usando um percorredor:
  Se existir algum problema de compilação, retorne.
  Se o segmento inicial deste percorredor for algum comando condicional,
    Compile a próxima instrução usando o percorredor (cláusula de condicional);
    Retorne.
  Se o segmento inicial deste percorredor for algum comando de percorrimento,
    Compile a próxima instrução usando o percorredor (cláusula de inicio de laço);
    Retorne.
  Se o segmento inicial deste percorredor for algum comando de proteção,
    Compile a próxima instrução usando o percorredor (cláusula de isolamento);
    Retorne.
  Se o segmento inicial deste percorredor não for o início de alguma declaração,
    Apresente uma mensagem de erro contendo "Erro #50. Esperado declaração. Encontrado: " 
    junto com o segmento inicial deste percorredor seguido de "." e o percorredor;
    Retorne.
  Compile a próxima instrução usando o percorredor (demais cláusulas).
  Se o segmento inicial deste percorredor não for o ponto final,
    Apresente a mensagem de erro contendo "Erro #51. Este comando está incorreto ou é uma palavra-chave reservada." e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).

Rotina para que se compile a próxima instrução usando um percorredor (cláusula de interrupção):
  Adicione um fragmento usando o etiqueta de interrupção.
  Mova o percorredor (usando diretrizes de compilação).

Função para que se determine se uma string é alguma palavra-chave de devolução:
  Se a string for "retornando", diga sim.
  Se a string for "retornando", diga sim.
  Se a string for "recebendo", diga sim.
  Se a string for "obtendo", diga sim.
  \Se a string for "obtendo", diga sim.
  Diga não.

Rotina para que se compile a próxima instrução usando um percorredor (palavra-chave 'processe' - chamada externa):
  Atribua o segmento inicial deste percorredor para uma string.
  Remova as aspas de a string.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum string literal,
    Apresente uma mensagem de erro contendo "Erro #52. Nomes de bibliotecas devem ser escritos entre aspas. Encontrado: " 
    junto com o segmento inicial deste percorredor seguido de "." e o percorredor;
    Retorne.
  Atribua o segmento inicial deste percorredor para uma segunda string.
  Remova as aspas de a segunda string.
  Mova o percorredor (usando diretrizes de compilação).
  Adicione uma função para as DLLs usando a string e a segunda string.
  Se o segmento inicial deste percorredor for "com",
    Compile a próxima instrução usando o percorredor (palavra-chave 'processe' - cláusula com).
  Se o segmento inicial deste percorredor for "usando",
    Compile a próxima instrução usando o percorredor (palavra-chave 'processe' - cláusula com).
  Se o segmento inicial deste percorredor for alguma palavra-chave de devolução,
    Compile a próxima instrução usando o percorredor retornando um termo (palavra-chave 'processe' - cláusula retornando).  
  Adicione um fragmento usando a etiqueta de demanda externa e a função.
  Se o termo estiver vazio, retorne.
  Se a variável deste termo for inexistente,
    Apresente a mensagem de erro contendo "Erro #53. A variável do termo '"
    junto com a frase deste termo seguido de "' não pode ser localizada." e o percorredor;
    Retorne.
  Adicione um segundo fragmento usando o etiqueta de obtenção do registrador EAX e a variável deste termo.

Rotina para que se compile a próxima instrução usando um percorredor (palavra-chave 'processe' - chamada indireta):
  Compile uma expressão matematica usando o percorredor.
  Se existir algum problema de compilação, retorne.
  Se a variável desta expressão matematica for inexistente,
    Apresente uma mensagem de erro contendo "Erro #54. A variável da expressão matematica'" 
    junto com a frase desta expressão matematica seguido de "' não pode ser localizada." e o percorredor;
    Retorne.
  Se o tipo desta expressão matematica não puder ser reduzido para "ponteiro",
    Apresente a mensagem de erro contendo "Erro #55. Neste comando 'Processe' é necessário usar uma expressão matematica do tipo ponteiro." e o percorredor;
    Retorne.
  Se o segmento inicial deste percorredor for "com", compile a próxima instrução usando o percorredor (palavra-chave 'processe' - cláusula com).
  Se o segmento inicial deste percorredor for "usando", compile a próxima instrução usando o percorredor (palavra-chave 'processe' - cláusula com).
  Se o segmento inicial deste percorredor for alguma palavra-chave de devolução, compile a próxima instrução usando o percorredor retornando um termo (palavra-chave 'processe' - cláusula retornando).
  \Se o segmento inicial deste percorredor for "retornando", compile a próxima instrução usando o percorredor retornando um termo (palavra-chave 'processe' - cláusula retornando).
  Adicione um fragmento usando a etiqueta de demanda indireta e a variável desta expressão matematica.
  Se o termo estiver vazio, retorne.
  Se a variável deste termo for inexistente,
    Apresente a mensagem de erro contendo "Erro #56. A variável do termo '"
    junto com a frase deste termo seguido de "' é inexistente." e o percorredor;
    Retorne.
  Adicione um segundo fragmento usando o etiqueta de obtenção do registrador EAX e a variável deste termo.

Rotina para que se compile a próxima instrução usando um percorredor (palavra-chave 'processe' - chamada interna):
  Compile umas unidades semânticas usando o percorredor.
  Encontre uma rotina usando as unidades semânticas.
  Se a rotina não for inexistente,
    Adicione push fragmentos usando as unidades semânticas.
  Se a rotina não for inexistente,
    Destrua as unidades semânticas;
    Adicione um fragmento usando a etiqueta de demanda interna e a rotina;
    Retorne.
  \ Se a rotina for inexistente,
  Converta as unidades semânticas para uma representação interna da rotina.
  Destrua as unidades semânticas.
  Atribua a representação interna da rotina ao texto retornado.
  Apresente uma mensagem de erro contendo "Erro #57. A rotina para que se " 
    junto com a representação interna da rotina seguido de " não foi localizada." e o percorredor.

Rotina para que se compile a próxima instrução usando um percorredor (palavra-chave 'processe' - cláusula com):
  \ this routine is recursise so parameters get passed right to  left
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile uma expressão matematica usando o percorredor.
  Se existir algum problema de compilação, retorne.
  Se a variável desta expressão matematica for inexistente,
    Apresente uma mensagem de erro contendo "Erro #58. A variável da expressão matematica '"
    junto com a frase desta expressão matematica seguido de "' é inexistente." e o percorredor;
    Retorne.
  Se o tipo desta expressão matematica não for valor empilhável,
    Apresente a mensagem de erro contendo "Erro #59. O tipo '" 
    junto com o nome deste tipo desta expressão matematica seguido de "' da expressão matematica não é um valor empilhável." e o percorredor;
    Retorne.
  Se o segmento inicial deste percorredor for algum operador de continuidade, compile a próxima instrução usando o percorredor (palavra-chave 'processe' - cláusula com).
  Adicione um fragmento usando o etiqueta de inserção de valor [na stack] e a variável desta expressão matematica.

Rotina para que se compile a próxima instrução usando um percorredor (palavra-chave 'processe'):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for algum string literal,
    Compile a próxima instrução usando o percorredor (palavra-chave 'processe' - chamada externa);
    Retorne.
  Compile a próxima instrução usando o percorredor (palavra-chave 'processe' - chamada indireta).

Rotina para que se compile a próxima instrução usando um percorredor (cláusula de retorno):
  Se o sinalizador de deliberação desta rotina utilizada atualmente estiver ativo,
    Apresente uma mensagem de erro contendo "Erro #60. Funções booleanas devem retornar um 'sim' ou 'não'" e o percorredor;
    Retorne.
  Adicione um fragmento usando o etiqueta de retorno.
  Mova o percorredor (usando diretrizes de compilação).

Rotina para que se compile a próxima instrução usando um percorredor (cláusula de condicional):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile umas unidades semânticas usando o percorredor.
  Remova alguns termos negativos desde as unidades semânticas retornando um sinalizador.
  Encontre uma rotina usando as unidades semânticas.
  Se a rotina não for inexistente, adicione push fragmentos usando as unidades semânticas.
  Se a rotina for inexistente, converta as unidades semânticas para uma representação interna da rotina.
  Destrua as unidades semânticas.
  Se a rotina for inexistente,
    Apresente uma mensagem de erro contendo "Erro #61. A rotina para que se determine se '"
    junto com a representação interna da rotina seguido de "' não existe." e o percorredor;
    Retorne.
  Se o sinalizador de deliberação desta rotina não estiver ativo,
    Apresente a mensagem de erro contendo "Erro #62. Necessário utilizar um decisor." e o percorredor;
    Retorne.
  \ Se o segmento inicial deste percorredor não for a vírgula, apresente a mensagem de erro contendo "Acho que você esqueceu de uma vírgula, eu achei isso aqui: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; Retorne.
  Se o segmento inicial deste percorredor não for qualquer separador de comandos,
    Apresente a mensagem de erro contendo "Erro #63. Necessário incluir uma vírgula ao invés de: "
    junto com o segmento inicial deste percorredor seguido de "." e o percorredor;
    Retorne.
  Adicione um fragmento usando a etiqueta de demanda interna e a rotina.
  Se o sinalizador estiver ativo, adicione um segundo fragmento usando a etiqueta de negação lógica.
  Adicione um terceiro fragmento usando o etiqueta de desvio falso.
  Mova o percorredor (usando diretrizes de compilação).
  Itere.
    Compile a próxima instrução usando o percorredor (demais cláusulas).
    Se existir algum problema de compilação, retorne.
    Se o segmento inicial deste percorredor for o ponto&vírgula,
    Mova o percorredor (usando diretrizes de compilação);
    Reitere.
    Se o segmento inicial deste percorredor não for o ponto final,
    Apresente a mensagem de erro contendo "Erro #64. Necessário incluir um '.' ao invés de: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Adicione um quarto fragmento usando o etiqueta delimitadora de bloco condicional.

Função para que se determine se um subtexto é qualquer separador de comandos:
  Se o subtexto for a vírgula, diga sim.
  Se o subtexto for "então", diga sim.
  [Caso contrário] 
  Diga não.

Rotina para que se compile a próxima instrução usando um percorredor (cláusula de decodificação):
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum valor hexadecimal literal,
    Apresente uma mensagem de erro contendo "Erro #65. Encontrado '"
    junto com o segmento inicial deste percorredor seguido de "'. Esperado instrução hexadecimal" e o percorredor;
    Retorne.
  Adicione um fragmento usando o etiqueta de decodificação.
  Atribua o segmento inicial deste percorredor para um parte da cifra binária.
  Adicione 1 para o caractere inicial desta parte da cifra binária.
  Converta o parte da cifra binária para o código deste fragmento.
  Mova o percorredor (usando diretrizes de compilação).

Rotina para que se compile a próxima instrução usando um percorredor (cláusula de inicio de laço):
  Se existir algum problema de compilação, retorne.
  Adicione um fragmento usando o etiqueta de laço.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for o ponto final,
    Apresente uma mensagem de erro contendo "Erro #66. Necessário incluir um '.' após comandos em blocos de repetição." e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).

Rotina para que se compile a próxima instrução usando um percorredor (demais cláusulas):
  Se existir algum problema de compilação, retorne.
  Se o segmento inicial deste percorredor estiver em branco, retorne.
  Se o segmento inicial deste percorredor for algum comando de retorno de rotina,
    Compile a próxima instrução usando o percorredor (cláusula de retorno);
    Retorne.
  Se o segmento inicial deste percorredor for algum comando de repetição,
    Compile a próxima instrução usando o percorredor(cláusula de repetição);
    Retorne.
  Se o segmento inicial deste percorredor for algum comando de interrupção de repetições,
    Compile a próxima instrução usando o percorredor (cláusula de interrupção);
    Retorne.
  Se o segmento inicial deste percorredor for algum comando de confirmação ou negação,
    Compile a próxima instrução usando o percorredor (palavra-chave 'diga');
    Retorne.
  Se o segmento inicial deste percorredor for "Decodifique",
    Compile a próxima instrução usando o percorredor (cláusula de decodificação);
    Retorne.
  Se o segmento inicial deste percorredor for "Push",
    Compile a próxima instrução usando o percorredor (cláusula de empilhamento);
    Retorne.
  Se o segmento inicial deste percorredor for alguma chamada de biblioteca externa,
    Compile a próxima instrução usando o percorredor (palavra-chave 'processe');
    Retorne.
  Se o segmento inicial deste percorredor for algum point,
    Compile a próxima instrução usando o percorredor (palavra-chave 'aponte');
    Retorne.
  Se o segmento inicial deste percorredor for algum comando condicional,
    Apresente uma mensagem de erro contendo "Erro #67. O aninhamento de condicionais não é permitido." e o percorredor;
    Retorne.
  Se o segmento inicial deste percorredor for algum comando de proteção,
    Apresente a mensagem de erro contendo "Erro #68. A palavra-chave 'Preserve' não pode ser usada nesse tipo de comando." e o percorredor;
    Retorne.
  Se o segmento inicial deste percorredor for algum comando de percorrimento,
    Apresente a mensagem de erro contendo "Erro #69. Loops não são permitidos em condicionais." e o percorredor;
    Retorne.
  Se o segmento inicial deste percorredor for uma palavra-chave de reutilização de rotina,
    Apresente a mensagem de erro contendo "Erro #70. O comando 'Empregue' deve ser o único comando de uma rotina." e o percorredor;
    Retorne.
  \Se o segmento inicial deste percorredor for "senão", mova o percorredor (usando diretrizes de compilação); Retorne.
  \Se o segmento inicial deste percorredor for "caso", mova o percorredor (usando diretrizes de compilação); Retorne.
  \Se o segmento inicial deste percorredor for "contrário", mova o percorredor (usando diretrizes de compilação); Retorne.
  Compile a próxima instrução usando o percorredor (palavra-chave 'processe' - chamada interna).

Rotina para que se compile a próxima instrução usando um percorredor (palavra-chave 'aponte'):
  Mova o percorredor (usando diretrizes de compilação).
  Compile um termo usando o percorredor.
  Se existir algum problema de compilação, retorne.
  Se a variável deste termo for inexistente,
    Apresente uma mensagem de erro contendo "Erro #71. A variável '" 
    junto com a frase deste termo seguido de "' deste termo não pode ser encontrada." e o percorredor;
    Retorne.
  Se a categoria deste termo for "literal",
    Apresente a mensagem de erro contendo "Erro #72. Identificado valor literal na categoria deste termo." e o percorredor.
  Se a quantidade de caracteres deste tipo deste termo não for 4,
    Apresente a mensagem de erro contendo "Erro #73. Variável de comprimento diferente de 4 ." e o percorredor.
  Se o segmento inicial deste percorredor não for "para",
    Apresente a mensagem de erro contendo "Erro #74. A palavra-chave 'para é necessária após o comando 'aponte'. Termo encontrado: " 
    junto com o segmento inicial deste percorredor seguido de "." e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Mova o percorredor (usando diretrizes de compilação).
  \Mova o percorredor (usando diretrizes de compilação). \ artigo definido
  Se o segmento inicial deste percorredor não for "rotina",
    Apresente a mensagem de erro contendo "Erro #75. A sintaxe do comando é 'Aponte para a rotina'. Encontrado termo: " 
    junto com o segmento inicial deste percorredor seguido de "." e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile uma referência da rotina usando o percorredor.
  Converta a referência da rotina para uma representação interna da rotina.
  Destrua a referência da rotina.
  Encontre uma rotina usando a representação interna da rotina e o catálogo geral de rotinas.
  Se a rotina for inexistente,
    Apresente a mensagem de erro contendo "Erro #76. A rotina para que se "
    junto com a representação interna da rotina seguido de " é inexistente." e o percorredor;
    Retorne.
  Adicione um fragmento usando a etiqueta de endereço de rotina e a rotina.
  Atribua a variável deste termo à variável deste fragmento.

Rotina para que se compile a próxima instrução usando um percorredor (cláusula de isolamento):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile um termo usando o percorredor.
  Se existir algum problema de compilação, retorne.
  Se a variável deste termo for inexistente,
    Apresente uma mensagem de erro contendo "Erro #77. Comando 'Isole', Inválido. A variável '" 
      junto com a frase deste termo 
      [seguido de "do termo '" junto com o termo]
      seguido de "' está vazia. " 
      e o percorredor;
    Retorne.
  Se a categoria deste termo não for "parâmetro",
    Apresente a mensagem de erro contendo "Erro #78. Apenas parâmetros podem ser isolados." e o percorredor;
    Retorne.
  Adicione uma variável local para as variáveis locais desta rotina utilizada atualmente usando "local" e o caractere inicial deste segmento inicial deste percorredor.
  Atribua o nome deste termo ao nome desta variável local.
  Atribua o apelido deste termo ao apelido desta variável local.
  Atribua o nome do tipo deste termo ao nome do tipo desta variável local.
  Destrinche a variável local.
  \Anteponha "original " para o nome deste termo. 
  Acrescente " original" para o nome deste termo. 
  Se o apelido deste termo não estiver em branco,
    \Anteponha "original " para o apelido deste termo.
    Acrescente " original" para o apelido deste termo.
  Adicione fragmentos diversos usando "Atribua" e a variável deste termo e "para" e a variável local e o caractere inicial deste segmento inicial deste percorredor.
  Se o segmento inicial deste percorredor não for o ponto final,
    Apresente a mensagem de erro contendo "Erro #79. Necessário incluir um '.' ao fim do comando" e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).

Rotina para que se compile a próxima instrução usando um percorredor (cláusula de empilhamento):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile uma expressão matematica usando o percorredor.
  Se existir algum problema de compilação, retorne.
  Se a variável desta expressão matematica for inexistente,
    Apresente uma mensagem de erro contendo "Erro #80. Comando de empilhamento inválido devido a expressão matematica: " junto com a frase desta expressão matematica seguido de "' ser inexistente." e o percorredor;
    Retorne.
  Se o tipo desta expressão matematica não for valor empilhável,
    Apresente a mensagem de erro contendo "Erro #81. Valores do tipo: " junto com o nome deste tipo desta expressão matematica seguido de "' não podem ser empilhados." e o percorredor;
    Retorne.
  Adicione um fragmento usando o etiqueta de inserção de valor [na stack] e a variável desta expressão matematica.

Rotina para que se compile a próxima instrução usando um percorredor(cláusula de repetição):
  Adicione um fragmento usando a etiqueta de repetição.
  Mova o percorredor (usando diretrizes de compilação).

\Rotina para que se compile a próxima instrução usando um percorredor (palavra-chave 'diga'):
\Se o sinalizador de deliberação desta rotina utilizada atualmente não estiver ativo, compile a próxima instrução usando o percorredor (palavra-chave 'processe' - chamada interna); Retorne.
\Mova o percorredor (usando diretrizes de compilação).
\Compile uma expressão matematica usando o percorredor.
\Se existir algum problema de compilação, retorne.
\Se a variável desta expressão matematica for inexistente, apresente uma mensagem de erro contendo "No es válido este 'diga', no entiendo la variável: " junto com a frase desta expressão matematica seguido de "." e o percorredor; Retorne.
\Se o tipo desta expressão matematica não puder ser reduzido para "sinalizador", apresente uma mensagem de erro contendo "Necesito un rotundo 'si' o 'no' aquí." e o percorredor; Retorne.
\Adicione um fragmento usando o etiqueta de carregamento de registrador EAX e a variável desta expressão matematica.
\Adicione um segundo fragmento usando o etiqueta de retorno.

Rotina para que se compile a próxima instrução usando um percorredor (palavra-chave 'diga'):
  Se o sinalizador de deliberação desta rotina utilizada atualmente não estiver ativo,
    Compile a próxima instrução usando o percorredor (palavra-chave 'processe' - chamada interna);
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum comando de deliberação literal,
    Apresente uma mensagem de erro contendo "Erro #82. Funções booleanas devem terminar com um 'sim' ou 'não'." e o percorredor;
    Retorne.
  Desative um sinalizador. 
  Se o segmento inicial deste percorredor for algum decisor literal afirmativo, 
    Ative o sinalizador.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for o ponto final,
    Apresente a mensagem de erro contendo "Erro #83. O compilador esperava encontrar um '.' Encontrado o termo: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor;
    Retorne.
  Adicione um fragmento usando o etiqueta de carregamento de registrador EAX e o sinalizador.
  Adicione um segundo fragmento usando o etiqueta de retorno.

Rotina para que se compile a próxima instrução usando um percorredor retornando um termo (palavra-chave 'processe' - cláusula retornando):
  Mova o percorredor (usando diretrizes de compilação).
  Compile o termo usando o percorredor.
  Se existir algum problema de compilação, retorne.
  Se a variável deste termo for inexistente,
    Apresente uma mensagem de erro contendo "Erro #84. O termo da variável: " junto com a frase deste termo seguido de "'. aparenta estar vazio." e o percorredor;
    Retorne.
  Se o tipo deste termo não for valor empilhável, apresente a mensagem de erro contendo "Erro #85. Uma varíavel de 1, 2, ou 4 bytes é necessária na cláusula de devolução." e o percorredor.

Rotina para que se compile uma referência da rotina usando um percorredor:
  Se o segmento inicial deste percorredor for "para", mova o percorredor (usando diretrizes de compilação).
  Se o percorredor for o início de alguma função,
    Compile a referência da rotina usando o percorredor (função);
    Retorne.
  Se o segmento inicial deste percorredor for algum comando de deliberação, compile a referência da rotina usando o percorredor (decide).
  Itere.
    Se existir algum problema de compilação, retorne.
    Se o segmento inicial deste percorredor estiver em branco, retorne.
    Se o segmento inicial deste percorredor for ".", retorne.
    Se o segmento inicial deste percorredor for algum artigo definido,
      Compile a referência da rotina usando o percorredor (artigo definido);
      Reitere.
    Se o segmento inicial deste percorredor for algum artigo indefinido,
      Compile a referência da rotina usando o percorredor (artigo indefinido);
      Reitere.
    Se o percorredor está sobre algum unidade semântica string,
      Compile a referência da rotina usando o percorredor (string de unidade semântica);
      Reitere.
    Apresente uma mensagem de erro contendo "Erro #86. O termo '"
    junto com o segmento inicial deste percorredor seguido de "' não é válido neste tipo de comando." e o percorredor.
  [Reitere.]

Rotina para que se compile uma referência da rotina usando um percorredor (decide):
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum comando condicional,
    Apresente uma mensagem de erro contendo "Erro #87. Esperava encontrar: 'Para que se decisa SE xxxx'. Encontrado: 'Para que se decida '"
    junto com o segmento inicial deste percorredor seguido de "' '." e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).

Rotina para que se compile uma referência da rotina usando um percorredor (artigo definido):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Anteponha "o " para o nome.
  Adicione uma unidade semântica para a referência da rotina usando o nome.

Rotina para que se compile uma referência da rotina usando um percorredor (função):
  Se existir algum problema de compilação, retorne.
  Adicione uma unidade semântica para a referência da rotina usando "atribua".
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for algum artigo indefinido, ative um sinalizador.
  Se o sinalizador estiver ativo, compile a referência da rotina usando o percorredor (artigo indefinido).
  Se o sinalizador não estiver ativo, compile a referência da rotina usando o percorredor (artigo definido).
  Se o segmento inicial deste percorredor não for algum possessivo inglês,
    Apresente uma mensagem de erro contendo "Erro #88. O compilador esperava encontrar um 's. Encontrado: '"
    junto com o segmento inicial deste percorredor seguido de "'." e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Adicione uma segunda unidade semântica para a referência da rotina usando "'s " junto com o nome.
  Se o segmento inicial deste percorredor não for "para",
    Apresente a mensagem de erro contendo "Erro #89. O compilador esperava encontrar a palavra 'para'. Encontrado: '"
    junto com o segmento inicial deste percorredor seguido de "'." e o percorredor;
    Retorne.
  Adicione uma terceira unidade semântica para a referência da rotina usando "para".
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum artigo indefinido,
    Apresente a mensagem de erro contendo "Erro #90. O compilador esperava encontrar um artigo indefinido. Encontrado: '" junto com o segmento inicial deste percorredor seguido de "'." e o percorredor;
    Retorne.
  Compile a referência da rotina usando o percorredor (artigo indefinido).

Rotina para que se compile uma referência da rotina usando um percorredor (artigo indefinido):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Encontre um tipo e um apelido usando o nome.
  Se o tipo for inexistente,
    Apresente uma mensagem de erro contendo "Erro #91. O comando '" junto com o nome seguido de "' não é um comando de reutilização válido." e o percorredor;
    Retorne.
  Adicione uma unidade semântica para a referência da rotina usando o tipo.

Rotina para que se compile uma referência da rotina usando um percorredor (string de unidade semântica):
  Se existir algum problema de compilação, retorne.
  Adicione uma unidade semântica para a referência da rotina usando o segmento inicial deste percorredor.
  Mova o percorredor (usando diretrizes de compilação).

Rotina para que se compile um termo usando um percorredor:
  Limpe o termo.
  Se existir algum problema de compilação, retorne.
  Compile o termo usando o percorredor (análise preliminar).
  Se o percorredor estiver sobre algum simile, retorne. \ added for invisible turtle project ***
  \Se o segmento inicial deste percorredor for "as", compile o termo usando o percorredor (cláusula comparativa). \preposição
  \Se o segmento inicial deste percorredor for "tão", compile o termo usando o percorredor (cláusula comparativa). \ me parece desnecessário por ser usado apenas em funções.
  Se o segmento inicial deste percorredor for "quão", compile o termo usando o percorredor (cláusula comparativa).
  Se o segmento inicial deste percorredor for "quanto", compile o termo usando o percorredor (cláusula comparativa).
  Se o segmento inicial deste percorredor for "como", compile o termo usando o percorredor (cláusula comparativa).
  \Se o segmento inicial deste percorredor for "que nem", compile o termo usando o percorredor (cláusula comparativa).
  Se o segmento inicial deste percorredor for "/", compile o termo usando o percorredor (proporção de execução).

Rotina para que se compile um termo usando um percorredor (cláusula comparativa):
  Se existir algum problema de compilação, retorne.
  Se a variável deste termo for inexistente,
    Apresente uma mensagem de erro contendo "Erro #92. Comando 'como' inválido. Variável: " junto com a frase deste termo seguido de "' está vaiza." e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum artigo indefinido,
    Apresente a mensagem de erro contendo "Erro #93. Esperado Artigo indefinido. Encontrado: " junto com o segmento inicial deste percorredor seguido de "'." e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome do tipo usando o percorredor.
  Encontre um tipo usando o nome do tipo e o catálogo de tipos.
  Se o tipo for inexistente,
    Apresente a mensagem de erro contendo "Erro #94. Tipo: '" junto com o nome do tipo seguido de "' inválido." e o percorredor;
    Retorne.
  Adicione um scratch usando o nome deste tipo e o caractere inicial deste segmento inicial deste percorredor.
  Adicione um fragmento usando o etiqueta de carregamento de endereço e a variável deste termo e o scratch.
  Atribua o scratch à variável deste termo.
  Limpe a frase deste termo.

Rotina para que se compile um termo usando um percorredor (análise preliminar):
  Se existir algum problema de compilação, retorne.
  Se o segmento inicial deste percorredor for o sinal de subtração,
    Compile o termo usando o percorredor (subtração de termo);
    Retorne.
  Se o segmento inicial deste percorredor for o sinal de adição,
    Compile o termo usando o percorredor (adição de termo);
    Retorne.
  Se o segmento inicial deste percorredor for o início de alguma variável,
    Compile o termo usando o percorredor (variável);
    Retorne.
  Se o segmento inicial deste percorredor for o início de alguma variável local,
    Compile o termo usando o percorredor (nova variável local);
    Retorne.
  Se o segmento inicial deste percorredor for algum valor literal,
    Compile o termo usando o percorredor (valor literal);
    Retorne.
  Apresente uma mensagem de erro contendo "Erro #95. O Compilador esperava encontrar um termo. Encontrado: '"
  junto com o segmento inicial deste percorredor seguido de "'." e o percorredor.

Rotina para que se compile um termo usando um percorredor (redirecionamentos de endereços - campos de estruturas):
  Se a variável deste termo for inexistente,
    Apresente uma mensagem de erro contendo "Erro #96. Termo inexistente." e o percorredor;
    Retorne.
  Atribua o nome deste tipo do conteúdo deste tipo deste termo ao nome do tipo deste termo.
  Atribua o tipo do conteúdo deste tipo deste termo ao tipo deste termo.
  Adicione um fragmento usando o etiqueta de redirecionamento e a variável deste termo.
  Limpe o frase deste termo.

Rotina para que se compile um termo usando um percorredor (cláusula de redirecionamento):
  Se existir algum problema de compilação, retorne.
  Se a variável deste termo for inexistente,
    Apresente uma mensagem de erro contendo "Erro #97. Cláusula redirecionamento inválida. A variável '"
    junto com a frase deste termo seguido de "' deste termo não foi encontrada." e o percorredor;
    Retorne.
  Se o tipo do conteúdo deste tipo deste termo for inexistente,
    Apresente a mensagem de erro contendo "Erro #98. O tipo do conteúdo deste termo não foi encontrado." e o percorredor;
    Retorne.
  Se a categoria deste termo for "scratch",
    Compile o termo usando o percorredor (redirecionamentos de endereços - campos de estruturas);
    Retorne.
  Adicione um scratch usando o nome deste tipo do conteúdo deste tipo deste termo e o caractere inicial deste segmento inicial deste percorredor.
  Adicione um fragmento usando o etiqueta de carregamento de endereço e a variável deste termo e o scratch.
  Adicione um segundo fragmento usando o etiqueta de redirecionamento e o scratch.
  Atribua o scratch à variável deste termo.
  Limpe o frase deste termo.

Rotina para que se compile um termo usando um percorredor (valor literal):
  Se existir algum problema de compilação, retorne.
  Compile um valor literal usando o percorredor.
  Atribua o valor literal à variável deste termo.
  Limpe o frase deste termo.
  Compile o termo usando o percorredor (possessivos).

Rotina para que se compile um termo usando um percorredor (subtração de termo):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile uma segunda termo usando o percorredor.
  Se existir algum problema de compilação, retorne.
  Se a variável desta segunda termo for inexistente,
    Apresente uma mensagem de erro contendo "Erro #99. Comando 'inverta' inválido. A variável: "
    junto com o frase desta segunda termo seguido de "' não foi encontrada." e o percorredor;
    Retorne.
  Adicione uma variável intermediária usando o nome do tipo desta segunda termo e o caractere inicial deste segmento inicial deste percorredor.
  Adicione fragmentos diversos usando "Atribua" e a variável desta segunda termo e "para" e a variável intermediária e o endereço local desta segunda termo.
  Adicione two fragmentos usando "inverta o sinal de" e a variável intermediária e o caractere inicial deste segmento inicial deste percorredor.
  Atribua a variável intermediária à variável deste termo.
  Limpe o frase deste termo.

Rotina para que se compile um termo usando um percorredor (nova variável local):
  Se existir algum problema de compilação, retorne.
  Se a rotina utilizada atualmente for inexistente,
    Apresente uma mensagem de erro contendo "Erro #100. Rotina não localizada. Não foi possível desempilhar o item da stack." e o percorredor;
    Retorne.
  Adicione uma variável local para as variáveis locais desta rotina utilizada atualmente usando "local" e o caractere inicial deste segmento inicial deste percorredor.
  \PAL
  Se o segmento inicial deste percorredor for "outra", atribua "outra" ao nome desta variável local.
  Se o segmento inicial deste percorredor for "outro", atribua "outro" ao nome desta variável local.
  Se o segmento inicial deste percorredor for "segundo", atribua "segundo" ao nome desta variável local.
  Se o segmento inicial deste percorredor for "segunda", atribua "segunda" ao nome desta variável local.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Expanda o nome desta variável local com o nome.
  Se o segmento inicial deste percorredor for uma palavra-chave de designação, compile a parte designadora usando o percorredor e a variável local.
  Destrinche a variável local.
  Se a variável local estiver duplicada em os parâmetros desta rotina utilizada atualmente,
    Apresente a mensagem de erro contendo "Erro #101. O identificador: "
    junto com o nome desta variável local seguido de "' já está sendo usado como parâmetro." e o endereço local desta variável local;
    Retorne.
  Se a variável local estiver duplicada em as variáveis locais desta rotina utilizada atualmente,
    Apresente a mensagem de erro contendo "Erro #102. A variável local " 
    junto com o nome desta variável local seguido de "' já foi declarada nesta rotina. Utilize um nome de variável diferente." e o endereço local desta variável local;
    Retorne.
  Elimine apelidos duplicados usando a variável local e o catálogo de apelidos desta rotina utilizada atualmente.
  Atribua a variável local à variável deste termo.
  Limpe a frase deste termo.
  Compile o termo usando o percorredor (possessivos).

Rotina para que se compile um termo usando um percorredor (adição de termo):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile o termo usando o percorredor.
  Se a variável deste termo for inexistente,
    Apresente uma mensagem de erro contendo "Erro #103. Comando 'Posigate' inválido. O termo da variável'" 
    junto com a frase deste termo seguido de "' não foi localizado." e o percorredor;
    Retorne.
  Limpe a frase deste termo.

Rotina para que se compile um termo usando um percorredor (possessivo - magnitude):
  Se existir algum problema de compilação, retorne.
  Se a variável deste termo for inexistente,
    Apresente uma mensagem de erro contendo "Erro #104. Comando magnitude inválido. A variável: " 
    junto com a frase deste termo seguido de "'não foi localizada." e o percorredor;
    Retorne.
  Adicione um valor literal para os valores literais usando o caractere inicial deste segmento inicial deste percorredor.
  Converta a quantidade de caracteres deste tipo deste termo para os data deste valor literal.
  Atribua "número" ao nome do tipo deste valor literal.
  Destrinche o valor literal.
  Atribua o valor literal à variável deste termo.
  Limpe a frase deste termo.

Rotina para que se compile um termo usando um percorredor (possessivo - conteúdo):
  Se existir algum problema de compilação, retorne.
  Se a variável deste termo for inexistente,
    Apresente uma mensagem de erro contendo "Erro #105. Palavra-chave 'conteúdo' detectada, mas o termo da variável: "
    junto com a frase deste termo seguido de "' não foi devidamente definido." e o percorredor;
    Retorne.
  Se o tipo deste termo não puder ser reduzido para "ponteiro",
    Apresente a mensagem de erro contendo "Erro #106. A palavra 'conteúdo' exige valores do tipo 'ponteiro'." e o percorredor;
    Retorne.
  Compile o termo usando o percorredor (cláusula de redirecionamento).

Rotina para que se compile um termo usando um percorredor (possessivo - endereçamento):
  Se existir algum problema de compilação, retorne.
  Se a variável deste termo for inexistente,
    Apresente uma mensagem de erro contendo "Erro #107. palavra-chave 'endereçamento' detectada, mas a variável do termo: " 
    junto com a frase deste termo seguido de " não foi localizada." e o percorredor;
    Retorne.
  Adicione uma variável intermediária usando "ponteiro" e o caractere inicial deste segmento inicial deste percorredor.
  Adicione um fragmento usando o etiqueta de carregamento de endereço e a variável deste termo e a variável intermediária.
  Atribua a variável intermediária à variável deste termo.
  Limpe a frase deste termo.

Rotina para que se compile um termo usando um percorredor (possessivo):
  \ similar a "compile um termo usando um percorredor (possessivo reverso)
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Se existir algum problema de compilação, retorne.
  Se o nome for alguma palavra-chave de obtenção de tamanho de variável,
    Compile o termo usando o percorredor (possessivo - magnitude);
    Retorne.
  Se o nome for algum conteúdo,
    Compile o termo usando o percorredor (possessivo - conteúdo);
    Retorne.
  Se o nome for algum endereçamento,
    Compile o termo usando o percorredor (possessivo - endereçamento);
    Retorne.
  Compile o termo usando o percorredor e o nome (possessivo - campo).

Rotina para que se compile um termo usando um percorredor (possessivos):
  Se existir algum problema de compilação, retorne.
  Se o segmento inicial deste percorredor não for algum possessivo inglês, retorne.
  Compile o termo usando o percorredor (possessivo).
  Reitere.

Rotina para que se compile um termo usando um percorredor (proporção de execução):
  Se existir algum problema de compilação, retorne.
  Se a variável deste termo for inexistente,
    Apresente uma mensagem de erro contendo "Erro #108. Operador '/' detectado, mas o numerador do termo: "
    junto com a frase deste termo seguido de " não foi localizada." e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile um segundo termo usando o percorredor.
  Se existir algum problema de compilação, retorne.
  Se a variável deste segundo termo for inexistente,
    Apresente a mensagem de erro contendo "Erro #109. Operador '/' detectado, mas o denominador do termo: "
    junto com o frase deste segundo termo seguido de "' não foi localizado." e o percorredor;
    Retorne.
  Adicione uma variável intermediária usando "proporção" e o caractere inicial deste segmento inicial deste percorredor.
  Adicione fragmentos diversos usando "Atribua" 
   e a variável deste termo 
   e "e" e a variável deste segundo termo 
   e "para" e a variável intermediária 
   e o caractere inicial deste segmento inicial deste percorredor.
  Atribua a variável intermediária à variável deste termo.
  Limpe a frase deste termo.

Rotina para que se compile um termo usando um percorredor (variável):
  Se existir algum problema de compilação, retorne.
  Se a rotina utilizada atualmente for inexistente,
    Apresente uma mensagem de erro contendo "Erro #110. Rotina inexistente. Impossível desempilhar termo possessivo." e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Se o percorredor estiver sobre algum possessivo reverso,
    Compile o termo usando o percorredor e o nome (possessivo reverso);
    Retorne.
  Encontre uma variável usando o nome.
  Atribua a variável à variável deste termo.
  Atribua "o " à frase deste termo.
  Acrescente o nome para a frase deste termo.
  Compile o termo usando o percorredor (possessivos).

Rotina para que se compile um termo usando um percorredor e um campo nome (possessivo reverso):
  \ função recursiva
  \ Rotina nova criada pelo Dahn para version 2
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação). \ após o starter do possessivo reverso
  \Se o segmento inicial deste percorredor não for "del", mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum artigo,
    Apresente uma mensagem de erro contendo "Erro #111. O compilador esperava encontrar um artigo, mas encontrou: " junto com o segmento inicial deste percorredor seguido de ".";
    Retorne.
  Atribua o segmento inicial deste percorredor para um article segmento inicial.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Se o percorredor estiver sobre algum possessivo reverso, ative um sinalizador de possessivo reverso.
  Se o sinalizador de possessivo reverso estiver ativo, compile o termo usando o percorredor e o nome (possessivo reverso).
  Se o sinalizador de possessivo reverso não estiver ativo, compile o termo usando o percorredor e o nome e o article (reversão de contrações do possessivo).\ não entendi
  Compile o termo usando o campo nome e o percorredor (possessivo reverso).

Rotina para que se compile um termo usando um percorredor e uma variável nome e um article segmento inicial (reversão de contrações do possessivo):
  \ Rotina nova criada pelo Dahn para version 2
  Se o article for o início de alguma variável,
    Compile o termo usando o percorredor e a variável nome e o article (reversão de contrações de variáveis do possessivo);
    Retorne.
  Compile o termo usando o percorredor e a variável nome (decomposição do possessivo reverso - variável local).

Rotina para que se compile um termo usando um percorredor e uma variável nome e um article segmento inicial (reversão de contrações de variáveis do possessivo):
  \ Rotina nova criada pelo Dahn para version 2
  Encontre uma variável usando a variável nome.
  Se a variável for inexistente,
    Apresente uma mensagem de erro contendo "Erro #112. Não foi possível encontrar a variável: " junto com a variável nome seguido de ".".
  Atribua a variável à variável deste termo.
  Atribua "o " à frase deste termo.
  Acrescente a variável nome para a frase deste termo.

Rotina para que se compile um termo usando um percorredor e uma variável nome (decomposição do possessivo reverso - variável local):
  \ Rotina nova criada pelo Dahn para version 2
  Se existir algum problema de compilação, retorne.
  Adicione uma variável local para as variáveis locais desta rotina utilizada atualmente usando "local" e o caractere inicial deste segmento inicial deste percorredor.
  \PAL
  Se o segmento inicial deste percorredor for "outra", atribua "outra" ao nome desta variável local.
  Se o segmento inicial deste percorredor for "outro", atribua "outro" ao nome desta variável local.
  Se o segmento inicial deste percorredor for "segundo", atribua "segundo" ao nome desta variável local.
  Se o segmento inicial deste percorredor for "segunda", atribua "segunda" ao nome desta variável local.
  Expanda o nome desta variável local com a variável nome.
  Se o segmento inicial deste percorredor for uma palavra-chave de designação, compile a parte designadora usando o percorredor e a variável local.
  Destrinche a variável local.
  Se a variável local estiver duplicada em os parâmetros desta rotina utilizada atualmente,
    Apresente uma mensagem de erro contendo "Erro #113. O identificador: "
    junto com o nome desta variável local seguido de "' já está sendo usado como parâmetro." e o endereço local desta variável local;
    Retorne.
  Se a variável local estiver duplicada em as variáveis locais desta rotina utilizada atualmente,
    Apresente a mensagem de erro contendo "Erro #114. O identificador: " 
    junto com o nome desta variável local seguido de "' já está sendo usado coma variável local." e o endereço local desta variável local;
    Retorne.
  Elimine apelidos duplicados usando a variável local e o catálogo de apelidos desta rotina utilizada atualmente.
  Atribua a variável local à variável deste termo.
  Limpe a frase deste termo.

Rotina para que se compile um termo usando um campo nome e um percorredor (possessivo reverso):
  \ similar para "compile um termo usando um percorredor (possessivo)" \ Rotina nova criada pelo Dahn para
  Se existir algum problema de compilação, retorne.
  Se o campo nome for alguma palavra-chave de obtenção de tamanho de variável,
    Compile o termo usando o percorredor (possessivo - magnitude);
    Retorne.
  Se o campo nome for algum conteúdo,
    Compile o termo usando o percorredor (possessivo - conteúdo);
    Retorne.
  Se o campo nome for algum endereçamento,
    Compile o termo usando o percorredor (possessivo - endereçamento);
    Retorne.
  Compile o termo usando o percorredor e o campo nome (possessivo - campo).

Rotina para que se compile um termo usando um percorredor e um campo de estrutura:
  Se existir algum problema de compilação, retorne.
  Se o sinalizador de redirecionamento deste campo de estrutura estiver ativo, compile o termo usando o percorredor (cláusula de redirecionamento).
  Se a rotina de função deste campo de estrutura não for inexistente,
    Compile o termo usando o percorredor e o campo de estrutura (função);
    Retorne.
  Se a categoria deste termo for "scratch",
    Compile o termo usando o percorredor e o campo de estrutura (campos de restruturas);
    Retorne.
  Atribua o campo deste campo de estrutura para um campo.
  Adicione um scratch usando o nome deste tipo deste campo e o caractere inicial deste segmento inicial deste percorredor.
  Adicione um fragmento usando o etiqueta de carregamento de endereço e a variável deste termo e o scratch.
  Se o deslocamento deste campo não for 0, adicione um terceiro fragmento usando a etiqueta de acréscimo e o scratch e o deslocamento deste campo.
  Atribua o scratch à variável deste termo.
  Limpe a frase deste termo.

Rotina para que se compile um termo usando um percorredor e um campo de estrutura (função):
  Se existir algum problema de compilação, retorne.
  Atribua a rotina de função deste campo de estrutura para uma rotina.
  Atribua o último parâmetro destes parâmetros desta rotina para um parâmetro.
  Se o parâmetro for inexistente,
    Apresente uma mensagem de erro contendo "Erro #115. Parâmetro inexistente. " e o percorredor;
    Retorne.
  Se o tipo deste parâmetro for inexistente,
    Apresente a mensagem de erro contendo "Erro #116. Tipo de parâmetro inexistente. " e o percorredor;
    Retorne.
  Adicione uma variável intermediária usando o nome deste tipo deste parâmetro e o caractere inicial deste segmento inicial deste percorredor.
  Adicione um fragmento usando o etiqueta de inserção de endereço [na stack] e a variável intermediária.
  Se o sinalizador de empilhamento deste campo de estrutura estiver ativo, adicione um segundo fragmento usando o etiqueta de inserção de endereço [na stack] e a variável deste termo.
  Adicione um terceiro fragmento usando a etiqueta de demanda interna e a rotina.
  Atribua a variável intermediária à variável deste termo.
  Limpe a frase deste termo.

Rotina para que se compile um termo usando um percorredor e um campo de estrutura (campos de restruturas):
  Se existir algum problema de compilação, retorne.
  Atribua o campo deste campo de estrutura para um campo.
  Atribua o nome deste tipo deste campo ao nome do tipo deste termo.
  Atribua o tipo deste campo ao tipo deste termo.
  Se o deslocamento deste campo não for 0, adicione um terceiro fragmento usando a etiqueta de acréscimo e a variável deste termo e o deslocamento deste campo.
  Limpe a frase deste termo.

Rotina para que se compile um termo usando um percorredor e um nome (possessivo - campo):
  Se existir algum problema de compilação, retorne.
  Se a variável deste termo não for inexistente, atribua o tipo deste termo para um tipo.
  Encontre um campo de estrutura usando o frase deste termo e o tipo e o nome.
  Se o campo de estrutura não estiver vazio,
    Compile o termo usando o percorredor e o campo de estrutura;
    Retorne.
  Se a variável deste termo for inexistente,
    Apresente uma mensagem de erro contendo "Erro #117. A variável do termo '" 
    junto com a frase deste termo seguido de "' não localizada." e o percorredor;
    Retorne.
  Se o tipo puder ser reduzido para "ponteiro", atribua o tipo do conteúdo deste tipo ao tipo.
  Se o tipo for inexistente,
    Apresente a mensagem de erro contendo "Erro #118. O tipo: "
    junto com o nome seguido de "' não foi localizada na estrutura: " 
    junto com o nome deste tipo deste termo seguido de "." e o percorredor;
    Retorne.
  Itere.
    Se existir algum problema de compilação, retorne.
    Obtenha um campo desde os campos deste tipo.
    Se o campo for inexistente,
    Apresente a mensagem de erro contendo "Erro #119. O campo '"
    junto com o nome seguido de "' não foi localizado na estrutura '"
    junto com o nome deste tipo deste termo seguido de "'." e o percorredor;
    Retorne.
    Encontre um campo de estrutura-membro usando "" e o tipo deste campo e o nome.
    Se o campo de estrutura-membro estiver vazio, reitere.
  Atribua o campo para o campo dum primeiro campo de estrutura.
  Se o tipo deste termo puder ser reduzido para "ponteiro", ative o sinalizador de redirecionamento deste primeiro campo de estrutura.
  Compile o termo usando o percorredor e o primeiro campo de estrutura.
  Compile o termo usando o percorredor e o campo de estrutura-membro.

Rotina para que se converta umas unidades semânticas para uma representação interna da rotina :
  Converta as unidades semânticas para a representação interna da rotina usando a última unidade semântica destas unidades semânticas.

Rotina para que se converta umas unidades semânticas para uma representação interna da rotina usando uma unidade semântica:
  Limpe a representação interna da rotina.
  Itere.
    Obtenha um current unidade semântica desde as unidades semânticas.
    Se o current unidade semântica for inexistente, retorne.
    Acrescente o current unidade semântica para a representação interna da rotina.
    Se o current unidade semântica for a unidade semântica, retorne.
  Reitere.

\Rotina para que se converta uma parte da cifra binária para uma string:
  \Employ converta uma cifra hexadecimal para um texto hexadecimal.

Rotina para que se converta um termo por concatenação usando um percorredor: \\ concatenação
  \ used for right-lado followed by operand
  Se a variável deste termo for inexistente,
    Apresente uma mensagem de erro contendo "Erro #120. A variável do termo '"
    junto com a frase deste termo seguido de "' não pode ser encontrada." e o percorredor;
    Retorne.
  Se o tipo deste termo puder ser reduzido para "string", retorne.
  Se o tipo deste termo puder ser reduzido para "texto", retorne.
  Adicione uma variável intermediária usando "string" e o caractere inicial deste segmento inicial deste percorredor.
  \Adicione uma variável intermediária usando "texto" e o caractere inicial deste segmento inicial deste percorredor.
  Adicione o atribua ou converta fragmentos usando a variável deste termo e a variável intermediária e o caractere inicial deste segmento inicial deste percorredor.
  Atribua a variável intermediária à variável deste termo.
  Limpe a frase deste termo.





Rotina para que se copie uns campos para uns segundo campos (apenas campos de dados):
  Se a contagem destes campos for menor do que 4, retorne. \ for english próximo e prev e spanish next e prev redefinitions
  \Se o primeiro campo destes campos for inexistente, retorne.
  \Se o próximo campo deste primeiro campo destes campos for inexistente, retorne.
  \Se o próximo campo deste próximo campo deste primeiro campo destes campos for inexistente, retorne.
  \Atribua o próximo campo deste próximo campo deste primeiro campo destes campos para um campo. \ skip próximo e prev
  \Se o próximo campo deste próximo campo deste próximo campo deste primeiro campo destes campos for inexistente, retorne.
  \Se o próximo campo deste próximo campo deste próximo campo deste próximo campo deste primeiro campo destes campos for inexistente, retorne.
  \Se o próximo campo deste próximo campo deste próximo campo deste próximo campo deste próximo campo deste primeiro campo destes campos for inexistente, retorne.
  \Atribua o próximo campo deste próximo campo deste próximo campo deste próximo campo deste primeiro campo destes campos para um campo.
  Atribua o próximo campo
    Deste próximo campo
    Deste próximo campo
    Deste próximo campo
    Deste primeiro campo destes campos
  Para um campo.\ english próximo e prev e spanish próximo e prev redefinitions
  \ talvez mudar isso aqui ajude?
  Itere.
    Se o campo for inexistente, retorne.
    Copie o campo para um segundo campo.
    Acrescente o segundo campo para o segundo campos.
    Obtenha o campo desde o campos.
  Reitere.

Rotina para que se copie uma unidade semântica para uma segunda unidade semântica:
  Se a unidade semântica for inexistente,
    Esvazie a segunda unidade semântica;
    Retorne.
  Aloque memória para o segunda unidade semântica.
  Atribua a string desta unidade semântica à string desta segunda unidade semântica.
  Atribua o tipo desta unidade semântica ao tipo desta segunda unidade semântica.
  Atribua a variável desta unidade semântica à variável desta segunda unidade semântica.
  \ não copia subtexto
  Atribua o tipo atual desta unidade semântica ao tipo atual desta segunda unidade semântica.

Rotina para que se copie umas unidades semânticas para uns segunda unidades semânticas:
  Destrua a segunda unidades semânticas.
  Itere.
    Obtenha uma unidade semântica desde as unidades semânticas.
    Se a unidade semântica for inexistente, retorne.
    Copie a unidade semântica para uma segunda unidade semântica.
    Acrescente a segunda unidade semântica para a segunda unidades semânticas.
  Reitere.

Rotina para que se crie uma função:
  Aloque memória para a função.

Rotina para que se crie um fragmento usando uma etiqueta:
  Aloque memória para o fragmento.
  Atribua a etiqueta à etiqueta deste fragmento.

Rotina para que se crie uma DLL:
  Aloque memória para a DLL.

Rotina para que se crie uma unidade semântica:
  Aloque memória para a unidade semântica.

Rotina para que se crie uma rotina:
  Aloque memória à rotina.







Função para que se determine se algumas dentre umas unidades semânticas são advérbios de negação:
    Obtenha uma unidade semântica desde as unidades semânticas.
    Se a unidade semântica for inexistente, diga não. \ return true
    Se a string desta unidade semântica for algum advérbio de negação, diga sim.\ return false
  Reitere.

Função para que se determine se um byte é um byte ignorável:
  Se o byte for algum letra, diga sim.
  Se o byte for algum dígito, diga sim.
  Se o byte for o acento til, diga sim.
  Se o byte for o sinal de arroba, diga sim.
  Se o byte for o símbolo cardinal, diga sim.
  Se o byte for o sinal de porcentagem, diga sim.
  Se o byte for o & comercial, diga sim.
  Se o byte for o underline, diga sim.
  Se o byte for o single-quote byte, diga sim.
  Se o byte for o hífem, diga sim.
  Se o byte for o sinal de adição, diga sim.
  Se o byte for o barra inclinada, diga sim.
  Se o byte for o símbolo da Libra Esterlina, diga sim.
  Diga não.



Função para que se determine se um byte é alguma vogal acentuada:
  Se o byte estiver em "áãâàéèêëíîìïóõôöúùüûý", diga sim. \ na verdade a rotina apenas identifica caracteres acentuados
  Diga não.



Função para que se determine se uma campo de estrutura está vazia;
Função para que se determine se umas campo de estrutura estão vazias;
Função para que se determine se uns campo de estrutura estão vazios;
Função para que se determine se um campo de estrutura está vazio:
  Se o campo deste campo de estrutura não for inexistente, diga não.
  Se a rotina de função deste campo de estrutura não for inexistente, diga não.
  Diga sim.

Função para que se determine se uns campos deveriam ser finalizados;
Função para que se determine se uns campos deveria ser finalizado:
  Obtenha um campo desde o campos.
  Se o campo for inexistente, diga não.
  Se o tipo deste campo deveria ser finalizado, diga sim.
  Reitere.

Função para que se determine se uma variável global está causando conflitos: \ Jasper
  Se o nome desta variável global não estiver no catálogo de variáveis globais, diga não.
  Se a variável global estiver perfeitamente predefinida, diga não.
  Diga sim.

Função para que se determine se uma variável global está perfeitamente predefinida: \ Jasper
  Itere.
    Obtenha uma segunda variável global desde as variáveis globais prededinidas.
    Se a segunda variável global for inexistente, diga não.
    Se a variável for alguma cópia de a segunda variável global, diga sim.
  Reitere.

Função para que se determine se uma variável global é alguma cópia de uma segunda variável global: \ Jasper
  Se a variável global for inexistente, diga não.
  Se a segunda variável global for inexistente, diga não.
  \ OK to have different loci.
  Se a categoria desta variável global não for "global", diga não.
  Se a categoria desta segunda variável global não for "global", diga não.
  Se o nome desta variável global não for o nome desta segunda variável global, diga não.
  Se o nome do tipo desta variável global não for o nome do tipo desta segunda variável global, diga não.
  Se o corpo de variável global desta variável global não for o corpo de variável global desta segunda variável global, diga não.
  Diga sim.

Função para que se determine se um item parece ser lexical: \ Jasper
  \Verifiqua progressivamente as porções maiores do arquivo (em bytes).
  Se o item não parece ser lexical usando 200, diga não.
  Se o item não parece ser lexical usando 10000, diga não.
  Se o item não parece ser lexical usando o maior número, diga não.
  Diga sim.

Função para que se determine se um item parece ser lexical usando um tamanho: \ Jasper
  \ O arquivo de léxico não inclui pontos.
  \ Os arquivos de código incluem pontos.
  Leia o endereço completo deste item em um trecho utilizando o tamanho.
  Se o trecho contém um ".", diga não.
  Diga sim.

Função para que se determine se um trecho contém uma string;
Função para que se determine se uma string contém uma segunda string:
  Se a segunda string estiver na string, diga sim.
  Diga não.

Função para que se determine se um item parece ser encadernável:
  Carregue o endereço completo deste item para um trecho.
  Se o trecho começa com "ream cal", diga sim. \ ream
  Se o trecho começa com "ream SAL", diga sim. \
  Se o trecho começa com "ream CEL", diga sim. \ 
  Se o trecho começa com "Este documento foi produzido pelo Editor de Documentos - CEL", diga sim.
  Diga não.

Função para que se determine se uma representação interna da rotina está em um catálogo:
  Encontre um referência usando a representação interna da rotina e o catálogo.
  Se o referência for inexistente, diga não.
  Se o ponteiro deste referência for inexistente, diga não.
  Diga sim.

Função para que se determine se uma unidade semântica está indefinida:
  Se a unidade semântica for inexistente, diga sim.
  \Se a unidade semântica não for inexistente, diga não.\
  Se o tipo atual desta unidade semântica não for inexistente, diga não. 
  \Se o tipo atual desta unidade semântica for inexistente, diga sim. 
  Se o subtexto atual desta unidade semântica não estiver em branco, diga não.
  \Se o subtexto atual desta unidade semântica estiver em branco, diga sim.
  Diga sim.

Função para que se determine se um percorredor está acompanhado por algum unidade de medida:
  Preserve o percorredor.
  Mova o percorredor (usando diretrizes de compilação).
  Se o percorredor não estiver sobre algum indicador de início de variável, diga não.
  Examine um nome usando o percorredor.
  Encontre um tipo usando o nome e o catálogo de tipos.
  Se o tipo for inexistente, diga não.
  Se o nome não for algum operador de multiplicação, diga sim.
  \Se o nome não for "vezes", diga sim. \ necessário porque o termo 'vezes' é um operador de multiplicação e uma unidade de medida
  Se o segmento inicial deste percorredor for o início de alguma expressão matematica, diga não.
  Diga sim.

Função para que se determine se um percorredor está sobre algum simile:
  \ adicionado para as rotinas de grágico de tartatuga ***
  Preserve o percorredor.
  Se o segmento inicial deste percorredor for "like", diga sim.
  \Se o segmento inicial deste percorredor for "como", diga sim.
  \Se o segmento inicial deste percorredor for "quão", diga sim.
  \Se o segmento inicial deste percorredor for "tão", diga sim.
  \Se o segmento inicial deste percorredor for "quanto", diga sim.
  Se o segmento inicial deste percorredor não for "as", diga não.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for algum artigo indefinido, diga não.
  Diga sim.

Função para que se determine se um percorredor é o início de alguma função:
  Se existir algum problema de compilação, diga não.
  \Se o segmento inicial deste percorredor for "Ponha", diga sim.
  \Se o segmento inicial deste percorredor não for algum comando de atribuição, diga não.
  Se o segmento inicial deste percorredor não for "atribua", diga não.
  Preserve o percorredor.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum artigo, diga não.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Se o segmento inicial deste percorredor for algum possessivo inglês, diga sim. \TODO: REMOVER POSSESSIVOS INGLÊS
  Diga não.

Função para que se determine se uma string deveria ser expandida usando uma segunda string (análise de termos compostos):
  Se a string não for "partir", diga não.
  Se a string não for "partindo", diga não.
  \Se a string for alguma locução prepositiva, diga sim.
  Se a segunda string não for "de", diga não.
  Diga sim.

Função para que se determine se uma string termina com alguma consoante e uma segunda string:
  Lance um subtexto sobre a string.
  Subtraia a quantidade de caracteres desta segunda string desde o caractere final deste subtexto.
  Se o subtexto estiver em branco, diga não.
  Se o conteúdo deste caractere final deste subtexto não for alguma consoante, diga não.
  Se a string não terminar com a segunda string, diga não.
  Diga sim.

Função para que se determine se uma string termina com algum vogal e uma segunda string:
  Lance um subtexto sobre a string.
  Subtraia a quantidade de caracteres desta segunda string desde o caractere final deste subtexto.
  Se o subtexto estiver em branco, diga não.
  Se o conteúdo deste caractere final deste subtexto não for algum vogal, diga não.
  Se a string não terminar com a segunda string, diga não.
  Diga sim.

Função para que se determine se uma string termina com alguma vogal ou com alguma consoante:
  Se a string terminar com algum vogal, diga sim.
  Se a string terminar com alguma consoante, diga sim.
  Diga não.

Função para que se determine se uma string termina com alguma consoante:
  Se a string estiver em branco, diga não.
  Se o conteúdo deste caractere final desta string não for alguma consoante, diga não.
  Diga sim.

Função para que se determine se uma string termina com algum vogal:
  Se a string estiver em branco, diga não.
  Se o conteúdo deste caractere final desta string não for algum vogal, diga não.
  Diga sim.

Função para que se determine se uma string é algum operador de adição:
  Se a string for "mais", diga sim.
  Diga não.

Função para que se determine se uma string é algum comando de atribuição:
  \"Rotina para que se acrescente uma string para uma segunda string usando uma terceira string (para expandir contrações)"
  Se a string for "atribua", diga sim.
  Diga não.

Função para que se determine se uma string é algum operador de subtração:
  Se a string for "menos", diga sim.
  Diga não.

Função para que se determine se uma string é algum operador de multiplicação:
  Se a string for "vezes", diga sim.
  Diga não.

Função para que se determine se uma string é algum operador de divisão:
  Se a string for "dividido", diga sim.
  Diga não.

Função para que se determine se uma string é algum objeto indireto:
  Se a string for "via", diga sim. 
  Se a string for "por", diga sim. \ TODO: Testar a compatibilidade
  Diga não.

Função para que se determine se uma string é alguma palavra de concatenação:
  Se a string for "com", diga sim.
  Se a string for "de", diga sim.
  Se a string for "a", diga sim.
  Se a string for "seguida", diga sim.
  Diga não.

Função para que se determine se uma string é algum operador de concatenação:
  Se a string for "junto", diga sim. \ junto do/da, junto com o ...
  Se a string for "juntamente", diga sim. \ juntamente com o...
  Se a string for "seguido", diga sim. \ seguido do ....
  Se a string for "acompanhado", diga sim. \ acompanhado de...
  Se a string for "em", diga sim.
  \Se a string for "&", diga sim.
  Diga não.














Função para que se determine se uma string é algum operador de continuidade:
  Se a string for "e", diga sim.
  Diga não. \repetido?

Função para que se determine se uma string é alguma função possessiva reversa into:
  Se a string for "em", diga sim.
  Se a string for "para", diga sim.
  Diga não.

Função para que se determine se uma string é algum comando de deliberação literal:
  Se a string for "sim", diga sim.
  Se a string for "positivo", diga sim.
  Se a string for "positivamente", diga sim.
  Se a string for "afirmativamente", diga sim.
  Se a string for "não", diga sim.
  Se a string for "negativo", diga sim.
  Se a string for "negativamente", diga sim.
  Se a string for "no", diga sim.
  Diga não.

Função para que se determine se uma string é algum decisor literal afirmativo:
  Se a string for "sim", diga sim.
  Se a string for "positivo", diga sim.
  Se a string for "positivamente", diga sim.
  Se a string for "afirmativamente", diga sim.
  Diga não.

Função para que se determine se uma string é algum decisor literal negativo:
  Se a string for "não", diga sim.
  Se a string for "negativo", diga sim.
  Se a string for "negativamente", diga sim.
  Diga não.

Função para que se determine se uma string é algum valor hexadecimal literal:
  Se a string estiver em branco, diga não.
  Se o conteúdo deste caractere inicial desta string for o cifrão, diga sim.
  Diga não.

Função para que se determine se uma string é algum número órdinal:
  Se a string estiver em branco, diga não.
  Se o conteúdo deste caractere final desta string for o indicador ordinal masculino, diga sim.
  Se o conteúdo deste caractere final desta string for o indicador ordinal feminino, diga sim.
  Diga não.









Função para que se determine se um percorredor está sobre algum artigo definido:
  Se o percorredor estiver sobre algum preposição conectiva, diga não.
  Se o segmento inicial deste percorredor não for algum artigo definido, diga não.
  Diga sim.

Função para que se determine se um percorredor está sobre algum artigo indefinido:
  Se o percorredor estiver sobre algum preposição conectiva, diga não.
  Se o segmento inicial deste percorredor não for algum artigo indefinido, diga não.
  Diga sim.

Função para que se determine se um percorredor está sobre algum preposição conectiva:
  Se o segmento inicial deste percorredor não for "a", diga não.
  Preserve o percorredor.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for algum artigo, diga sim.
  Diga não.







Função para que se determine se uma string é algum sinal de pontuação:
  Se a quantidade de caracteres desta string não for 1, diga não.
  Se o conteúdo deste caractere inicial desta string for algum sinal de pontuação, diga sim.
  Diga não.

\Função para que se determine se uma string é algum unidade semântica string:
\Se a string estiver em branco, diga não.
\Se a string for "the", diga não.
\Se a string é algum artigo indefinido, diga não.
\Se a string é algum possessivo inglês, diga não.
\Se a string é algum valor literal, diga não.
\Se a string é algum sinal de pontuação, diga não.
\Se a string é algum símbolo, diga não.
\Diga sim.

Função para que se determine se um percorredor está sobre algum unidade semântica string:
  Se o segmento inicial deste percorredor estiver em branco, diga não.
  Se o percorredor estiver sobre algum artigo definido, diga não.
  Se o percorredor estiver sobre algum artigo indefinido, diga não.
  Se o segmento inicial deste percorredor for algum possessivo inglês, diga não.
  Se o segmento inicial deste percorredor for algum valor literal, diga não.
  Se o segmento inicial deste percorredor for algum sinal de pontuação, diga não.
  Se o segmento inicial deste percorredor for algum símbolo, diga não.
  Se o segmento inicial deste percorredor for "então", diga não.
  Diga sim.

Função para que se determine se uma string é algum advérbio de negação:
  Se a string for "não", diga sim.
  Diga não.





Função para que se determine se uma string é algum ponteiro literal:
  Se a string for "nulo", diga sim.
  Se a string for "nula", diga sim.
  Se a string for "nulos", diga sim.
  Se a string for "nulas", diga sim.
  Se a string for "inexistente", diga sim.
  Se a string for "inexistentes", diga sim.
  Se a string for "zerado", diga sim.
  \CAL
  Se a string for "nil", diga sim.
  Diga não.




Função para que se determine se uma string é alguma preposição:
  Se a string for "a_partir_de", diga sim.
  Se a string for "aproximadamente", diga sim.
  Se a string for "através", diga sim.
  Se a string for "after", diga sim.
  \Se a string for "all", diga sim.
  Se a string for "alone", diga sim.
  Se a string for "algum", diga sim.
  \Se a string for "as", diga sim.
  Se a string for "sob", diga sim.
  Se a string for "backward", diga sim.
  Se a string for "regressivamente", diga sim.
  Se a string for "backwards", diga sim.
  Se a string for "entre", diga sim.
  Se a string for "aproada", diga sim.
  Se a string for "aproado", diga sim.
  Se a string for "aproando", diga sim.
  Se a string for "orientada", diga sim.
  Se a string for "orientado", diga sim.
  Se a string for "orientando", diga sim.
  Se a string for "orientando-se", diga sim.
  Se a string for "virada", diga sim.
  Se a string for "virado", diga sim.
  Se a string for "virando", diga sim.
  Se a string for "virando-se", diga sim.
  \Se a string for "for", diga sim.
  Se a string for "por", diga sim.
  Se a string for "usando", diga sim.
  Se a string for "tão", diga sim.
  Se a string for "quão", diga sim.
  Se a string for "tanto", diga sim.
  Se a string for "quanto", diga sim.
  Se a string for "dentro", diga sim.
  Se a string for "em comprimento", diga sim.
  Se a string for "d'", diga sim.
  Se a string for "d'", diga sim.
  Se a string for "referente", diga sim.
  Se a string for "pertencente", diga sim.
  Se a string for "pertinente", diga sim.
  Se a string for "somente", diga sim.
  Se a string for "apenas", diga sim.
  Se a string for "só", diga sim.
  Se a string for "exclusivamente", diga sim.
  Se a string for "fora", diga sim.
  \Se a string for "sobre", diga sim.
  Se a string for "pointing", diga sim.
  Se a string for "retornando", diga sim.
  Se a string for "retornando", diga sim.
  Se a string for "começando", diga sim.
  Se o subtexto for "começando", diga sim.
  Se o subtexto for "iniciando", diga sim.
  Se a string for "usando", diga sim.
  Se a string for "via", diga sim.
  Se a string for "com", diga sim.
  Se a string for "dentre", diga sim.
  Se a string for "depois", diga sim. \ depois de
  Se a string for "desde", diga sim.
  Se a string for "aproximadamente", diga sim.
  Se a string for "cerca", diga sim.
  Diga não.


Função para que se determine se uma string é algum possessivo reverso:
  Se a string for "de", diga sim.
  \Se a string for "do", diga sim. \ short por "de o", expanded em "compile um termo usando um percorredor e um campo nome (possessivo reverso)"
  Diga não.



Função para que se determine se um percorredor está sobre ("de" como preposição):
  Preserve o percorredor.
  Se o segmento inicial deste percorredor não for "de", diga não.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for algum artigo, diga sim.
  Diga não.

Função para que se determine se um percorredor está sobre alguma locução prepositiva:
  Preserve o percorredor.
  Se o segmento inicial deste percorredor não for alguma locução prepositiva diga não.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for "de", diga sim.
  Se o segmento inicial deste percorredor for "do", diga sim.\ Se o segmento inicial deste percorredor for "do", atribua "o" para o segmento inicial deste percorredor original; diga sim.
  Se o segmento inicial deste percorredor for "dos", diga sim.
  Se o segmento inicial deste percorredor for "da", diga sim.
  Se o segmento inicial deste percorredor for "das", diga sim.
  Diga não.

Função para que se determine se uma string é alguma locução prepositiva:
  Se a string for alguma preposição, diga sim.
  Diga não.

Função para que se determine se uma string é algum string literal:
  Se a string estiver em branco, diga não.
  Se o conteúdo deste caractere inicial desta string for as aspas duplas, diga sim.
  Diga não.



Função para que se determine se uma string é algum comando condicional:
  Se a string for "se", diga sim.
  Se a string for "quando", diga sim.
  Diga não.

Função para que se determine se uma string é algum comando de proteção:
  Se a string for "isole", diga sim.
  Se a string for "conserve", diga sim.
  Se a string for "preserve", diga sim.
  \Se a string for "derive", diga sim.
  Diga não.

Função para que se determine se uma string é algum comando de percorrimento:
  Se a string for "percorra", diga sim.
  \Se a string for "comece", diga sim.
  Se a string for "itere", diga sim.
  Diga não.

Função para que se determine se uma string é algum comando de interrupção de repetições:
  Se a string for "pare", diga sim.
  Diga não.

Função para que se determine se uma string é algum comando de retorno de rotina:
  Se a string for "Retorne", diga sim.
  Diga não.

Função para que se determine se uma string é algum comando de repetição:
  \Se a string for "recomece", diga sim.
  \Se a string for "repita", diga sim.
  Se a string for "reitere", diga sim.
  \Se a string for "reinicie", diga sim.
  Diga não.

Função para que se determine se uma string é algum comando de confirmação ou negação:
  Se a string for "diga", diga sim.
  Se a string for "responda", diga sim.
  Diga não.

Função para que se determine se uma string é algum comando de deliberação:
  Se a string for "decida", diga sim.
  Se a string for "determine", diga sim.
  Se a string for "esclareça", diga sim.
  Diga não.

Função para que se determine se uma string é alguma chamada de biblioteca externa:
  Se a string for "chame", diga sim.
  Se a string for "invoque", diga sim.
  \Se a string for "acione", diga sim.
  Se a string for "processe", diga sim.
  \Se a string for "informe", diga sim.\ no caso de comandos como "informe os parâmetros x e y e z para a função "FunctionName" da biblioteca "MyLibrary.dll"
  Diga não.

Função para que se determine se uma string é algum point:
  Se a string for "aponte", diga sim.
  Se a string for "direcione", diga sim.
  Se a string for "redirecione", diga sim.
  Diga não.

Função para que se determine se uma string é uma palavra-chave de reutilização de rotina:
  \ Funcionalidade obsoleta desde a implantação da sobrecarga de cabeçalhos de rotina
  Se a string for "empregue", diga sim.
  Diga não.

Função para que se determine se uma string é alguma palavra ignorável:
  Se a string for "já", diga sim.
  Se a string for "ainda", diga sim.
  \Se a string for "que", diga sim.
  \Se a string for "se", diga sim.
  Diga não.

Função para que se determine se uma string é o início de alguma expressão matematica:
  Se a string for algum sinal aritmético, diga sim.
  Se a string for algum artigo indefinido, diga sim.
  Se a string for algum artigo definido, diga sim.
  Se a string for algum valor literal, diga sim.
  Diga não.



Função para que se determine se uma string é o início de alguma variável local:
  Se a string for algum artigo indefinido, diga sim.
  Diga não.

Função para que se determine se uma string é o início de algum dado complementar:
  \PAL
  Se a string for "com", diga sim.
  Se a string for "contendo", diga sim.
  Diga não.





Função para que se determine se uma string é o início de alguma declaração:
  Se a string for o enunciado de alguma rotina ou variável, diga não.
  Se a string for algum valor literal, diga não.
  Se a string for algum sinal de pontuação, diga não.
  Se a string estiver em branco, diga não.
  Diga sim.



Função para que se determine se uma string é o início de alguma variável:
  Se a string for algum artigo definido, diga sim.
  \Se a string for "do", diga sim. \ this é iffy, here por reverse-possessives
  Diga não.

Função para que se determine se uma string possui alguma vogal acentuada:
  Preserve a string.
  Itere.
    Se a string estiver em branco, diga não.
    Se o conteúdo deste caractere final desta string for alguma vogal acentuada, diga sim.
    Subtraia 1 desde o caractere final desta string.
  Reitere.

Função para que se determine se uma termo está vazia;
Função para que se determine se uns termo estão vazias;
Função para que se determine se uns termo estão vazios;
Função para que se determine se um termo está vazio:
  Se a variável deste termo não for inexistente, diga não.
  Se a frase deste termo não estiver em branco, diga não.
  Diga sim.



Função para que se determine se um tipo é algum tipo pré-definido:
  Se o tipo for inexistente, diga não.
  Se o tipo for o tipo base deste tipo, diga sim.
  Diga não.

Função para que se determine se um tipo é valor empilhável:
  Se o tipo for inexistente, diga não.
  Se a quantidade de caracteres deste tipo for 4, diga sim.
  Se a quantidade de caracteres deste tipo for 2, diga sim.
  Se a quantidade de caracteres deste tipo for 1, diga sim.
  Diga não.

Função para que se determine se um tipo deveria ser finalizado: [determina se o compilador deveria liberar a memória alocada para algum tipo]
  \The frase "should be finalized" means "ought to be/needs to be automatically deallocated".
  Se o tipo for inexistente, diga não.
  Se o tipo puder ser reduzido para "subtexto", diga não.\ substrings point to (parts of) real strings that get deallocated elsewhere
  Se o tipo puder ser reduzido para "string", diga sim.\ the normal case for strings
  Se o tipo puder ser reduzido para "texto", diga sim.\ the normal case for strings
  Se os campos deste tipo deveriam ser finalizados, diga sim.\ this is for strings dentro de records
  Diga não.

Função para que se determine se um tipo deveria ser ignorado: [ou seja, o compilador não deveria finalizar esse tipo de forma automática]
  \ ie, can be destroyed/needs a destroy routine generated for it
  \The frase "should be forgotten" means "ought to be forgotten" which really means "needs to have a destroy routine automatically generated for it".
  \See page 93 of the manual.
  Se o tipo for inexistente, diga não.
  \PAL
  \Se o nome deste tipo for "elemento", diga não.
  \Se o nome deste tipo for "elementos", diga não.
  \CAL
  Se o nome deste tipo for "lista", diga não. \ no, because this is the tipo primitivo which we don't ever allocate or destroy, it exists so we can "magically" add próximo and precedente fields to anything defined as a "thing"
  Se o nome deste tipo for "listas", diga não. \ no, because this is the tipo primitivo we "magically" generate to anchor lists of things, same as above of .
  Se o tipo puder ser reduzido para "listas", diga sim. \ yes, because (though it seems to contradict the line immediately above of ) this is a an actual list of things that we can destroy, for example "some pages".
  Se o tipo não puder ser reduzido para "ponteiro", diga não. \ \ no, because a pointer variable is a static variable (it is the address in the variable that is dynamic); the pointer variable itself is not something that can be dynamically allocated, so no destroy is necessary
  Se o tipo do conteúdo deste tipo for inexistente, diga não. \ no, because it's a pointer to nothing, so there's nothing to destroy.
  Se o tipo do conteúdo deste tipo não puder ser reduzido para "ponteiro", diga sim.\ yes, because it's a pointer to something allocated, not a pointer to another pointer. Pointers to pointers are handled with the próximo recursive line
  Se o tipo do conteúdo deste tipo não deveria ser ignorado, diga não.\ no, because it's a pointer to something that shouldn't be destroyed. For example, a pointer to a thing
  Diga sim.\ The último condition is the hardest to wrap one's head around since it is recursive.



Rotina para que se elimine apelidos duplicados desde umas variáveis:
  Crie um catálogo usando 101.
  Elimine apelidos duplicados desde as variáveis usando o catálogo.
  Destrua o catálogo.

Rotina para que se elimine apelidos duplicados desde umas variáveis usando um catálogo:
  Se o catálogo for inexistente, retorne.
  Itere.
    Obtenha uma variável desde as variáveis.
    Se a variável for inexistente, retorne.
    Elimine apelidos duplicados usando a variável e o catálogo.
  Reitere.

Rotina para que se elimine apelidos duplicados usando uma variável e um catálogo:
  Se a variável for inexistente, retorne.
  Se o catálogo for inexistente, retorne.
  Encontre uma segunda variável usando o apelido desta variável e o catálogo.
  Se a segunda variável for inexistente, encontre a segunda variável usando o nome desta variável e o catálogo.
  Se a segunda variável for inexistente,
    Catalogue a variável usando o apelido desta variável e o catálogo;
    Retorne.
  Limpe o apelido desta segunda variável.
  Limpe o apelido desta variável.





Rotina para que se encontre uma função usando uma string e uns funções:
  Esvazie a função.
  Itere.
    Obtenha a função desde as funções.
    Se a função for inexistente, retorne.
    Se o nome desta função for a string, retorne.
  Reitere.

Rotina para que se encontre um campo de estrutura usando um frase e um tipo e um nome:
  Limpe o campo de estrutura.
  Encontre o campo de estrutura usando o tipo e o nome.
  Se o campo deste campo de estrutura não for inexistente, retorne.
  Se a frase não estiver em branco, encontre uma rotina usando "atribua" e a frase e "'s " junto com o nome e "para". \ traduzir
  Se a rotina não for inexistente,
    Atribua a rotina à rotina de função deste campo de estrutura;
    Retorne.
  Se o tipo for inexistente, retorne.
  Encontre a rotina usando "atribua" e o tipo e "'s " junto com o nome e "para".  \traduzir
  Se a rotina não for inexistente,
    Ative o sinalizador de empilhamento deste campo de estrutura;
    Atribua a rotina à rotina de função deste campo de estrutura;
    Retorne.
  \  code below for looking deep dentre pointers - a debatable feature
  \ Se o tipo do conteúdo deste tipo não for inexistente, encontre a rotina usando "atribua" e o tipo do conteúdo deste tipo e "'s " junto com o nome e "para".
  \ Se a rotina não for inexistente, ative o sinalizador de redirecionamento deste campo de estrutura; atribua a rotina à rotina de função deste campo de estrutura; Retorne.

Rotina para que se encontre um campo de estrutura usando um tipo e um nome:
  Se o tipo for inexistente, retorne.
  Encontre um campo usando o nome e os campos deste tipo.
  Se o campo não for inexistente,
    Atribua o campo ao campo deste campo de estrutura;
    Retorne.
  Se o tipo do conteúdo deste tipo não for inexistente,
    Encontre o campo usando o nome e os campos deste tipo do conteúdo deste tipo.
  Se o campo não for inexistente,
    Ative o sinalizador de redirecionamento deste campo de estrutura;
    Atribua o campo ao campo deste campo de estrutura;
    Retorne.

Rotina para que se encontre um fragmento usando um segundo fragmento e uma etiqueta:
  Atribua o segundo fragmento ao fragmento.
  Itere.
    Se o fragmento for inexistente, retorne.
    Se a etiqueta deste fragmento for a etiqueta, retorne.
    Atribua o próximo fragmento deste fragmento ao fragmento.
  Reitere.

Rotina para que se encontre um fragmento usando um segundo fragmento e uma etiqueta (regressivamente):
  Atribua o segundo fragmento ao fragmento.
  Itere.
    Se o fragmento for inexistente, retorne.
    Se a etiqueta deste fragmento for a etiqueta, retorne.
    Atribua o fragmento anterior deste fragmento ao fragmento.
  Reitere.

Rotina para que se encontre uma DLL usando uma string:
  Esvazie a DLL.
  Itere.
    Obtenha a DLL desde as DLLs.
    Se a DLL for inexistente, retorne.
    Se o nome desta DLL for a string, retorne.
  Reitere.



Rotina para que se encontre uma rotina usando uma representação interna da rotina e uma unidade semântica e um catálogo:
  Se a unidade semântica for inexistente, retorne.
  Esvazie a rotina.
  Preserve a representação interna da rotina.
  Atribua o tipo desta unidade semântica ao tipo atual desta unidade semântica.
  Lance o subtexto atual desta unidade semântica sobre a string desta unidade semântica.
  Itere.
    Acrescente a unidade semântica para a representação interna da rotina (inserção de colchetes).
    Encontre uma referência usando a representação interna da rotina e o catálogo.
    Se a referência não for inexistente, atribua o ponteiro deste referência à rotina.
    Se a referência não for inexistente, encontre a rotina usando a representação interna da rotina e a próxima unidade semântica desta unidade semântica e o catálogo.
    Se a rotina não for inexistente, pare.
    Defina o tipo de a unidade semântica.
    Se a unidade semântica estiver indefinida, pare.
    Atribua a representação interna da rotina original para a representação interna da rotina.
  Reitere.

Rotina para que se encontre uma rotina usando umas unidades semânticas:
  Esvazie a rotina.
  Encontre a rotina usando uma representação interna da rotina e a primeira unidade semântica destas unidades semânticas e o catálogo geral de rotinas.

Rotina para que se encontre uma rotina usando uma string e uma segunda string e uma terceira string e um quarto string:
  Adicione uma unidade semântica para umas unidades semânticas usando a string.
  Adicione uma segunda unidade semântica para as unidades semânticas usando a segunda string.
  Adicione uma terceira unidade semântica para as unidades semânticas usando a terceira string.
  Adicione uma quarta unidade semântica para as unidades semânticas usando o quarto string.
  Encontre a rotina usando as unidades semânticas.
  Destrua as unidades semânticas.

Rotina para que se encontre uma rotina usando uma string e um tipo:
  Adicione uma unidade semântica para umas unidades semânticas usando a string.
  Adicione uma segunda unidade semântica para as unidades semânticas usando o tipo.
  Encontre a rotina usando as unidades semânticas.
  Destrua as unidades semânticas.

Rotina para que se encontre uma rotina usando uma string e um tipo e uma segunda string e um segundo tipo:
  Adicione uma unidade semântica para umas unidades semânticas usando a string.
  Adicione uma segunda unidade semântica para as unidades semânticas usando o tipo.
  Adicione uma terceira unidade semântica para as unidades semânticas usando a segunda string.
  Adicione uma quarta unidade semântica para as unidades semânticas usando o segundo tipo.
  Encontre a rotina usando as unidades semânticas.
  Destrua as unidades semânticas.

Rotina para que se encontre uma rotina usando uma string e um tipo e uma segunda string e uma terceira string:
  Adicione uma unidade semântica para umas unidades semânticas usando a string.
  Adicione uma segunda unidade semântica para as unidades semânticas usando o tipo.
  Adicione uma terceira unidade semântica para as unidades semânticas usando a segunda string.
  Adicione uma quarta unidade semântica para as unidades semânticas usando a terceira string.
  Encontre a rotina usando as unidades semânticas.
  Destrua as unidades semânticas.

Rotina para que se encontre uma rotina usando uma string e um tipo e uma segunda string e uma terceira string e uma quarta string e uma quinta string:
  Adicione uma unidade semântica para umas unidades semânticas usando a string.
  Adicione uma segunda unidade semântica para as unidades semânticas usando o tipo.
  Adicione uma terceira unidade semântica para as unidades semânticas usando a segunda string.
  Adicione uma quarta unidade semântica para as unidades semânticas usando a terceira string.
  Adicione uma quinta unidade semântica para as unidades semânticas usando a quarta string.
  Adicione uma sexta unidade semântica para as unidades semânticas usando a quinta string.
  Encontre a rotina usando as unidades semânticas.
  Destrua as unidades semânticas.

Rotina para que se encontre uma variável usando um nome:
  Se a rotina utilizada atualmente for inexistente,
    Esvazie a variável;
    Retorne.
  Encontre a variável usando o nome e as variáveis locais desta rotina utilizada atualmente.
  Se a variável não for inexistente, retorne.
  Encontre a variável usando o nome e os parâmetros desta rotina utilizada atualmente.
  Se a variável não for inexistente, retorne.
  Encontre a variável usando o nome e o catálogo de variáveis globais.
  Se a variável não for inexistente, retorne.
  Encontre a variável usando o nome e o catálogo de variáveis hexadecimais.

Rotina para que se encontre uma variável usando um nome e umas variáveis:
  Esvazie a variável.
  Itere.
    Obtenha a variável desde as variáveis.
    Se a variável for inexistente, retorne.
    Se o nome desta variável for o nome, retorne.
    Se o apelido desta variável for o nome, retorne.
  Reitere.

Rotina para que se gere um nome usando uma string:
  Atribua a string ao nome.
  Adicione 1 para a contagem de nomes deste compilador.
  Converta a contagem de nomes deste compilador para uma segunda string.
  Acrescente a segunda string para o nome.

Rotina para que se obtenha um endereço usando uma rotina:
  Se o endereço desta rotina não for 0,
    Atribua o endereço desta rotina ao endereço;
    Retorne.
  Atribua -1 ao endereço desta rotina.
  Encontre uma segunda rotina usando o representação de emprego desta rotina e o catálogo geral de rotinas.
  Se a segunda rotina for inexistente,
    Apresente uma mensagem de erro contendo "Erro #121. Rotina: " junto com 
    a representação de emprego desta rotina seguido de "' não encontrada. (palavra-chave empregue)" 
    e o endereço local desta rotina;
    Retorne.
  Se o endereço desta segunda rotina for -1,
    Apresente a mensagem de erro contendo "Erro #122. Referência recursiva na palavra-chave 'empregue'." 
    e o endereço local desta rotina;
    Retorne.
  Obtenha o endereço usando a segunda rotina.
  Atribua o endereço ao endereço desta rotina.

Rotina para que se obtenha uma contagem usando umas DLLs (todas as funções mais os marcadores):
  Atribua 0 à contagem.
  Itere.
    Obtenha uma DLL desde as DLLs.
    Se a DLL for inexistente, retorne.
    Adicione a contagem destas funções desta DLL para a contagem.
    Adicione 1 para a contagem.
  Reitere.

Rotina para que se catalogue um valor literal:
  Se existir algum problema de compilação, retorne.
  Se o valor literal for inexistente, retorne.
  Se o nome deste valor literal estiver no catálogo de variáveis hexadecimais,
    Apresente uma mensagem de erro contendo "Erro interno #124. O nome deste valor literal já foi catalogado anteriormente" 
    e o endereço local deste valor literal;
    Retorne.
  Catalogue o valor literal usando o nome deste valor literal e o catálogo de variáveis hexadecimais.

Rotina para que se catalogue um cabeçalho compactado usando um catálogo (especial):
  Encontre uma referência usando o cabeçalho compactado e o catálogo.
  Se a referência não for inexistente, retorne.
  Catalogue o cabeçalho compactado no catálogo.

Rotina para que se catalogue uma rotina por utilização:
  Se existir algum problema de compilação, retorne.
  Se a rotina for inexistente, retorne.
  Se o sinalizador de função desta rotina estiver ativo, retorne.
  Se a contagem destes parâmetros desta rotina for 0, retorne.
  Copie as unidades semânticas desta rotina para umas unidades semânticas.
  Reduza as unidades semânticas por utilização.
  Converta as unidades semânticas para uma representação interna da rotina.
  Destrua as unidades semânticas.
  Se a representação interna da rotina estiver no catálogo geral de rotinas, retorne.
  Encontre uma referência usando a representação interna da rotina e o catálogo de rotinas úteis.
  Se a referência não for inexistente,
    Atribua nil ao ponteiro deste referência;
    Retorne.
  Catalogue a rotina usando a representação interna da rotina e o catálogo de rotinas úteis.

Rotina para que se catalogue uma rotina usando uma representação interna da rotina e um catálogo (especial):
  Encontre uma referência usando a representação interna da rotina e o catálogo.
  Se a referência não for inexistente,
    Atribua a rotina ao ponteiro deste referência;
    Retorne.
  Catalogue a rotina usando a representação interna da rotina e o catálogo.

Rotina para que se catalogue uma rotina usando umas unidades semânticas e um catálogo:
  Se a rotina for inexistente, retorne.
  Limpe um cabeçalho compactado.
  Itere.
    Obtenha uma unidade semântica desde as unidades semânticas.
    Se a unidade semântica for inexistente, retorne.
    Acrescente a unidade semântica para o cabeçalho compactado.
    Se a unidade semântica for a última unidade semântica destas unidades semânticas, pare.
    Catalogue o cabeçalho compactado usando o catálogo (especial).
  Reitere.
  Catalogue a rotina usando o cabeçalho compactado como uma representação interna da rotina e o catálogo (especial).

Rotina para que se catalogue umas rotinas por utilização:
  Se existir algum problema de compilação, retorne.
  Obtenha uma rotina desde as rotinas.
  Se a rotina for inexistente, retorne.
  Catalogue a rotina por utilização.
  Reitere.





\Rotina para que se inicialize o compilador:
\Rotina em branco. Serve apenas para fazer com que o código fique "simétrico"



Rotina para que se inicialize um cabeçalho DOS: \ vou alterar depois
  Atribua 23117 [$5A4D] ao Signature deste cabeçalho DOS.
  Atribua 64 [$0040] ao AddressOfRelocationTableInFile deste cabeçalho DOS. \ pointer to the table of DLLs needed for this program.
  Atribua 256 [$00000100] ao AddressOfPEHeaderInFile deste cabeçalho DOS. \ pointer to the PE Header, 
  \Os 16 camposrestantes  do cabeçalho DOS não são utilizados

Rotina para que se inicialize um Cabeçalho PE:
  Inicialize o Cabeçalho PE (cabeçalho padrão).
  Inicialize o Cabeçalho PE (cabeçalho opcional).
  Inicialize o Cabeçalho PE (informação da versão).
  Inicialize o Cabeçalho PE (diretórios).
  Inicialize o Cabeçalho PE (Seção de DLLs).
  Inicialize o Cabeçalho PE (seção de dados).
  Inicialize o Cabeçalho PE (seção de código).

Rotina para que se inicialize um Cabeçalho PE (seção de código):
  Atribua "code  " para uma string.
  Copie bytes desde o caractere inicial desta string para o endereçamento deste nome desta Code Section deste Cabeçalho PE por 6.
  Atribua a quantidade de caracteres desta Região de Código ao SizeInBytes desta Code Section deste Cabeçalho PE.
  Atribua o endereço base desta Região de Código  ao AddressInMemory desta Code Section deste Cabeçalho PE.
  Atribua a quantidade de caracteres desta Região de Código  ao SizeInFile desta Code Section deste Cabeçalho PE.
  Atribua o endereço base desta Região de Código  ao AddressInFile desta Code Section deste Cabeçalho PE.
  Atribua -536870880 [$E0000020 ] para as Characteristics desta Code Section deste Cabeçalho PE. \ executable, readable, writable, code object
  \IMAGE_FILE_LARGE_ADDRESS_ AWARE 0x0020 - Application can handle > 2-GB addresses.

Rotina para que se inicialize um Cabeçalho PE (seção de dados):
  Atribua "data " para uma string.
  Copie bytes desde o caractere inicial desta string para o endereçamento deste nome desta Data Section deste Cabeçalho PE por 6.
  Atribua a quantidade de caracteres desta região de dados ao SizeInBytes desta Data Section deste Cabeçalho PE.
  Atribua o endereço base desta região de dados ao AddressInMemory desta Data Section deste Cabeçalho PE.
  Atribua a quantidade de caracteres desta região de dados ao SizeInFile desta Data Section deste Cabeçalho PE.
  Atribua o endereço base desta região de dados ao AddressInFile desta Data Section deste Cabeçalho PE.
  Atribua -1073741760 [$C0000040] para as Characteristics desta Data Section deste Cabeçalho PE. \ initialized, readable, writable

Rotina para que se inicialize um Cabeçalho PE (diretórios):
  Atribua 16 [$00000010] ao NumberOfDirectories deste Cabeçalho PE.
  Atribua o endereço base desta seção de DLLs ao ImageDirectoryEntryImportAddress deste Cabeçalho PE.
  Atribua a quantidade de caracteres desta seção de DLLs ao ImageDirectoryEntryImportSize deste Cabeçalho PE.

Rotina para que se inicialize um Cabeçalho PE (Seção de DLLs):
  Atribua "idata " para uma string.
  Copie bytes desde o caractere inicial desta string para o endereçamento deste nome desta Idata Section deste Cabeçalho PE por 6.
  Atribua a quantidade de caracteres desta seção de DLLs ao SizeInBytes desta Idata Section deste Cabeçalho PE.
  Atribua o endereço base desta seção de DLLs ao AddressInMemory desta Idata Section deste Cabeçalho PE.
  Atribua a quantidade de caracteres desta seção de DLLs ao SizeInFile desta Idata Section deste Cabeçalho PE.
  Atribua o endereço base desta seção de DLLs ao AddressInFile desta Idata Section deste Cabeçalho PE.
  Atribua -1073741760 [$C0000040] para as Characteristics desta Idata Section deste Cabeçalho PE. \ initialized, readable, writable

Rotina para que se inicialize um Cabeçalho PE (cabeçalho opcional):
  Atribua 267 [$010B] ao MagicNumber deste Cabeçalho PE.
  \The magic number for PE32+ executables is $020B [523]
  Atribua a quantidade de caracteres desta Região de Código ao SizeOfCodeInFile deste Cabeçalho PE.
  Atribua a quantidade de caracteres desta Região de Dados ao SizeOfInitializedDataInFile deste Cabeçalho PE.
  Atribua 0 ao SizeOfUninitializedDataInFile deste Cabeçalho PE.
  Encontre uma rotina usando "~Inicialize antes da execução e Execute o programa e Finalize após execução" e o catálogo geral de rotinas. \ AddressOfEntryPointInMemory
  Se a rotina for inexistente,
    Apresente uma mensagem de erro contendo "Erro interno #126. Uma das rotinas de inicialização do cabeçalho PE não foi encontrada no catálogo geral de rotinas. ";
    Retorne.
  Atribua o endereço desta rotina menos o image base ao AddressOfEntryPointInMemory deste Cabeçalho PE.
  Atribua o Endereço Base desta Região de Código ao AddressOfCodeInMemory deste Cabeçalho PE. \BaseOfCode
  Atribua o Endereço Base desta Região de Dados ao AddressOfInitializedDataInMemory deste Cabeçalho PE. \BaseOfData
  Atribua o Image Base à ImageBase deste Cabeçalho PE.
  Atribua 4096 [$00001000] ao MemoryAlignment deste Cabeçalho PE. \ 4 KB
  Atribua 4096 [$00001000] ao FileAlignment deste Cabeçalho PE. \ 4 KB. used to align the raw data of sections in the image file. The value should be a power of 2
  Atribua 0 ao Reserved deste Cabeçalho PE.
  Atribua o Tamanho Do Executável deste Compilador ao SizeOfImageInMemory deste Cabeçalho PE.
  Atribua 4096 [section base] ao SizeOfAllHeadersInFile deste Cabeçalho PE. \ 4 KB
  Atribua 0 ao CheckSum deste Cabeçalho PE.
  Atribua 0 para as DLLCharacteristics deste Cabeçalho PE.
  Atribua 1048576 [$00100000] ao MaxStack deste Cabeçalho PE. \ SizeOfStackReserve
  Atribua 16384 [$00004000] ao MinStack deste Cabeçalho PE. \ SizeOfStackCommit
  Atribua 1048576 [$00100000] ao MaxHeap deste Cabeçalho PE. \ SizeOfHeapReserve. The number of bytes to reserve for the local heap
  Atribua 16384 [$00004000] ao MinHeap deste Cabeçalho PE. \ SizeOfHeapCommit. The number of bytes to commit for the local heap.
  Atribua 0 ao LoaderFlags deste Cabeçalho PE. \ This member is obsolete.

Rotina para que se inicialize um Cabeçalho PE (cabeçalho padrão):
  Atribua 17744 [$00004550] ao Signature deste Cabeçalho PE. \ -> 50 45 00 00
  Atribua 332 [$014C] ao MachineType deste Cabeçalho PE. \ IMAGE_FILE_MACHINE_I386 
  Atribua 3 [$0003] ao NumberOfSections deste Cabeçalho PE. \ IMAGE_SCN_ALIGN_4BYTES
  Atribua 0 ao TimeStamp deste Cabeçalho PE.
  Atribua 0 ao PointerToSymbolTable deste Cabeçalho PE.
  Atribua 0 ao NumberOfSymbols deste Cabeçalho PE.
  Atribua 224 [$00E0] ao SizeOfOptionalHeaderInBytes deste Cabeçalho PE. \ IMAGE_SCN_ALIGN_8192BYTES
  Atribua 33166 [$818E] às Characteristics deste Cabeçalho PE.

Rotina para que se inicialize um Cabeçalho PE (informação da versão):
  Atribua 0 ao MajorLinkerVersion deste Cabeçalho PE.
  Atribua 0 ao MinorLinkerVersion deste Cabeçalho PE.
  Atribua 4 [$0004] ao OS_MajorVersion deste Cabeçalho PE.
  Atribua 0 [$0000] ao OS_MinorVersion deste Cabeçalho PE.
  Atribua 0 ao UserMajorVersion deste Cabeçalho PE.
  Atribua 0 ao UserMinorVersion deste Cabeçalho PE.
  Atribua 4 [$0004] ao SubsystemMajorVersion deste Cabeçalho PE.
  Atribua 0 [$0000] ao SubsystemMinorVersion deste Cabeçalho PE.
  Atribua 3 [$0003] ao Subsystem deste Cabeçalho PE.

Rotina para que se vincule:
  Arredonde para cima tamanhos de zona.
  Inicialize um cabeçalho DOS.
  Inicialize um Cabeçalho PE.
  Preencha o trecho EXE deste compilador com o caractere null usando o tamanho do executável deste compilador.
  Disponibilize o cabeçalho DOS ao trecho EXE deste compilador.
  Disponibilize o Cabeçalho PE ao trecho EXE deste compilador.
  Disponibilize as DLLs ao trecho EXE deste compilador.
  Disponibilize as variáveis globais ao trecho EXE deste compilador.
  Disponibilize os valores literais ao trecho EXE deste compilador.
  Disponibilize as rotinas ao trecho EXE deste compilador.

Rotina para que se liste tudo:
  Limpe o trecho de listagem deste compilador.
  Liste a mensagem de erro deste compilador na trecho de listagem deste compilador.
  Liste os tipos depois de "TIPOS:" na trecho de listagem deste compilador.
  Liste as variáveis globais depois de "VARIÁVEIS GLOBAIS:" na trecho de listagem deste compilador.
  Liste os valores literais depois de "VALORES LITERAIS:" na trecho de listagem deste compilador.
  Liste as rotinas depois de "ROTINAS:" na trecho de listagem deste compilador.
  Liste o catálogo de tipos depois de "ÍNDICE DE TIPOS:" na trecho de listagem deste compilador.
  Liste o catálogo de variáveis globais depois de "ÍNDICE GLOBAL:" na trecho de listagem deste compilador.
  Liste o catálogo de variáveis hexadecimais depois de "ÍNDICE DE VALORES LITERAIS:" na trecho de listagem deste compilador.
  Liste o catálogo geral de rotinas depois de "ÍNDICE DE ROTINAS:" na trecho de listagem deste compilador.
  Liste o catálogo de rotinas úteis depois de "Catálogo de Rotinas Úteis:" na trecho de listagem deste compilador.
  Liste as DLLs depois de "DLL's:" na trecho de listagem deste compilador.
  Liste os arquivos fontes depois de "ARQUIVOS FONTE:" na trecho de listagem deste compilador.
  Liste os temporizadores depois de "TEMPORIZADORES:" na trecho de listagem deste compilador.
  Escreva o trecho de listagem deste compilador para o listagem endereço completo deste compilador.

Rotina para que se liste um mensagem de erro em um trecho:
  Se o mensagem de erro estiver em branco, retorne.
  Acrescente "COMPILAÇÃO INTERROMPIDA - LISTAGEM INCOMPLETA" para o trecho.
  Insira quebra de linha no trecho (duas vezes).
  Acrescente o mensagem de erro para o trecho.
  Insira quebra de linha no trecho (duas vezes).

Rotina para que se liste um recipiente em um trecho:
  Se as referências deste recipiente estiverem vazios, retorne.
  Acrescente "| RECIPIENTE" para o trecho (com separador).
  Insira quebra de linha no trecho.
  Liste as referências deste recipiente no trecho.
  Insira quebra de linha no trecho.

Rotina para que se liste umas funções em um trecho:
  Obtenha uma função desde as funções.
  Se a função for inexistente, retorne.
  Liste a função no trecho.
  Reitere.

Rotina para que se liste uma função em um trecho:
  Se a função for inexistente, retorne.
  Acrescente "| FUNÇÃO" para o trecho (com separador).
  Acrescente o nome desta função para o trecho (com separador).
  Acrescente o endereço desta função para o trecho (cifra hexadecimal com separador).
  Insira quebra de linha no trecho.

Rotina para que se liste um fragmento em um trecho:
  Acrescente "| FRAGMENTO" para o trecho (com separador).
  Acrescente a etiqueta deste fragmento para o trecho (geral).
  Acrescente "Variável principal: " para o trecho.
  Acrescente a variável deste fragmento para o trecho (com separador).
  Acrescente "Variável secundária: " para o trecho.
  Acrescente a segunda variável deste fragmento para o trecho (com separador).
  Acrescente "Rotina: " para o trecho.
  Acrescente a rotina deste fragmento para o trecho (com separador).
  Acrescente "Entrada: " para o trecho.
  Acrescente a função desta fragmento para o trecho (com separador).
  Acrescente "Número hexadecimal: " para o trecho.
  Acrescente o número deste fragmento para o trecho (cifra hexadecimal com separador).
  Acrescente "Endereço: " para o trecho.
  Acrescente o endereço deste fragmento para o trecho (cifra hexadecimal com separador).
  Converta o código deste fragmento para uma cifra hexadecimal.
  Acrescente "Código compilado: " para o trecho.
  Acrescente a cifra hexadecimal para o trecho (com separador).
  Insira quebra de linha no trecho.

Rotina para que se liste uns fragmentos em um trecho:
  Obtenha um fragmento desde o fragmentos.
  Se o fragmento for inexistente, retorne.
  Liste o fragmento no trecho.
  Reitere.

Rotina para que se liste uma DLL em um trecho:
  Se a DLL for inexistente, retorne.
  Acrescente "| DLL" para o trecho (com separador).
  Acrescente o nome desta DLL para o trecho (com separador).
  Insira quebra de linha no trecho.
  Liste as funções desta DLL no trecho.
  Insira quebra de linha no trecho.

Rotina para que se liste umas DLLs em um trecho:
    Obtenha uma DLL desde as DLLs.
    Se a DLL for inexistente, retorne.
    Liste a DLL no trecho.
  Reitere.

Rotina para que se liste umas DLLs depois de uma string em um trecho:
  Acrescente a string para o trecho.
  Insira quebra de linha no trecho (duas vezes).
  Se as DLLs estiverem vazios, retorne.
  Liste as DLLs no trecho.

Rotina para que se liste um catálogo em um trecho:
  Acrescente "| " junto com o used contagem de recipientes deste catálogo seguido de " recipientes" para o trecho (com separador).
  Acrescente a contagem deste catálogo seguido de " referências" para o trecho (com separador).
  Insira quebra de linha no trecho (duas vezes).
  Itere.
    Obtenha um recipiente usando o catálogo.
    Se o recipiente for inexistente, retorne.
    Liste o recipiente no trecho.
  Reitere.

Rotina para que se liste um catálogo depois de uma string em um trecho:
  Acrescente a string para o trecho.
  Insira quebra de linha no trecho (duas vezes).
  Se o catálogo estiver vazio, retorne.
  Liste o catálogo no trecho.

Rotina para que se liste uma referência em um trecho:
  Se a referência for inexistente, retorne.
  Acrescente "| REFERÊNCIA" para o trecho (com separador).
  Acrescente a string deste referência para o trecho.
  Se o ponteiro deste referência for inexistente, acrescente " (ponteiro inexistente) " para o trecho.
  Acrescente "| " para o trecho.
  Insira quebra de linha no trecho.

Rotina para que se liste umas referências em um trecho:
  Obtenha uma referência desde as referências.
  Se a referência for inexistente, retorne.
  Liste a referência no trecho.
  Reitere.

Rotina para que se liste uma rotina em um trecho:
  Se a rotina for inexistente, retorne.
  Acrescente "| ROTINA: " para o trecho.
  Acrescente a representação interna da rotina desta rotina para o trecho (com separador). \ por exemplo: atribua [matiz] e [saturação] e [luminosidade] para [cor]
  Acrescente o texto CRLF para o trecho.
  Acrescente "| A rotina foi compilada? " para o trecho .
  Acrescente o sinalizador de compilação desta rotina para o trecho (com separador). \ A rotina foi compilada? SIM / NÃO
  Acrescente o texto CRLF para o trecho.
  Acrescente "| A rotina é um callback? " para o trecho.
  Acrescente o sinalizador de compatibilidade desta rotina para o trecho (com separador). \ A rotina é um callback? SIM / NÃO
  Acrescente o texto CRLF para o trecho.
  Acrescente "| A rotina é uma rotina decisora? " para o trecho.
  Acrescente o sinalizador de deliberação desta rotina para o trecho (com separador). \ A rotina é uma rotina decisora? SIM / NÃO
  Acrescente o texto CRLF para o trecho.
  Acrescente "| A rotina é uma função? " para o trecho.
  Acrescente o sinalizador de função desta rotina para o trecho (com separador). \ A rotina é uma função ? SIM / NÃO
  Acrescente o texto CRLF para o trecho.
  Acrescente "| Employs utilizados: |    " para o trecho.
  Acrescente o representação de emprego desta rotina para o trecho (com separador).
  Acrescente o texto CRLF para o trecho.
  Acrescente "| Tamanho dos parâmetros: " para o trecho.
  Acrescente o tamanho do parâmetro desta rotina para o trecho (com separador). \ Tamanho dos parâmetros. Exemplo: 16 ( 4 parâmetros)
  Acrescente " Tamanho das variáveis: " para o trecho.
  Acrescente o tamanho local desta rotina para o trecho (com separador). \Tamanho da variável local. Exemplo: 28
  Acrescente o texto CRLF para o trecho.
  Acrescente "| Endereço da Rotina: " para o trecho.
  Acrescente o endereço desta rotina para o trecho (cifra hexadecimal com separador). \ Endereço da rotina, Exemplo: 0041D000
  Insira quebra de linha no trecho.
  Liste os parâmetros desta rotina no trecho.
  Liste as variáveis locais desta rotina no trecho.
  Liste os fragmentos desta rotina no trecho.
  Insira quebra de linha no trecho.

Rotina para que se liste umas rotinas em um trecho:
  Obtenha uma rotina desde as rotinas.
  Se a rotina for inexistente, retorne.
  Liste a rotina no trecho.
  Reitere.

Rotina para que se liste umas rotinas depois de uma string em um trecho:
  Acrescente a string para o trecho.
  Insira quebra de linha no trecho (duas vezes).
  Se as rotinas estiverem vazias, retorne.
  Liste as rotinas no trecho.

Rotina para que se liste um arquivo fonte em um trecho:
  Se o arquivo fonte for inexistente, retorne.
  Acrescente "| ARQUIVO FONTE" para o trecho (com separador).
  Acrescente o endereço completo deste arquivo fonte para o trecho (com separador).
  Insira quebra de linha no trecho.

Rotina para que se liste uns arquivos fontes em um trecho:
  Obtenha um arquivo fonte desde os arquivos fontes.
  Se o arquivo fonte for inexistente, retorne.
  Liste o arquivo fonte no trecho.
  Reitere.

Rotina para que se liste uns arquivos fontes depois de uma string em um trecho:
  Acrescente a string para o trecho.
  Insira quebra de linha no trecho (duas vezes).
  Se os arquivos fontes estiverem vazios, retorne.
  Liste os arquivos fontes no trecho.
  Insira quebra de linha no trecho.

Rotina para que se liste um temporizador usando uma string em um trecho:
  Acrescente "| TEMPORIZADOR" para o trecho (com separador).
  Acrescente a string para o trecho (com separador).
  Acrescente a string deste temporizador para o trecho.
  Acrescente " milissegundos" para o trecho (com separador).
  Insira quebra de linha no trecho.

Rotina para que se liste os temporizadores depois de uma string em um trecho:
  Acrescente a string para o trecho.
  Insira quebra de linha no trecho (duas vezes).
  Liste o temporizador de operacionalização usando "Tempo de carregamento: " no trecho.
  Liste o temporizador de análise/verificação usando "Tempo de verificação: " no trecho.
  Liste o temporizador de resolução de tipos usando "Resolução de tipos: " no trecho.
  Liste o temporizador de resolução de variáveis globais usando "Resolução de variáveis globais: " no trecho.
  Liste o temporizador de compilação de cabeçalhos de rotina usando "Compilação de cabeçalhos de rotinas: " no trecho.
  Liste o temporizador de etapas de cálculo usando "Cálculos matemáticos: " no trecho.
  Liste o temporizador de adição de rotinas pré-definidas de mémoria  usando "Inclusão de rotinas pré-definidas: " no trecho.
  Liste o temporizador de ferramentas de catalogação usando "Catalogação de ferramentas: " no trecho.
  Liste o temporizador de compilação do conteúdo das rotinas usando "Compilação de rotinas: " no trecho.
  Liste o temporizador de adição de rotinas pré-definidas de inicialização usando "Inserção rotina de inicialização:" no trecho.
  Liste o temporizador de deslocamentos usando "Alinhamento de bytes na memória: " no trecho.
  Liste o temporizador de endereçamento usando "Endereçamento: " no trecho.
  Liste o temporizador de transmutação usando "Conversão em binário" no trecho.
  Liste o temporizador de vinculação usando "Vinculação: " no trecho.
  Liste o temporizador de escrita usando "Escrita e gravação no SO: " no trecho.
  Liste o temporizador deste compilador usando "Tempo total: " no trecho.
  Insira quebra de linha no trecho.

Rotina para que se liste um tipo em um trecho:
  Se o tipo for inexistente, retorne.
  Acrescente "| TIPO" para o trecho (com separador).
  Acrescente o nome deste tipo para o trecho (com separador).
  Acrescente " Plural: " para o trecho.
  Acrescente o nome plural deste tipo para o trecho (com separador).
  Acrescente " Comprimento: " para o trecho.
  Acrescente a quantidade de caracteres deste tipo para o trecho (cifra hexadecimal com separador).
  Acrescente " Tipo: " para o trecho.
  Acrescente o nome do tipo primitivo deste tipo para o trecho (com separador).
  Acrescente " Tipo base: " para o trecho.
  Acrescente o tipo base deste tipo para o trecho (com separador).
  Acrescente o nome do conteúdo deste tipo para o trecho (com separador).
  Acrescente o tipo do conteúdo deste tipo para o trecho (com separador).
  Acrescente " Razão de escala: " para o trecho.
  Acrescente a razão de escala deste tipo para o trecho (com separador).
  Insira quebra de linha no trecho.
  Liste os campos deste tipo no trecho.
  Insira quebra de linha no trecho.

Rotina para que se liste uns tipos em um trecho:
  Obtenha um tipo desde o tipos.
  Se o tipo for inexistente, retorne.
  Liste o tipo no trecho.
  Reitere.

Rotina para que se liste uns tipos depois de uma string em um trecho:
  Acrescente a string para o trecho.
  Insira quebra de linha no trecho (duas vezes).
  Se os tipos estiverem vazios, retorne.
  Liste os tipos no trecho.

Rotina para que se liste uma variável em um trecho:
  Se a variável for inexistente, retorne.
  Acrescente "| VARIÁVEL" para o trecho (com separador).
  Acrescente "Categoria: " para o trecho.
  Acrescente a categoria desta variável para o trecho (com separador).
  Acrescente "Compilada? " para o trecho.
  Acrescente o sinalizador de compilação desta variável para o trecho (com separador).
  Acrescente "Nome completo: " para o trecho.
  Acrescente o nome desta variável para o trecho (com separador).
  Acrescente "Nome resumido: " para o trecho.
  Acrescente o apelido desta variável para o trecho (com separador).
  Acrescente "Nome do tipo: " para o trecho.
  Acrescente o nome do tipo desta variável para o trecho (com separador).
  Acrescente "Tipo: " para o trecho.
  Acrescente o tipo desta variável para o trecho (com separador).
  Acrescente "Endereço (deslocamento): " para o trecho.
  Acrescente o endereço desta variável [or deslocamento] para o trecho (cifra hexadecimal com separador).
  Acrescente "Passagem por valor? " para o trecho.
  Acrescente o sinalizador de passagem por-valor desta variável para o trecho (com separador).
  Acrescente "Contagem: " para o trecho.
  Acrescente a contagem desta variável para o trecho (com separador).
  Acrescente "Referência somente? " para o trecho.
  Acrescente o sinalizador de referência desta variável para o trecho (com separador).
  Acrescente "Redefinição: " para o trecho.
  Acrescente o novo nome desta variável para o trecho (com separador).
  Acrescente "Conteúdo: " para o trecho.
  Acrescente o valor literal desta variável para o trecho (com separador).
  Converta o data desta variável para uma cifra hexadecimal.
  Acrescente "Conteúdo (valores hexadecimais): " para o trecho.
  Acrescente a cifra hexadecimal para o trecho (com separador).
  Insira quebra de linha no trecho.

Rotina para que se liste umas variáveis em um trecho:
  Obtenha uma variável desde as variáveis.
  Se a variável for inexistente, retorne.
  Liste a variável no trecho.
  Reitere.

Rotina para que se liste umas variáveis depois de uma string em um trecho:
  Acrescente a string para o trecho.
  Insira quebra de linha no trecho (duas vezes).
  Se as variáveis estiverem vazias, retorne.
  Liste as variáveis no trecho.
  Insira quebra de linha no trecho.



Rotina para que se mova um percorredor (símbolos):
  Avance o percorredor.







Rotina para que se alinhe as variáveis locais em uma rotina:
  Se a rotina for inexistente, retorne.
  Se a sinalizador de compilação desta rotina não estiver ativo, retorne.
  Limpe o tamanho local desta rotina.
  Itere.
    Se existir algum problema de compilação, retorne.
    Obtenha uma variável local desde as variáveis locais desta rotina.
    Se a variável local for inexistente, retorne.
    Se o variável local anterior desta variável local não for inexistente, atribua o deslocamento deste variável local anterior desta variável local ao deslocamento desta variável local.
    Atribua a quantidade de caracteres deste tipo desta variável local para uma quantidade de caracteres.
    Se a categoria desta variável local for "scratch", atribua a magnitude dum ponteiro à quantidade de caracteres.
    Arredonde a quantidade de caracteres para cima usando o múltiplo imediato de 4.
    Subtraia a quantidade de caracteres desde o deslocamento desta variável local.
    Adicione a quantidade de caracteres para o tamanho local desta rotina.
  Reitere.

Rotina para que se alinhe as variáveis locais em umas rotinas:
    Se existir algum problema de compilação, retorne.
    Obtenha uma rotina desde as rotinas.
    Se a rotina for inexistente, retorne.
    Alinhe as variáveis locais na rotina.
  Reitere.

Rotina para que se alinhe o parâmetros em uma rotina:
  Se a rotina for inexistente, retorne.
  Se a sinalizador de compilação desta rotina não estiver ativo, retorne.
  Limpe o tamanho do parâmetro desta rotina.
  Itere.
    Se existir algum problema de compilação, retorne.
    Obtenha um parâmetro desde os parâmetros desta rotina.
    Se o parâmetro for inexistente, retorne.
    Se o sinalizador de compatibilidade desta rotina estiver ativo, ative o sinalizador de passagem por-valor deste parâmetro.
    Se o parâmetro anterior deste parâmetro for inexistente, atribua 8 ao deslocamento deste parâmetro. \ skip o return address e saved ebp
    Se o parâmetro anterior deste parâmetro não for inexistente, atribua o deslocamento deste parâmetro anterior deste parâmetro mais 4 ao deslocamento deste parâmetro. \ all parâmetros são 4 endereço de byte s ou 4 byte values por callbacks
    Adicione 4 para a tamanho do parâmetro desta rotina.
  Reitere.

Rotina para que se alinhe o parâmetros em umas rotinas:
  Se existir algum problema de compilação, retorne.
  Obtenha uma rotina desde as rotinas.
  Se a rotina for inexistente, retorne.
  Alinhe o parâmetros na rotina.
  Reitere.

\Função para que se determine se uma string looks like English:
\Carregue o dicionário léxico.
\Se o dicionário léxico for inexistente, Mostre na tela "Não foi possível encontrar o dicionário léxico."; diga não.
\Se a string estiver em branco, diga não.
\Lance um subtexto sobre a string.
\Atribua o caractere final deste subtexto ao caractere inicial deste subtexto.
\Itere.
  \Se o caractere inicial deste subtexto é o caractere inicial desta string, pare.
  \Se o target deste caractere inicial deste subtexto for o caractere de espaço, adicione 1 para o caractere inicial deste subtexto; pare.
  \Subtraia 1 desde o caractere inicial deste subtexto.
\Reitere.
\Se o subtexto estiver no catálogo deste dicionário léxico, diga sim.
\Diga não.



Rotina para que se atribua o endereço EXE completo deste compilador para um endereço completo:
  Extraia um designador desde o endereço da pasta deste compilador.
  Remova alguma barra invertida final desde o designador.
  Atribua o endereço da pasta deste compilador junto com o designador seguido de ".exe" ao endereço completo.

Rotina para que se atribua o tamanho do executável deste compilador para um tamanho:
  Atribua 4096 [section base] ao tamanho.
  Adicione o tamanho desta seção de DLLs para o tamanho.
  Adicione o tamanho desta região de dados para o tamanho.
  Adicione o tamanho desta região de código para o tamanho.

Rotina para que se atribua o listagem endereço completo deste compilador para um endereço completo:
  Extraia um designador desde o endereço da pasta deste compilador.
  Remova alguma barra invertida final desde o designador.
  Atribua o endereço da pasta deste compilador junto com o designador seguido de ".lst" ao endereço completo.

Rotina para que se atribua um termo para um segundo termo:
  Atribua a variável deste termo à variável deste segundo termo.
  Atribua a frase deste termo ao frase deste segundo termo.

Rotina para que se carregue uns arquivos fonte usando um nível de profundidade: \ Jasper
  Leia os arquivos fonte usando o endereço completo deste compilador e o nível de profundidade.

Rotina para que se carregue uns arquivos fonte usando um endereço da pasta e um nível de profundidade: \Jasper
  Atribua ".pop" a uma nova extensão.
  Anexe o caractere NULL após a nova extensão.
  Se o nível de profundidade for menor do que 1, retorne.
  Preserve a nível de profundidade.
  Atribua o nível de profundidade para um segundo nível de profundidade.
  Subtraia 1 desde o segundo nível de profundidade.
  Itere.
    Se existir algum problema de compilação, retorne.
    Obtenha um item desde o endereço da pasta.
    Se o item não for encontrado, pare.
    Se a categoria deste item for "endereço de pasta", 
      Leia os arquivos fonte usando o endereço da pasta deste item e o segundo nível de profundidade;
      Reitere.
    Se a categoria deste item não for "arquivo", reitere.
    Se a extensão deste  item não for a nova extensão, reitere.
    Se o item parece ser encadernável, reitere.
    Se o item parece ser lexical, reitere.
    Adicione um arquivo fonte para os arquivos fontes usando o endereço completo deste item.
    Carregue o arquivo fonte.
  Reitere.

\ Rotina para que se carregue uns arquivos fontes:
  \ Atribua ".pop" a uma nova extensão.
  \ Anexe o caractere NULL após a nova extensão.
  \ Itere.
    \ Se existir algum problema de compilação, retorne.
    \ Obtenha um item desde o endereço da pasta deste compilador.
    \ Se o item não for encontrado, pare.
    \ Se a categoria deste item não for "arquivo", reitere.
    \ Se a extensão deste  item não for a nova extensão, reitere.
    \ Se o item parece ser encadernável, reitere.
    \ Adicione um arquivo fonte para os arquivos fontes usando o endereço completo deste item.
    \ Carregue o arquivo fonte.
  \ Reitere.





Rotina para que se reduza umas unidades semânticas por utilização:
  Obtenha uma unidade semântica desde as unidades semânticas.
  Se a unidade semântica for inexistente, retorne.
  Se o tipo desta unidade semântica for inexistente, reitere.
  Reduza o tipo desta unidade semântica para um tipo por utilização.
  Se o tipo não for inexistente, atribua o tipo ao tipo desta unidade semântica.
  Reitere.

Rotina para que se reduza um tipo para um segundo tipo por utilização:
  Atribua o tipo ao segundo tipo.
  Itere.
    Se o segundo tipo for inexistente, retorne.
    Se o nome deste segundo tipo for "texto hexadecimal", retorne.
    Se o nome deste segundo tipo for "string", retorne.
    Se o nome deste segundo tipo for "texto", retorne.
    Se o nome deste segundo tipo for "número", retorne.
    Se o nome deste segundo tipo for "ponteiro", retorne.
    Se o nome deste segundo tipo for "lista",
    Esvazie o segundo tipo;
    Retorne.
    \PAL
    Se o tipo base deste segundo tipo for o segundo tipo,
    Esvazie o segundo tipo;
    Retorne.
    Atribua o tipo base deste segundo tipo ao segundo tipo.
  Reitere.

Rotina para que se organize o catálogo de rotinas úteis:
    Se existir algum problema de compilação, retorne.
    Obtenha um recipiente usando o catálogo de rotinas úteis.
    Se o recipiente for inexistente, retorne.
    Se as referências deste recipiente estiverem vazios, reitere.
    Organize o catálogo de rotinas úteis usando as referências deste recipiente.
  Reitere.

Rotina para que se organize o catálogo de rotinas úteis usando umas referências:
    Obtenha uma referência desde as referências.
    Se a referência for inexistente, retorne.
    Atribua o ponteiro desta referência para uma rotina.
    Se a rotina for inexistente,
      Apresente uma mensagem de erro contendo "Erro interno #134. A rotina não foi localizada";
      Retorne.
    Copie as unidades semânticas desta rotina para umas unidades semânticas.
    Reduza as unidades semânticas por utilização.
    Catalogue a rotina usando as unidades semânticas e o catálogo geral de rotinas.
    Destrua as unidades semânticas.
  Reitere.

Rotina para que se remova alguns termos negativos desde umas unidades semânticas retornando um sinalizador:
  Desative o sinalizador.
  Permute as unidades semânticas com umas segunda unidades semânticas.
  Itere.
    Atribua a primeira unidade semântica destas segunda unidades semânticas para uma unidade semântica.
    Se a unidade semântica for inexistente, retorne.
    Remova a unidade semântica desde a segunda unidades semânticas.
    \PAL
    Se a string desta unidade semântica for "não",
    Inverta o sinalizador;
    Destrua a unidade semântica; Reitere.
    \CAL
    Acrescente a unidade semântica para as unidades semânticas.
    Se a string desta unidade semântica for "nothing",
    Inverta o sinalizador;
    Atribua "something" à string desta unidade semântica; Reitere.
    Se a string desta unidade semântica for "nada",
    Inverta o sinalizador;
    Atribua "something" à string desta unidade semântica; Reitere.
    \Se a string desta unidade semântica termina com "n't", inverta o sinalizador; remova final bytes desde a string desta unidade semântica usando 3; Reitere.
  Reitere.



Rotina para que se destrinche uma variável global:
  Se a variável global for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Se o corpo de variável global desta variável global não estiver em branco, destrinche a variável global (compile corpo).
  Se o nome do tipo desta variável global estiver em branco,
    Apresente uma mensagem de erro contendo "Erro #136. Tipo inválido: " junto com o nome desta variável global seguido de "' . O tipo da variável variável global está vazio." e o endereço local desta variável global;
    Retorne.
  Destrinche a variável global como uma variável.

Rotina para que se destrinche uma variável global (compile corpo):
  Se a variável global for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Lance um percorredor sobre o corpo de variável global desta variável global.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum valor literal,
    Apresente uma mensagem de erro contendo "Erro #137. Erro de tipo. O tipo: " junto com o segmento inicial deste percorredor seguido de "' deve ser do tipo literal." e o percorredor;
    Retorne.
  Compile um valor literal usando o percorredor.
  Se existir algum problema de compilação, retorne.
  Se o segmento inicial deste percorredor não estiver em branco,
    Apresente a mensagem de erro contendo "Erro #138. Esperado '.' " e o percorredor;
    Retorne.
  Se o nome do tipo desta variável global estiver em branco, atribua o nome deste tipo deste valor literal ao nome do tipo desta variável global.
  Atribua o valor literal ao valor literal desta variável global.
  Catalogue o valor literal.

Rotina para que se destrinche umas variáveis globais:
  Se existir algum problema de compilação, retorne.
  Obtenha uma variável global desde as variáveis globais.
  Se a variável global for inexistente, retorne.
  Destrinche a variável global.
  Reitere.




  Atribua "primeiro " junto com o nome deste tipo ao novo nome deste terceiro campo português.
  \Adicione um terceiro campo português feminino para os campos deste tipo encadeado usando "primeira " junto com o nome deste tipo e "primeira" e o nome deste tipo e o sinalizador de ignição.
  \Atribua "primeiro " junto com o nome deste tipo ao novo nome deste terceiro campo português feminino.
  Adicione um quarto campo para os campos deste tipo encadeado usando "último " junto com o nome deste tipo e "último" e o nome deste tipo e o sinalizador de ignição.
  Adicione um quarto campo português para os campos deste tipo encadeado usando "última " junto com o nome deste tipo e "última" e o nome deste tipo e o sinalizador de ignição.
  Atribua "último " junto com o nome deste tipo ao novo nome deste quarto campo português.
  \Adicione um quarto campo português feminino para os campos deste tipo encadeado usando "última " junto com o nome deste tipo e "última" e o nome deste tipo e o sinalizador de ignição.
  \Atribua "último " junto com o nome deste tipo ao novo nome deste quarto campo português feminino.
  Catalogue o tipo encadeado.






Rotina para que se arredonde tamanhos de zona para cima;
Rotina para que se arredonde para cima tamanhos de zona:
  Atribua a quantidade de caracteres desta seção de DLLs ao tamanho desta seção de DLLs.
  Arredonde para cima o tamanho desta seção de DLLs usando o múltiplo imediato de 4096.
  Atribua a quantidade de caracteres desta região de dados ao tamanho desta região de dados.
  Arredonde para cima o tamanho desta região de dados  usando o múltiplo imediato de 4096.
  Atribua a quantidade de caracteres desta região de código ao tamanho desta região de código.
  Arredonde para cima o tamanho desta região de código  usando o múltiplo imediato de 4096.







Rotina para que se examine uma cabeçalho de rotina usando um percorredor:
  Se existir algum problema de compilação, retorne.
  Se o segmento inicial deste percorredor estiver em branco, retorne.
  Atribua o caractere inicial deste segmento inicial deste percorredor ao caractere inicial deste cabeçalho de rotina.
  Atribua -1 ao caractere final deste cabeçalho de rotina.
  Itere.
    Se existir algum problema de compilação, retorne.
    Se o segmento inicial deste percorredor estiver em branco, retorne.
    Se o segmento inicial deste percorredor for o ponto&vírgula, retorne. \ *** alternate wording
    Se o segmento inicial deste percorredor for o sinal de dois pontos, retorne.
    Se o segmento inicial deste percorredor for o ponto final, retorne.
    Atribua o caractere final deste segmento inicial deste percorredor ao caractere final deste cabeçalho de rotina.
    Mova o percorredor (usando diretrizes de compilação).
  Reitere.

Rotina para que se scrub um catálogo:
  Itere.
    Obtenha um recipiente usando o catálogo.
    Se o recipiente for inexistente,
      Retorne.
    Se as referências deste recipiente estiverem vazios,
      Reitere.
    Scrub as referências deste recipiente.
  Reitere.

Rotina para que se scrub umas referências:
  Permute as referências com uns segunda referências.
  Itere.
    Atribua a primeira referência destes segunda referências para uma referência.
    Se a referência for inexistente,
      Retorne.
    Remova a referência desde a segunda referências.
    Se o ponteiro deste referência for inexistente,
      Destrua a referência;
      Reitere.
    Acrescente a referência para as referências.
  Reitere.

Rotina para que se ative o sinalizador de compilação em uma variável;
Rotina para que se ligue o sinalizador de compilação em uma variável:
  Se a variável for inexistente, retorne.
  Se o sinalizador de compilação desta variável [já] estiver ativo, retorne.
  Ative o sinalizador de compilação desta variável.
  Se a categoria desta variável não for "global", retorne.
  Se o valor literal desta variável for inexistente, retorne.
  Encontre uma rotina usando "atribua" e o tipo deste valor literal desta variável e "para" e o tipo desta variável.
  Se a rotina for inexistente,
    Encontre a rotina usando "converta" e o tipo deste valor literal desta variável e "para" e o tipo desta variável;
    Ative um sinalizador.
  Se a rotina for inexistente,
    Apresente uma mensagem de erro contendo "Erro #172. O tipo e o valor da variável variável global  não estão correspondendo." e o endereço local desta variável;
    Retorne.
  Compile o corpo referente à rotina.
  Se o sinalizador estiver ativo, atribua "converta o " junto com o nome deste valor literal desta variável seguido de " para o " junto com o nome desta variável seguido de ". " ao texto inicializador desta variável.
  Se o sinalizador não estiver ativo, atribua "atribua o " junto com o nome deste valor literal desta variável seguido de " para o " junto com o nome desta variável seguido de ". " ao texto inicializador desta variável. \ Era " ao ". NÃO PODIA MUDAR O " ao " não sei o porquê





Rotina para que se transforme um fragmento em código hexadecimal:
  Se existir algum problema de compilação, retorne.
  Se o fragmento for inexistente, retorne.
  Se a etiqueta deste fragmento for o etiqueta de inserção de endereço [na stack],
    Transforme o fragmento em código hexadecimal (empilhamento de endereço);
    Retorne.
  Se a etiqueta deste fragmento for a etiqueta de demanda interna,
    Transforme o fragmento em código hexadecimal (Demanda Interna);
    Retorne.
  Se a etiqueta deste fragmento for o etiqueta de carregamento de endereço,
    Transforme o fragmento em código hexadecimal (load endereço);
    Retorne.
  Se a etiqueta deste fragmento for a etiqueta de acréscimo,
    Transforme o fragmento em código hexadecimal (increment);
    Retorne.
  Se a etiqueta deste fragmento for o etiqueta de redirecionamento,
    Transforme o fragmento em código hexadecimal (cláusula de redirecionamento);
    Retorne.
  Se a etiqueta deste fragmento for o etiqueta de desvio falso,
    Transforme o fragmento em código hexadecimal (desvio caso resultado negativo);
    Retorne.
  Se a etiqueta deste fragmento for a etiqueta de negação lógica,
    Transforme o fragmento em código hexadecimal (negação lógica);
    Retorne.
  Se a etiqueta deste fragmento for o etiqueta de retorno,
    Transforme o fragmento em código hexadecimal (cláusula de retorno);
    Retorne.
  Se a etiqueta deste fragmento for a etiqueta de repetição,
    Transforme o fragmento em código hexadecimal(cláusula de repetição);
    Retorne.
  Se a etiqueta deste fragmento for o etiqueta de interrupção,
    Transforme o fragmento em código hexadecimal (cláusula de interrupção);
    Retorne.
  Se a etiqueta deste fragmento for o etiqueta preliminar,
    Transforme o fragmento em código hexadecimal (etapa preliminar);
    Retorne.
  Se a etiqueta deste fragmento for o etiqueta conclusiva,
    Transforme o fragmento em código hexadecimal (etapa conclusiva);
    Retorne.
  Se a etiqueta deste fragmento for o etiqueta de inserção de valor [na stack],
    Transforme o fragmento em código hexadecimal (empilhamento de valor);
    Retorne.
  Se a etiqueta deste fragmento for a etiqueta de demanda externa,
    Transforme o fragmento em código hexadecimal (Demanda Externa);
    Retorne.
  Se a etiqueta deste fragmento for o etiqueta de carregamento de registrador EAX,
    Transforme o fragmento em código hexadecimal (atribuição de EAX);
    Retorne.
  Se a etiqueta deste fragmento for o etiqueta de obtenção do registrador EAX,
    Transforme o fragmento em código hexadecimal (registrador EAX);
    Retorne.
  Se a etiqueta deste fragmento for a etiqueta de demanda indireta,
    Transforme o fragmento em código hexadecimal (Demanda Indireta);
    Retorne.
  Se a etiqueta deste fragmento for a etiqueta de endereço de rotina,
    Transforme o fragmento em código hexadecimal (endereço de rotina);
    Retorne.

Rotina para que se transforme um fragmento em código hexadecimal (cláusula de interrupção):
  Atribua a etiqueta de repetição para uma etiqueta.
  Encontre um segundo fragmento usando o fragmento e a etiqueta.
  Se o segundo fragmento for inexistente, atribua a etiqueta de finalização para a etiqueta. \ para break sem um loop ou depois de um loop
  Encontre um terceiro fragmento usando o último fragmento destes fragmentos desta rotina utilizada atualmente e a etiqueta (regressivamente).
  Se o terceiro fragmento for inexistente,
    Apresente uma mensagem de erro contendo "Erro interno #173. Fragmento não encontrado.";
    Retorne.
  Se o próximo fragmento deste terceiro fragmento for inexistente,
    Apresente a mensagem de erro contendo "Erro interno #174. Fragmento não encontrado.";
    Retorne.
  Acrescente $E9 [jmp] e o endereço deste próximo fragmento deste terceiro fragmento para o fragmento. \ JMP o endereço de destino

Rotina para que se transforme um fragmento em código hexadecimal (Demanda Externa):
  Acrescente $FF15 [call] e o endereço desta função deste fragmento para o código deste fragmento. \ Processe [o endereço desta função deste fragmento ]
  \ The above of generates the machine code for a call to the Windows operating system.
  \The op code is specified, in hexadecimal ($FF15) and the rest of the instruction is the address of the função address of the target rotina, which is appended to the op code.

Rotina para que se transforme um fragmento em código hexadecimal (Demanda Indireta):
  Acrescente a instrução de carregamento de endereço para o código deste fragmento usando a variável deste fragmento. \ coloca endereço para edx
  Acrescente $FF12 para o código deste fragmento. \ call [edx]

Rotina para que se transforme um fragmento em código hexadecimal (Demanda Interna):
  Obtenha um endereço usando a rotina deste fragmento.
  Acrescente $E8 e o endereço para o fragmento. \ call o endereço da rotina do fragmento

Rotina para que se transforme um fragmento em código hexadecimal (cláusula de redirecionamento):
  Acrescente $8B95 e o deslocamento desta variável deste fragmento para o código deste fragmento. \ mov edx,[ebp+ o deslocamento desta variável deste fragmento]
  Acrescente $8B12 para o código deste fragmento. \ mov edx,[edx]
  Acrescente $8995 e o deslocamento desta variável deste fragmento para o código deste fragmento. \ mov [ebp+ o deslocamento desta variável deste fragmento]

\ THE EPILOG OF EVERY ROUTINE REMOVES ANY LOCAL VARIABLES, RESTORES THE EBP, AND RETURNS TO THE CALLER, POPPING ANY PARAMETERS AS HE DOES.
Rotina para que se transforme um fragmento em código hexadecimal (etapa conclusiva):
  Se o sinalizador de compatibilidade desta rotina utilizada atualmente estiver ativo,
    Acrescente $5F5E5B para o código deste fragmento. \ pop edi; pop esi; pop ebx;
  Acrescente $8BE5 para o código deste fragmento. \ mov esp,ebp -> não seria 89EC?
  Acrescente $5D para o código deste fragmento. \ pop ebp
  Acrescente $C2 e o tamanho do parâmetro desta rotina utilizada atualmente para o código deste fragmento. \ ret + o tamanho do parâmetro da rotina utilizada atualmente

Rotina para que se transforme um fragmento em código hexadecimal (cláusula de retorno):
  Encontre um segundo fragmento usando o fragmento e a etiqueta de finalização.
  Se o segundo fragmento for inexistente,
    Apresente uma mensagem de erro contendo "Erro interno #175. Fragmento não encontrado.";
    Retorne.
  Acrescente $E9 e o endereço deste segundo fragmento para o fragmento. \ jmp + o address da destination

Rotina para que se transforme um fragmento em código hexadecimal (increment):
  Se a variável deste fragmento for inexistente,
    Apresente uma mensagem de erro contendo "Erro interno #176. A variável '" junto com o nome desta variável deste fragmento seguido de "' do fragmento não foi encontrada.";
    Retorne.
  Se a categoria desta variável deste fragmento não for "scratch",
    Apresente a mensagem de erro contendo "Erro interno #177. A categoria da variável '" junto com o nome desta variável deste fragmento seguido de "' não é 'scratch'. Categoria detectada: '" junto com a categoria desta variável deste fragmento seguido de "'.";
    Retorne.
  Acrescente $8185 e o deslocamento desta variável deste fragmento e o número deste fragmento para o código deste fragmento. \ add [ebp+ o deslocamento desta variável deste fragmento], o número deste fragmento

Rotina para que se transforme um fragmento em código hexadecimal (desvio caso resultado negativo):
  Encontre um segundo fragmento usando o fragmento e o etiqueta delimitadora de bloco condicional.
  Se o segundo fragmento for inexistente,
    Apresente uma mensagem de erro contendo "Erro interno #178. Fragmento não encontrado.";
    Retorne.
  Acrescente $83F800 para o código deste fragmento. \ cmp eax,0
  Acrescente $0F84 e o endereço deste segundo fragmento para o fragmento. \ je + o address da destination

Rotina para que se transforme um fragmento em código hexadecimal (load endereço):
  Acrescente a instrução de carregamento de endereço para o código deste fragmento usando a variável deste fragmento. \ atribui endereço para edx
  Acrescente $8995 e o deslocamento desta segunda variável deste fragmento para o código deste fragmento. \ mov [ebp+ o deslocamento desta variável deste fragmento],edx

\Rotina para que se transforme um fragmento em código hexadecimal (atribuição de EAX):
\Acrescente a instrução de carregamento de endereço para o código deste fragmento usando a variável deste fragmento. \ atribua endereço para edx
\Se a variável deste fragmento for inexistente,
  \Apresente uma mensagem de erro contendo "Internal erro - transforme um fragmento em código hexadecimal (atribuição de EAX)";
  \Retorne.
\Se o tipo desta variável deste fragmento for inexistente,
  \Apresente uma mensagem de erro contendo "Internal erro 2 - transforme um fragmento em código hexadecimal (atribuição de EAX)";
  \Retorne.
 \Se a quantidade de caracteres deste tipo desta variável deste fragmento não for 4,
   \Apresente uma mensagem de erro contendo "Internal erro 3 - transforme um fragmento em código hexadecimal (atribuição de EAX)";
   \Retorne.
\Acrescente $8B02 para o código deste fragmento. \ mov eax,[edx]

Rotina para que se transforme um fragmento em código hexadecimal (atribuição de EAX):
  Acrescente $B8 e o sinalizador deste fragmento para o código deste fragmento. \ mov eax,sinalizador
\Acrescente a instrução de carregamento de endereço para o código deste fragmento usando a variável do fragmento. \ atribua endereço para edx
\Se a variável deste fragmento for inexistente,
  \apresente uma mensagem de erro contendo "Internal erro - transforme um fragmento em código hexadecimal (atribuição de EAX)";
  \Retorne.
\Se o tipo desta variável deste fragmento for inexistente,
  \apresente uma mensagem de erro contendo "Internal erro 2 - transforme um fragmento em código hexadecimal (atribuição de EAX)";
  \Retorne.
\Se a quantidade de caracteres deste tipo desta variável deste fragmento não for 4,
  \apresente uma mensagem de erro contendo "Internal erro 3 - transforme um fragmento em código hexadecimal (atribuição de EAX)";
  \Retorne.
\Acrescente $8B02 para o código deste fragmento. \ mov eax,[edx]

Rotina para que se transforme um fragmento em código hexadecimal (negação lógica):
  Acrescente $83F001 para o código deste fragmento. \ xor eax,1

\ THE PROLOG OF EVERY PLAIN ENGLISH ROUTINE BEGINS BY SAVING THE CALLER'S EBP ON THE STACK, JUST ABOVE THE RETURN ADDRESS.
Rotina para que se transforme um fragmento em código hexadecimal (etapa preliminar):
  Acrescente $55 para o código deste fragmento. \ push ebp -> saves the contents of the EBP register on the stack.
  Acrescente $8BEC para o código deste fragmento. \ mov ebp,esp -> puts the contents of the ESP register into the EBP register
  Atribua o tamanho local desta rotina utilizada atualmente dividido por 4 para um número.
  Se o número não for 0,
    Acrescente $B9 \ mov ecx,number;  -> sets up the loop that will clear enough space on the stack for the routine's local variables
    e o número 
    e $6A004975FB \ loop: push 0; dec ecx; jnz loop -> a loop that pushes enough zeros onto the stack to initialize the local variables.
    para o código deste fragmento.
  Se o sinalizador de compatibilidade desta rotina utilizada atualmente estiver ativo,
    Acrescente $535657 para o código deste fragmento. \ push ebx, esi, edi ->  save the EBX, ESI, and EDI registers on the stack.

Rotina para que se transforme um fragmento em código hexadecimal (empilhamento de endereço):
  Acrescente a instrução de carregamento de endereço para o código deste fragmento usando a variável deste fragmento. \ atribua endereço para edx
  Acrescente $52 para o código deste fragmento. \ push edx -> push the 4-byte value in edx onto the stack

Rotina para que se transforme um fragmento em código hexadecimal (empilhamento de valor):
  Acrescente a instrução de carregamento de endereço para o código deste fragmento usando a variável deste fragmento. \ atribua endereço para edx
  Se a variável deste fragmento for inexistente,
    Apresente uma mensagem de erro contendo "Erro interno #179. Fragmento não encontrado.";
    Retorne.
  Se o tipo desta variável deste fragmento for inexistente,
    Apresente a mensagem de erro contendo "Erro interno #180. O tipo '" 
      junto com o nome deste tipo desta variável deste fragmento seguido de "' da variável '" 
      junto com o nome desta variável deste fragmento seguido de "' não foi encontrado.";
    Retorne.
  Atribua a quantidade de caracteres deste tipo desta variável deste fragmento para uma quantidade de caracteres.
  Se a quantidade de caracteres for 4,
    Acrescente $FF32 para o código deste fragmento;
    Retorne. \ push [edx]
  Se a quantidade de caracteres for 2,
    Acrescente $66FF32 para o código deste fragmento;
    Retorne. \ push word ptr [edx]
  Se a quantidade de caracteres for 1,
    Acrescente $0FB61252 para o código deste fragmento;
    Retorne. \ movzxb edx,[edx]; push edx
  Apresente a mensagem de erro contendo "Erro interno #181. Tamanho do fragmento inválido".

Rotina para que se transforme um fragmento em código hexadecimal (cláusula de repetição):
  Encontre um segundo fragmento usando o fragmento e o etiqueta de laço (regressivamente).
  Se o segundo fragmento for inexistente,
    Apresente uma mensagem de erro contendo "Erro interno #182. Fragmento não encontrado. ";
    Retorne.
  Acrescente $E9 e o endereço deste segundo fragmento para o fragmento. \ jmp o address da destination

Rotina para que se transforme um fragmento em código hexadecimal (endereço de rotina):
  Acrescente a instrução de carregamento de endereço para o código deste fragmento usando a variável deste fragmento. \ atribui o endereço para o registrador edx
  Se a rotina deste fragmento for inexistente,
    Apresente uma mensagem de erro contendo "Erro interno #183. Rotina não encontrada.";
    Retorne.
  Obtenha um endereço usando a rotina deste fragmento.
  Acrescente $C702 e o endereço para o código deste fragmento. \ mov [edx],the endereço

Rotina para que se transforme um fragmento em código hexadecimal (registrador EAX):
  Acrescente a instrução de carregamento de endereço para o código deste fragmento usando a variável deste fragmento. \ atribui o endereço para o registrador edx
  Se a variável deste fragmento for inexistente,
    Apresente uma mensagem de erro contendo "Erro interno #184. A variável '" 
      junto com o nome desta variável deste fragmento seguido de "' não foi encontrada.";
    Retorne.
  Se o tipo desta variável deste fragmento for inexistente,
    Apresente a mensagem de erro contendo "Erro interno #185. O tipo '" junto com
       o nome deste tipo desta variável deste fragmento seguido de "' da variável '"
      junto com o nome desta variável deste fragmento seguido de "' não encontrado.";
    Retorne.
  Atribua a quantidade de caracteres deste tipo desta variável deste fragmento para uma quantidade de caracteres.
  \Se a quantidade de caracteres for 8,
    \Acrescente $67488902  para o código deste fragmento; \ mov [edx],rax
    \Retorne.   
  Se a quantidade de caracteres for 4,
    Acrescente $8902 para o código deste fragmento; \ mov [edx],eax
    Retorne. 
  Se a quantidade de caracteres for 2,
    Acrescente $668902 para o código deste fragmento; \ mov [edx],ax
    Retorne. 
  Se a quantidade de caracteres for 1,
    Acrescente $8802 para o código deste fragmento; \ mov [edx],al
    Retorne. 
  [Se a quantidade de caracteres não for 1, 2 ou 4] 
  Apresente a mensagem de erro contendo "Erro interno #186. O tipo '" junto com o tipo desta variável deste fragmento seguido de "deste fragmento possui um tamanho inválido".

Rotina para que se transforme uns fragmentos em código hexadecimal:
  Itere.
    Se existir algum problema de compilação, retorne.
    Obtenha um fragmento desde o fragmentos.
    Se o fragmento for inexistente, retorne.
    Transforme o fragmento em código hexadecimal.
  Reitere.

Rotina para que se transforme uma rotina em código hexadecimal:
  Se existir algum problema de compilação, retorne.
  Se a rotina for inexistente, retorne.
  Se o representação de emprego desta rotina não estiver em branco, retorne.
  Se o sinalizador de compilação desta rotina não estiver ativo, retorne.
  Atribua a rotina à rotina utilizada atualmente.
  Transforme os fragmentos desta rotina em código hexadecimal.

Rotina para que se transforme umas rotinas em código hexadecimal:
  Itere.
    Se existir algum problema de compilação, retorne.
    Obtenha uma rotina desde as rotinas.
    Se a rotina for inexistente, pare.
    Transforme a rotina em código hexadecimal.
  Reitere.

\ Rotina nova criada pelo Dahn para - reverse functions
\ To put o xxx uv a/the yyy para zzz
\ internally we turn this para "to put a/the yyy's xxx para zzz"
Rotina para que se compile o cabeçalho referente para uma rotina usando um percorredor (função do possessivo reverso):
  Se existir algum problema de compilação, retorne.
  Ative o sinalizador de função desta rotina.
  Adicione uma unidade semântica para as unidades semânticas desta rotina usando "atribua".
  Mova o percorredor (usando diretrizes de compilação). \ ignora "atribua"
  Mova o percorredor (usando diretrizes de compilação). \ ignora "the" ou um artigo definido em português
  Examine um nome usando o percorredor. \ nome do campo
  Mova o percorredor (usando diretrizes de compilação). \ ignora "uv" ou "de"
  Se o segmento inicial deste percorredor for algum artigo indefinido, ative um sinalizador.
  Se o sinalizador estiver ativo, compile as unidades semânticas desta rotina e o parâmetros desta rotina usando o percorredor (artigo indefinido).
  Se o sinalizador não estiver ativo, compile as unidades semânticas desta rotina e o parâmetros desta rotina usando o percorredor (artigo definido).
  Adicione uma segunda unidade semântica para as unidades semânticas desta rotina usando "'s " junto com o nome.
  Se o segmento inicial deste percorredor não for alguma função possessiva reversa into,
    Apresente uma mensagem de erro contendo "Erro #187. Erro de sintaxe. Esperado: 'para'. Encontrado: '" junto com o segmento inicial deste percorredor seguido de "'." e o percorredor;
    Retorne.
  Adicione uma terceira unidade semântica para as unidades semânticas desta rotina usando "para".
  Converta as unidades semânticas desta rotina para uma representação interna da rotina.
  Se a representação interna da rotina estiver no catálogo geral de rotinas,
    Apresente a mensagem de erro contendo "Erro #188. Erro. A rotina para que se " junto com a representação interna da rotina seguido de ": já havia sido definida." e o endereço local desta rotina;
    Retorne.
  Catalogue a rotina usando as unidades semânticas desta rotina e o catálogo geral de rotinas.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum artigo indefinido,
    Apresente a mensagem de erro contendo "Erro #189. Erro. Esperado 'um/uma'. Encontrado: '" junto com o segmento inicial deste percorredor seguido de "'." e o percorredor;
    Retorne.
  Compile as unidades semânticas desta rotina e o parâmetros desta rotina usando o percorredor (artigo indefinido).
  Se o segmento inicial deste percorredor não estiver em branco,
    Apresente a mensagem de erro contendo "Erro #190. Comandos inválidos no final desta rotina." e o percorredor;
    Retorne.
  Converta as unidades semânticas desta rotina para a representação interna da rotina desta rotina.
  Catalogue a rotina usando as unidades semânticas desta rotina e o catálogo geral de rotinas. \ Para employs

\ Rotina nova criada pelo Dahn para - reverse functions
\ para atribua o xxx uv a/the yyy para zzz
Função para que se determine se um percorredor é o início de alguma função possessiva reversa:
  Se o sinalizador de erros deste compilador estiver ativo, diga não.
  Se o segmento inicial deste percorredor não for algum comando de atribuição, diga não.
  Preserve o percorredor.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum artigo definido, diga não.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Se o percorredor não for sobre algum possessivo reverso, diga não.
  Diga sim.

\finalmente  acabou