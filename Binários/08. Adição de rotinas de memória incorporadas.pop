Rotina para que se compile um endereço da pasta (adição de rotinas de memória incorporadas): \ #008
  Se existir algum problema de compilação, retorne.
  Escreva "Adicionando tarefas predefinidas na memória..." junto com o texto CRLF para StdOut.
  Comece o temporizador de adição de rotinas pré-definidas de mémoria .
  Adicione as rotinas de alocação e desalocação e finalização e destruição. \ <----------------
  Suspenda o temporizador de adição de rotinas pré-definidas de mémoria .

Rotina para que se adicione as rotinas de alocação e desalocação e finalização e destruição:
  Se existir algum problema de compilação, retorne.
  Obtenha um tipo desde os tipos.
  Se o tipo for inexistente, retorne.
  Adicione a rotina de finalização para o tipo. \ <-------
  Adicione a rotina de alocação para o tipo. \ <----------
  Adicione a rotina de desalocação para o tipo.
  Adicione a rotina de destruição para o tipo.
 Reitere.

Rotina para que se adicione a rotina de finalização para um tipo:
  Se o tipo for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Se o tipo não deveria ser finalizado, retorne. \  <--------------
  Se o nome deste tipo for "string",
    Adicione a rotina de finalização para o tipo (cadeia de caracteres); \ <----------------
    Retorne.
  \Se o nome deste tipo for "texto",
    \Adicione a rotina de finalização para o tipo (cadeia de caracteres);
    \Retorne.
  \Se o nome deste tipo for "cadeia de caracteres",
    \Adicione a rotina de finalização para o tipo (cadeia de caracteres);
    \Retorne.
  Se o tipo puder ser reduzido para "string", retorne. \ impede a geração de finalizadores para tipos derivados de string
  \Se o tipo puder ser reduzido para "texto", retorne.
  \Se o tipo puder ser reduzido para "cadeia de caracteres", retorne.
  Adicione a rotina de finalização para o tipo (estrutura). \ <------------

Função para que se determine se um tipo deveria ser finalizado: [determina se o compilador deveria liberar a memória alocada para algum tipo]
  \The frase "should be finalized" means "ought to be/needs to be automatically deallocated".
  Se o tipo for inexistente, diga não.
  Se o tipo puder ser reduzido para "subtexto", diga não.\ substrings point to (parts of) real strings that get deallocated elsewhere
  Se o tipo puder ser reduzido para "string", diga sim.\ the normal case for strings
  Se o tipo puder ser reduzido para "texto", diga sim.\ the normal case for strings
  Se os campos deste tipo deveriam ser finalizados, diga sim.\ this is for strings dentro de records
  Diga não.

Função para que se determine se uns campos deveriam ser finalizados;
Função para que se determine se uns campos deveria ser finalizado:
  [Itere.]
    Obtenha um campo desde o campos.
    Se o campo for inexistente, diga não.
    Se o tipo deste campo deveria ser finalizado, diga sim. \ <--------------
  Reitere.


Rotina para que se adicione a rotina de finalização para um tipo (cadeia de caracteres):
  Se o tipo for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Adicione uma rotina para as rotinas usando nil [como o endereço local da rotina]. \ <---------------
  Acrescente "~Finalize um " junto com o nome deste tipo para a string do cabeçalho desta rotina.
  Acrescente "Decodifique $50. " para a string do corpo desta rotina. \ push eax -> Empilha o valor presente no registrador EAX na stack
  \ A instrução push primeiramente subtrai 4 do valor do registrador ESP, depois coloca o operando no endereço de memória constante no registrador [ESP].
  \ A subtração é egetuada porque nos processadores x86 a stack cresce pra baixo, ou seja começa no valor menor e vai reduzindo.
  Acrescente "Desassocie o caractere inicial de esta string . " para a string do corpo desta rotina. \\ traduzir "string" aqui
  Acrescente "Decodifique $58." para a string do corpo desta rotina. \ pop eax -> Remove o elemento do topo da stack e armazena-o na memória, 
  \ mais especificamente no endereço contido no registador eax.  
  \ The pop instruction removes the 4-byte data element desde the top of the hardware-supported stack into the specified operand (i.e. register or memory location).
  \ Primeiramente ela move the 4 bytes located sob memory location [SP] into the specified register or memory location, and then increments memory location [SP] by 4.
  Lance a cabeçalho de rotina desta rotina sobre a string do cabeçalho desta rotina.
  Lance as instruções desta rotina sobre a string do corpo desta rotina.
  Compile o cabeçalho referente à rotina. \ <-----------

Rotina para que se adicione a rotina de finalização para um tipo (estrutura):
  Se o tipo for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Adicione uma rotina para as rotinas usando nil.
  Acrescente "~Finalize um " junto com o nome deste tipo para a string do cabeçalho desta rotina.
  Acrescente "Decodifique $50. " para a string do corpo desta rotina. \ push eax -> coloca o valor de 32 bits presentes em EAX na pilha
  \ A instrução push coloca seu operando no topo da pilha de hardware na memória.
  \ Especificamente, a instrução push primeiro decrementa ESP em 4 e depois coloca seu operando no conteúdo do local de 32 bits no endereço [ESP].
   \ESP (o ponteiro da pilha) é decrementado por push, pois a pilha x86 cresce para baixo - ou seja, a pilha cresce dos endereços maiores para os endereços menores.
  Itere.
    Obtenha um campo desde os campos deste tipo.
    Se o campo for inexistente, pare.
    Se o tipo deste campo não deveria ser finalizado, reitere.
    Acrescente "~Finalize o " junto com o nome deste tipo seguido de "'s " junto com o nome deste campo seguido de ". " para a string do corpo desta rotina.
  Reitere.
  Acrescente "Decodifique $58." para a string do corpo desta rotina. \ pop eax -> pop the top element of the stack into memory ar the four bytes starting at location EAX.
  \ pop 4 bytes off the stack and put them into eax
  \ The pop instruction removes the 4-byte data element desde the top of the hardware-supported stack into the specified operand (i.e. register or memory location).
  \It primeiro moves the 4 bytes located sob memory location [SP] into the specified register or memory location, and then increments memory location [SP] by 4.
  Lance a cabeçalho de rotina desta rotina sobre a string do cabeçalho desta rotina.
  Lance as instruções desta rotina sobre a string do corpo desta rotina.
  Compile o cabeçalho referente à rotina. \ <-----------

Rotina para que se adicione uma rotina para umas rotinas usando um endereço local:
  Crie a rotina. \ **********
  Acrescente a rotina para as rotinas.
  Atribua o endereço local ao endereço local desta rotina.

Rotina para que se crie uma rotina:
  Aloque memória à rotina.

Rotina para que se adicione a rotina de alocação para um tipo:
  Se o tipo for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Se o tipo não puder ser reduzido para "ponteiro", retorne.
  Se o tipo do conteúdo deste tipo for inexistente, retorne.
  Adicione uma rotina para as rotinas usando nil. \  <--------
  Acrescente "Aloque memória para um " junto com o nome deste tipo para a string do cabeçalho desta rotina. \ traduzir aqui
  Acrescente "Associe o " junto com o nome deste tipo seguido de " usando " para a string do corpo desta rotina. \Nomeie
  Acrescente a quantidade de caracteres deste tipo do conteúdo deste tipo seguido de "." para a string do corpo desta rotina.
  Lance a cabeçalho de rotina desta rotina sobre a string do cabeçalho desta rotina.
  Lance as instruções desta rotina sobre a string do corpo desta rotina.
  Compile o cabeçalho referente à rotina.



